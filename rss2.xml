<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>前端路上</title>
    <link>https://refined-x.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>原创前端技术博客，致力于分享前端学习路上的第一手资料，专注web开发、移动端开发、混合应用开发、前端自动化、前端工程化，Nodejs开发。</description>
    <pubDate>Thu, 12 Jul 2018 01:18:28 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>如何计算一款保险的杠杆</title>
      <link>https://refined-x.com/2018/07/02/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E4%B8%80%E6%AC%BE%E4%BF%9D%E9%99%A9%E7%9A%84%E6%9D%A0%E6%9D%86/</link>
      <guid>https://refined-x.com/2018/07/02/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E4%B8%80%E6%AC%BE%E4%BF%9D%E9%99%A9%E7%9A%84%E6%9D%A0%E6%9D%86/</guid>
      <pubDate>Mon, 02 Jul 2018 07:06:20 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这篇文章向大家分享一个复利计算小工具，用来模拟保险年缴保费的支出情况，并用复利的方式算出这些保费在相同年数里的理财收入，技术含量极低，但如果你像我一样近期有买保险需求的话，这个小工具可以帮助你快速衡量一款保险产品的投入产出杠杆。</p><h2 id="聊聊保险"><a href="#聊聊保险" class="headerlink" title="聊聊保险"></a>聊聊保险</h2><p>自从宝宝出生后，突然感觉自己的健康风险特别高，为什么呢，说白了就一个原因：<strong>收入来源单一</strong>，孩子在不断长大，父母在不断老去，家庭支出在可预见的未来越来越高，这时候作为家庭经济支柱的自己如果出了问题，后果不堪设想，所以有一天我的脑子里突然响起一个声音：我要买保险。说到保险很多人第一反应是<code>骗子、坑、水深、感觉没啥用</code>，这也是我曾经的想法，但当有一天你也看到自己珍视的东西暴露在不可承受的风险之下时，可能也会重新考虑保险这件事。其实<strong>保险的本质是杠杆</strong>，这个杠杆允许你交一小笔钱，待出现风险时拿到一笔大钱，帮助家庭度过难关。在这个本质的基础上，如今的保险产品衍生出了太多花样，我花了不少时间才大致理清一个脉络，这里就不展开说了。</p><h2 id="定投复利计算器"><a href="#定投复利计算器" class="headerlink" title="定投复利计算器"></a>定投复利计算器</h2><p>前面大致说了这个计算器是干什么用的，这里再详细解释一下。以我自己为例，准备买人生第一款商业保险，重疾险，对于暂时手头没有那么宽裕的人（===穷人）来说，只能选择消费型、低保额、保终身，于是就锁定了全网最便宜的消费型重疾险<a href="https://cps.qixin18.com/zt1029065/product/detail-2170-2726.html" target="_blank" rel="external">百年康惠保</a>，保额我打算先来30万，以后宽裕了再增加（maybe），缴费年限越长年费越少（总额会多一些），老夫已经30了，希望20年内缴完，所以保费情况是这样的：</p><p><a href="https://cps.qixin18.com/zt1029065/product/detail-2170-2726.html" target="_blank" rel="external"><img src="https://refined-x.com/asset/baofei-kanghuibao.png" alt="此处输入图片的描述"></a></p><p>每年缴3390元，缴费20年，那么此时我最想知道，同样的时间和金钱付出，如果用在普通理财产品上会有怎样的收益？假设自己可以通过理财达到跟保险保额差不太多的收益，那显然就不需要买保险了。OK，我平时工资一般就放在微信钱包-零钱通里，年化收益率大致4%，如果我把每年要缴给保险公司的3390元都放进零钱通，20年后我一共有多少钱？算法很简单，第一年投入的年费作为初始本金，到年底会获得4%的受益，然后连本带息再加上第二年的年费一起作为第二年的本金，继续按照4%的收益率计算年底收益，以此类推直到20年，得到最终结果。</p><p><a href="//refined-x.com/projects/codes/interest.html">复利计算器</a>就是用来做这件事的，最终计算结果为104983，也就是10万出头，而这款产品的保额是30万，那么可以得出结论，以我的理财能力这款保险的保费杠杆可以达到3倍，这基本上是市面上杠杆最高的了，看来全网最便宜果然名不虚传。</p><p><img src="https://refined-x.com/asset/interest.png" alt="此处输入图片的描述"></p><p>感兴趣的可以自己来算算：<a href="//refined-x.com/projects/codes/interest.html">复利计算器</a>。</p><p>这里衍生一个话题，就是什么人不需要买保险？我觉得有两种人，第一是理财收益率能达到13%的人，因为通过计算得知，只要保持这个收益率就能将<a href="https://cps.qixin18.com/zt1029065/product/detail-2170-2726.html" target="_blank" rel="external">“全网最便宜的消费型重疾险”</a>的杠杆拉平，获得跟保费大致相同的收益，但是理财讲究资金的规模效应，以多数人的资金水平不可能稳定实现这么高的收益率；第二种人可能就是所谓生意人了，把钱投入商业运作，得到多高的收益都不稀奇，难点在于稳定。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>计算器的具体实现实在太简单就不提了，有兴趣的可以自己打开调试工具看源码。这里想多说两句，大家买保险千万不要凭感觉去买，很多人不喜欢纯消费型保险，认为如果自己好人一生平安就相当于把钱白给保险公司了，首先这是事实，你得到了你需要的保障，保险公司得到了利润，天经地义，也因此保险才是一个双赢产品，得以经久不衰的经营下去。由于这种“吃亏”心理非常普遍，因此市面上带返还的产品非常受欢迎，比如有的产品会在65周岁时反保额，看上去好像很划算，其实自己算一下就知道，去掉返现以后你的总投入一点不比消费型产品少，因为这期间动辄几十年的时间，你的本金会源源不断的产生收益，正所谓时间就是金钱。</p><hr><p><a href="//refined-x.com/projects/codes/interest.html">复利计算器</a></p><p><a href="https://cps.qixin18.com/zt1029065/product/detail-2170-2726.html" target="_blank" rel="external">“全网最便宜的消费型重疾险”</a></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2018/07/02/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E4%B8%80%E6%AC%BE%E4%BF%9D%E9%99%A9%E7%9A%84%E6%9D%A0%E6%9D%86/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HybridStart v1.2.0 更新日志</title>
      <link>https://refined-x.com/2018/04/27/HybridStart%20v1.2.0%20%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</link>
      <guid>https://refined-x.com/2018/04/27/HybridStart%20v1.2.0%20%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</guid>
      <pubDate>Fri, 27 Apr 2018 08:53:15 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;新增&quot;&gt;&lt;a href=&quot;#新增&quot; class=&quot;headerlink&quot; title=&quot;新增&quot;&gt;&lt;/a&gt;新增&lt;/h2&gt;&lt;h3 id=&quot;1-插件机制&quot;&gt;&lt;a href=&quot;#1-插件机制&quot; class=&quot;headerlink&quot; title=&quot;1.
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h2><h3 id="1-插件机制"><a href="#1-插件机制" class="headerlink" title="1. 插件机制"></a>1. 插件机制</h3><p>WEB代码无需编译，部署即可运行，因此可以很容易的实现热插拔插件机制，HybridStart内置了一个插件机制的实现DEMO，见示例APP首页“OTA-plugins(扩展插件)”。实现代码位于<code>/views/ota/</code>，额外引入了<a href="https://docs.apicloud.com/Client-API/Func-Ext/zip" target="_blank" rel="external">zip</a>模块实现插件压缩包的解压，完整流程如下：</p><p><img src="http://refined-x.com/asset/hybridstart-plugin.png" alt=""></p><p>插件列表数据格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;status&quot;: &quot;Y&quot;,</span><br><span class="line">&quot;data&quot;: [&#123;</span><br><span class="line">&quot;remote&quot;: &quot;http://static-zt.oss-cn-qingdao.aliyuncs.com/mock/plugin-test.zip&quot;,//插件压缩包下载地址</span><br><span class="line">&quot;index&quot;: &quot;/view/index/temp.html&quot;,//插件首页路径</span><br><span class="line">&quot;name&quot;: &quot;plugin-test&quot;,//插件名称（唯一标识）</span><br><span class="line">&quot;showName&quot;: &quot;测试插件&quot;//插件展示名称</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;remote&quot;: &quot;http://static-zt.oss-cn-qingdao.aliyuncs.com/mock/plugin-refined-x.zip&quot;,</span><br><span class="line">&quot;index&quot;: &quot;/view/index/temp.html&quot;,</span><br><span class="line">&quot;name&quot;: &quot;plugin-refined-x&quot;,</span><br><span class="line">&quot;showName&quot;: &quot;下载失败测试&quot;</span><br><span class="line">&#125;],</span><br><span class="line">&quot;msg&quot;: &quot;获取插件成功&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对插件包的文件结构没有要求，只需要在插件数据中正确指定首页即可，每个插件都自成一体，无法调用App的脚本文件。示例没有实现插件的删除，实际应用中可以自行实现删除功能。</p><h3 id="2-UI支持沉浸式"><a href="#2-UI支持沉浸式" class="headerlink" title="2. UI支持沉浸式"></a>2. UI支持沉浸式</h3><p>对<code>ui.less</code>做了调整，可以很容易的适配沉浸式效果，只需要给<code>.head类</code>加上<code>padding-top:24px</code>，编译成<code>ui.css</code>即可。开启沉浸式体验可以修改<code>config.xml</code>中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;preference name=&quot;statusBarAppearance&quot; value=&quot;true&quot;/&gt;//默认false</span><br></pre></td></tr></table></figure><h2 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h2><h3 id="1-移除页面style-css文件"><a href="#1-移除页面style-css文件" class="headerlink" title="1. 移除页面style.css文件"></a>1. 移除页面style.css文件</h3><p>考虑到页面独有样式通常不多，所以从页面文件夹中移除style.css文件，页面样式可以直接写在<code>temp.html</code>头部，减少文件引用，提升页面加载速度。</p><h3 id="2-增加loader-js"><a href="#2-增加loader-js" class="headerlink" title="2. 增加loader.js"></a>2. 增加loader.js</h3><p>将原来页面底部的一大坨异步非阻塞加载脚本的代码整理成<code>loader.js</code>统一调用。所谓异步非阻塞的意思是绕过APICloud的加载等待机制，使新开窗口能第一时间进场，在进场动画过程中加载页面脚本，以提升页面进场动画的响应速度。</p><p>由此带来的问题是页面脚本只能在真机环境下运行，让js调试非常不方便，关于调试方面的建议可以参考<a href="https://refined-x.com/HybridStart/docs/#solution-speed">进场动画提速</a></p><h2 id="BUG-修复"><a href="#BUG-修复" class="headerlink" title="BUG 修复"></a>BUG 修复</h2><h3 id="1-IOS事件委托BUG"><a href="#1-IOS事件委托BUG" class="headerlink" title="1. IOS事件委托BUG"></a>1. IOS事件委托BUG</h3><p>这个BUG的复现条件为，在IOS环境下将多个页面元素（比如列表项）的点击事件委托在body元素上，当元素多到足以页面发生滚动时，非首屏的元素将不响应点击事件。框架在<code>common.js</code>中默认提供的<code>[active]</code>跳转属性受到该BUG影响，示例APP的首页列表在IOS上会出现非首屏内容无法点击的问题。</p><p>解决方法为在body里插入一个<code>div#body</code>元素，将事件委托改在这个元素上就OK了，<code>common.js</code>里的事件委托写法做了如下兼容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var $body = $(&apos;#body&apos;).length ? $(&apos;#body&apos;) : $(&apos;body&apos;);//优先查找div#body元素</span><br><span class="line">$body.on(...</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-移除默认数据格式约定"><a href="#1-移除默认数据格式约定" class="headerlink" title="1. 移除默认数据格式约定"></a>1. 移除默认数据格式约定</h3><p>不再约定默认的异步数据格式，<code>app.ajax()</code>中已经移除数据格式校验相关代码。</p><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><p><a href="http://app.mi.com/details?id=com.apicloud.A6997660453388" target="_blank" rel="external">体验APP</a></p><p><a href="https://github.com/tower1229/HybridStart" target="_blank" rel="external">代码仓库</a></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2018/04/27/HybridStart%20v1.2.0%20%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>AJAX-Cache：一款好用的Ajax缓存插件</title>
      <link>https://refined-x.com/2018/03/07/AJAX-Cache/</link>
      <guid>https://refined-x.com/2018/03/07/AJAX-Cache/</guid>
      <pubDate>Wed, 07 Mar 2018 01:29:37 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;AJAX-Cache是什么&quot;&gt;&lt;a href=&quot;#AJAX-Cache是什么&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="AJAX-Cache是什么"><a href="#AJAX-Cache是什么" class="headerlink" title="AJAX-Cache是什么"></a>AJAX-Cache是什么</h2><p>Ajax是前端开发必不可少的数据获取手段，在频繁的异步请求业务中，我们往往需要利用“缓存”提升界面响应速度，减少网络资源占用。AJAX-Cache是一款jQuery缓存插件，可以为<code>$.ajax()</code>方法扩展缓存功能。</p><h2 id="AJAX-Cache提供什么"><a href="#AJAX-Cache提供什么" class="headerlink" title="AJAX-Cache提供什么"></a>AJAX-Cache提供什么</h2><h3 id="1-定时缓存"><a href="#1-定时缓存" class="headerlink" title="1. 定时缓存"></a>1. 定时缓存</h3><p>大多数的缓存场景是，希望将某个接口数据在一定时间段内缓存起来，缓存期内不再发起请求直接返回本地数据，过了这段时间再重新获取并更新缓存。</p><p>这就是“定时缓存”的典型使用场景，我们可以为<code>$.ajax()</code>方法传入<code>localCache: Number</code>开启定时缓存，Number是缓存秒毫秒数。定时缓存实际上是牺牲了数据实时性换取响应速度，使用中通过设置不同的缓存时长，可以匹配不同的业务场景，比如对于相对稳定的数据可以设置较长的缓存时间，而设置较短的缓存时间则可以起到请求“防抖”作用。</p><h3 id="2-快照缓存"><a href="#2-快照缓存" class="headerlink" title="2. 快照缓存"></a>2. 快照缓存</h3><p>更多的时候我们希望接口能兼具实时性和响应速度，比如应用首屏的异步数据块，既要快又要新，虽然这种需求听起来很“不科学”，但我们确实可以通过“快照缓存”满足这个需求。</p><p>为<code>$.ajax()</code>方法传入<code>localCache: &quot;snapshot&quot;</code>可以开启快照缓存，此时每当接口成功请求后都会为数据建立一份“快照”，下次请求时接口会首先将最近的快照数据作为结果返回，供前端渲染界面，同时发送请求获取最新数据，新数据到达后会与快照做对比，如果与快照相同则缓存命中，如果与快照不同会更新快照，并将新数据返回，供前端更新界面。也就是说启用快照缓存的接口前端有可能得到两次返回结果，为了让前端能够区分出快照，对象格式的快照数据会自动增加一个<code>snapshot=true</code>的属性。</p><h3 id="3-缓存清理"><a href="#3-缓存清理" class="headerlink" title="3. 缓存清理"></a>3. 缓存清理</h3><p>插件本身会自动清理过期缓存；</p><p>对于不想继续使用缓存的接口可以为<code>$.ajax()</code>方法传入<code>localCache: false</code>清理当前接口的缓存并返回最新数据；</p><p>也可以调用<code>$.ajaxCache.clear()</code>清理所有AJAX-Cache插件产生的缓存。</p><h3 id="4-并发管理"><a href="#4-并发管理" class="headerlink" title="4. 并发管理"></a>4. 并发管理</h3><p>除了上述基本功能，AJAX-Cache还考虑到了极端情况下的请求并发问题，当某个接口在本地没有缓存或者缓存过期时发生了并发，AJAX-Cache会拦截并发请求，暂存请求回调，只向服务端发送一次请求，待拿到数据后再依次执行暂存的请求回调，从而真正起到减少网络资源占用的作用。</p><h3 id="5-约定优于配置"><a href="#5-约定优于配置" class="headerlink" title="5. 约定优于配置"></a>5. 约定优于配置</h3><p>最后，Ajax-Cache奉行“约定优于配置”的理念，将主要功能都集中到一个<code>localCache</code>配置上，使用简单，将对业务代码的侵入性降到最低，如果没有使用<code>$.ajaxCache</code>全局方法的话，从页面中直接将Ajax-Cache插件移除业务代码也不会报错。</p><p>使用简单不代表功能简单，如果需要修改Ajax-Cache的全局配置，也可以通过<code>$.ajaxCache.set(config[Object])</code>方法实现，目前有两个配置项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">storage: &apos;localStorage&apos;, //存储方式，默认localStorage，可选sessionStorage</span><br><span class="line">cacheNamePrefix: &apos;_ajaxcache&apos; //存储标识，集中清理缓存时的依据，如果与你存储的业务数据发生冲突，可以通过这里修改</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展信息"><a href="#扩展信息" class="headerlink" title="扩展信息"></a>扩展信息</h2><p>官网：//refined-x.com/AJAX-Cache/<br>Github：<a href="https://github.com/tower1229/AJAX-Cache" target="_blank" rel="external">https://github.com/tower1229/AJAX-Cache</a></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2018/03/07/AJAX-Cache/#disqus_thread</comments>
    </item>
    
    <item>
      <title>前端页面热更新实现方案</title>
      <link>https://refined-x.com/2018/02/07/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</link>
      <guid>https://refined-x.com/2018/02/07/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</guid>
      <pubDate>Wed, 07 Feb 2018 02:46:48 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前端页面热更新&quot;&gt;&lt;a href=&quot;#前端页面热更新&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前端页面热更新"><a href="#前端页面热更新" class="headerlink" title="前端页面热更新"></a>前端页面热更新</h2><p>了解过前端性能优化的同学应该清楚，给页面加载提速的终极方案就是CDN，这是BS架构本身的特点决定的，无论什么前端提速手段，最终都会回到客户端文件的传输上来；与之相对的CS架构则不存在加载压力，但CS架构的问题是更新不灵活，那么有没有一种方法能结合这两种架构的优点，在加载速度和更新灵活性之间找到一个平衡点呢？这就是本文要探讨的一种方案：前端热更新。</p><h2 id="方案概述"><a href="#方案概述" class="headerlink" title="方案概述"></a>方案概述</h2><p>“前端”和“热更新”这两个词通常很少一起出现，提到热更新一般都是指APP的一种静默更新方式，这种方式会在用户使用时悄悄检测并下载增量更新包，当用户下次打开APP时自动应用更新，从而将APP“更新”这个破坏连贯性的动作隐藏于无形；前端页面的加载则相当于每次都是“全量更新”，如果能让前端页面也能用上“本地模板”，那将极大缩短前端加载时间，而且以此为前提，我们也可以实现一个前端的模板热更新机制，做到不影响页面更新的实时性。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>场景一：APP内嵌页面。</p><p>比如电商类APP的首页，经常需要改版或者做活动皮肤，如何减少更新成本就成了一个大问题。使用了热更新方案我们就可以用HTML实现APP首页，页面内容以模板的形式存进localStorage，后台静默更新模板，下次启动自动生效；针对具有一定时效性的活动皮肤，我们以补丁的形式发布，补丁文件叠加在模板上产生最终的活动模板效果，对于补丁包我们可以提前加载并预存在本地，补丁包应该包含自身的生效时段信息，前端检测到时间处于活动周期内时应用补丁。最终可以做到热更新页面无论改版还是做活动，只需要前端发版就可以，完全不需要APP端参与。</p><p>场景二：追求加载速度的web页面。</p><p>对于web页面来说更新不是问题，加载才是最大的问题，如果个别页面希望极致提升页面展现速度，那么也可以使用该方案作为提速手段，但因为页面的所有代码都将存进localStorage，所以不适合大范围使用。</p><h3 id="需求细化"><a href="#需求细化" class="headerlink" title="需求细化"></a>需求细化</h3><p>综合以上场景和需求，最终我们要做的东西是一个“壳”页面，该页面没有具体业务内容，只实现热更新功能，每次加载都先检查localStorage中是否存在模板，如果有则立即应用模板，此时页面展现出来，如果没有则进入下一步；下一步页面会请求模板管理接口获取最新模板信息，拿到模板信息后如果本地已有模板，则与本地模板比对版本信息，如果版本一致说明缓存命中，流程结束；如果本地版本不是最新，则获取最新模板并存进本地，下次页面加载时将应用最新的模板，流程结束；另一种情况是首次加载本地没有任何模板，那么将获取最新模板，保存到本地，然后应用模板，流程结束。</p><p>前面说的是稳定模板的更新流程，稳定模板流程结束后会进入补丁模板更新流程。首先仍然是检查本地是否存在补丁模板，如果已存在则检测当前时间是否匹配补丁的生效时段，匹配则应用补丁，不匹配将进入下一步；下一步将获取最新补丁模板并存到本地，然后检测当前时间是否匹配最新补丁的生效时段，如果匹配则应用模板，不匹配流程结束。</p><p>完整流程如图所示：<br><img src="https://github.com/tower1229/tower1229.github.io/raw/master/asset/hot-patch.png" alt="hot patch"></p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="接口数据"><a href="#接口数据" class="headerlink" title="接口数据"></a>接口数据</h3><p>根据功能需求我们需要接口返回稳定模板信息和活动模板信息，分别都包含<code>id</code>和<code>url</code>两个字段，<code>id</code>用于版本校验，<code>url</code>指向模板文件下载地址，活动模板信息还需要额外提供<code>cycle</code>字段，定义活动模板的生效时段，与之相对的我们还需要接口返回服务器当前时间，用于匹配活动模板的生效时段，最终完整的数据结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;status&quot;: &quot;Y&quot;,</span><br><span class="line">&quot;data&quot;: &#123;</span><br><span class="line">&quot;stableVersion&quot;: &#123;</span><br><span class="line">&quot;id&quot;: &quot;17&quot;,</span><br><span class="line">&quot;url&quot;: &quot;&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;activeVersion&quot;: &#123;</span><br><span class="line">&quot;id&quot;: &quot;18&quot;,</span><br><span class="line">&quot;url&quot;: &quot;&quot;,</span><br><span class="line">&quot;cycle&quot;: &quot;2018,02,01-2018,02,10&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;today&quot;: &quot;2018,02,06&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="本地数据"><a href="#本地数据" class="headerlink" title="本地数据"></a>本地数据</h3><p>保存到本地的数据大致跟接口数据保持一致，只保留<code>stableVersion</code>和<code>activeVersion</code>信息，字段在<code>id</code>和<code>url</code>基础上再增加<code>template</code>用于保存模板字符串，完整本地数据结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;stableVersion&quot;: &#123;</span><br><span class="line">&quot;id&quot;: &quot;17&quot;,</span><br><span class="line">&quot;url&quot;: &quot;&quot;,</span><br><span class="line">&quot;template&quot;: &quot;&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;activeVersion&quot;: &#123;</span><br><span class="line">&quot;id&quot;: &quot;18&quot;,</span><br><span class="line">&quot;url&quot;: &quot;&quot;,</span><br><span class="line">&quot;cycle&quot;: &quot;2018,02,01-2018,02,10&quot;,</span><br><span class="line">&quot;template&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板文件"><a href="#模板文件" class="headerlink" title="模板文件"></a>模板文件</h3><p>前端页面由三种语言构成，但我们希望只用一次请求就把模板文件拿到，所以模板是一个包含了html/css/js的文本文件，标签格式就保持普通HTML文件的写法，考虑到模板应用部分的实现，需要约定一下标签的写法，例如css必须用<code>&lt;style&gt;&lt;/style&gt;</code>标签包裹，js必须用<code>&lt;script style=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code>标签包裹，这样一来用正则表达式就很容易提取到各部分代码段。</p><h3 id="模板应用"><a href="#模板应用" class="headerlink" title="模板应用"></a>模板应用</h3><p>如上段所说，获得模板文件后可以使用正则表达式拿到三种语言代码，然后只需要按照css &gt; html &gt; js的顺序依次将他们插入页面相应位置，就完成了模板应用，唯一不同的是html代码将以<code>innerHTML</code>的方式覆盖进body元素。在应用顺序上，将css放在html之前是为了避免重绘，将js放在html之后是为了能够在js中操作DOM。</p><p>活动模板虽然定义为补丁，但模板构成跟稳定模板其实是相同的，应用方式也完全相同，只不过由于活动模板在稳定模板之后应用，所以活动模板的css和js都将以补丁的方式影响页面，对于普通的换皮肤需求只需要css和js就足够了，但如果希望html也能发生一些改变，根据html的覆盖式应用方式，活动模板中就需要给出一份完整的html代码，以达到修改html的目的。</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><h3 id="示例展示"><a href="#示例展示" class="headerlink" title="示例展示"></a>示例展示</h3><p><a href="//refined-x.com/WEB-OTA/">//refined-x.com/WEB-OTA/</a></p><p><img src="https://github.com/tower1229/tower1229.github.io/raw/master/asset/web-ota-qrcode.png" alt="qrcode"></p><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p><a href="http://o2o.zhongyishijia.com/" target="_blank" rel="external">一健康网上商城</a>APP首页即采用WEB-OTA方案实现，应付日常迭代游刃有余。</p><p><img src="https://github.com/tower1229/tower1229.github.io/raw/master/asset/yijiankang-share.png" alt="yijiankang"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>整个方案的流程比较琐碎，但实现过程其实很简单，部署成本也不高，只需要后端把模板管理起来，再提供一个更新接口就行了，但这套更新机制还是有一个小问题，那就是当有新版本发布时用户并不能第一时间看到新版本，必须下次访问才能更新到新版本，这算是静默更新要付出的一点点代价吧，如果实在介意这个问题其实也容易解决，只需要在检测到远程有新版本时提示用户重启/刷新就可以了。</p><p>相比较HTML5的manifest缓存方案，我认为灵活性要更高一些，但不足之处在于不支持静态文件的碎片化管理，但扩展这个功能也不复杂，无非模板信息里再扩展几个字段而已。</p><p>代码在这里了，更细节的东西自己看代码吧：<a href="https://github.com/tower1229/WEB-OTA" target="_blank" rel="external">https://github.com/tower1229/WEB-OTA</a></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2018/02/07/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Vue2.0用户权限控制解决方案</title>
      <link>https://refined-x.com/2017/11/28/Vue2.0%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <guid>https://refined-x.com/2017/11/28/Vue2.0%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <pubDate>Tue, 28 Nov 2017 08:39:21 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;&lt;a href=&quot;//refined-x.com/Vue-Access-Control/&quot;&gt;Vue-Access-Control&lt;/a&gt;是一套基于Vue/Vue-Router/axios
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="//refined-x.com/Vue-Access-Control/">Vue-Access-Control</a>是一套基于Vue/Vue-Router/axios 实现的前端用户权限控制解决方案，通过对路由、视图、请求三个层面的控制，使开发者可以实现任意颗粒度的用户权限控制。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="版本要求"><a href="#版本要求" class="headerlink" title="版本要求"></a>版本要求</h3><ul><li>Vue 2.0x</li><li>Vue-router 3.x</li></ul><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>项目主页：//refined-x.com/Vue-Access-Control/</p><p>git：<code>git clone https://github.com/tower1229/Vue-Access-Control.git</code></p><p>npm：<code>npm i vue-access-control</code></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//开发</span><br><span class="line">npm run dev</span><br><span class="line"></span><br><span class="line">//构建</span><br><span class="line">npm build</span><br></pre></td></tr></table></figure><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><p>会话开始之初，先初始化一个只有登录路由的Vue实例，在根组件created钩子里将路由定向到登录页，用户登录成功后前端拿到用户token，设置axios实例统一为请求headers添加<code>{&quot;Authorization&quot;:token}</code>实现用户鉴权，然后获取当前用户的权限数据，主要包括路由权限和资源权限，之后动态添加路由，生成菜单，实现权限指令和全局权限验证方法，并为axios实例添加请求拦截器，至此完成权限控制初始化。动态加载路由后，路由组件将随之加载并渲染，而后展现前端界面。</p><p>为解决浏览器刷新路由重置的问题，拿到token后要将其保存到<code>sessionStorage</code>，根组件的created钩子负责检查本地是否已有token，如果有则无需登录直接用该token获取权限并初始化，如果token有效且当前路由有权访问，将加载路由组件并正确展现；若当前路由无权访问将按路由设置跳转404；如果token失效，后端应返回4xx状态码，前端统一为axios实例添加错误拦截器，遇到4xx状态码执行退出操作，清除<code>sessionStorage</code>数据并跳转到登录页，让用户重新登录。</p><h3 id="最小依赖原则"><a href="#最小依赖原则" class="headerlink" title="最小依赖原则"></a>最小依赖原则</h3><p>Vue-Access-Control的定位是单一领域解决方案，除了Vue/Vue-Router/axios之外没有其他依赖，理论上可以无障碍的应用到任何有权限控制需求的Vue项目中，项目基于<a href="https://github.com/vuejs-templates/webpack" target="_blank" rel="external">webpack</a> 模板开发构建，大多数新项目可以直接基于检出代码继续开发。需要说明的是，项目额外引入的<a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="external">Element-UI</a>和<a href="https://www.npmjs.com/package/crypto-js" target="_blank" rel="external">CryptoJS</a>仅用于开发演示界面，他们不是必须且与权限控制毫无关系，项目应用中可以自行取舍。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">  |-- api/                  //接口文件</span><br><span class="line">  |     |-- index.js             //输出通用axios实例</span><br><span class="line">  |     |-- account.js           //按业务模块组织的接口文件，所有接口都引用./index提供的axios实例</span><br><span class="line">  |-- assets/</span><br><span class="line">  |-- components/</span><br><span class="line">  |-- router/</span><br><span class="line">  |     |-- fullpath.js         //完整路由数据，用于匹配用户的路由权限得到实际路由</span><br><span class="line">  |     `-- index.js            //输出基础路由实例</span><br><span class="line">  |-- views/</span><br><span class="line">  |-- App.vue</span><br><span class="line">  ·-- main.js</span><br></pre></td></tr></table></figure><h3 id="数据格式约定"><a href="#数据格式约定" class="headerlink" title="数据格式约定"></a>数据格式约定</h3><ul><li><p>路由权限数据必须是如下格式的对象数组，<code>id</code>和<code>parent_id</code>相同的两个路由具有上下级关系，如果希望使用自定义格式的路由数据，需要修改路由控制的相关实现，详见<a href="#路由控制"><strong>路由控制</strong></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;菜单1&quot;,</span><br><span class="line">      &quot;parent_id&quot;: null,</span><br><span class="line">      &quot;route&quot;: &quot;route1&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;2&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;菜单1-1&quot;,</span><br><span class="line">      &quot;parent_id&quot;: &quot;1&quot;,</span><br><span class="line">      &quot;route&quot;: &quot;route2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></li><li><p>资源权限数据必须是如下格式的对象数组，每个对象代表一个RESTful请求，支持带参数的url，具体格式说明见<a href="#请求控制"><strong>请求控制</strong></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;2c9180895e172348015e1740805d000d&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;账号-获取&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;/accounts&quot;,</span><br><span class="line">      &quot;method&quot;: &quot;GET&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;2c9180895e172348015e1740c30f000e&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;账号-删除&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;/account/**&quot;,</span><br><span class="line">      &quot;method&quot;: &quot;DELETE&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h2 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h2><p>路由控制包括动态注册路由和动态生成菜单两部分。</p><h3 id="动态注册路由"><a href="#动态注册路由" class="headerlink" title="动态注册路由"></a>动态注册路由</h3><p>最初实例化的路由仅包括登录和404两个路径，我们期待完整的路由是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">  path: &apos;/login&apos;,</span><br><span class="line">  name: &apos;login&apos;,</span><br><span class="line">  component: (resolve) =&gt; require([&apos;../views/login.vue&apos;], resolve)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  path: &apos;/404&apos;,</span><br><span class="line">  name: &apos;404&apos;,</span><br><span class="line">  component: (resolve) =&gt; require([&apos;../views/common/404.vue&apos;], resolve)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  path: &apos;/&apos;,</span><br><span class="line">  name: &apos;首页&apos;,</span><br><span class="line">  component: (resolve) =&gt; require([&apos;../views/index.vue&apos;], resolve),</span><br><span class="line">  children: [&#123;</span><br><span class="line">    path: &apos;/route1&apos;,</span><br><span class="line">    name: &apos;栏目1&apos;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      icon: &apos;icon-channel1&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    component: (resolve) =&gt; require([&apos;../views/view1.vue&apos;], resolve)</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: &apos;/route2&apos;,</span><br><span class="line">    name: &apos;栏目2&apos;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      icon: &apos;ico-channel2&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    component: (resolve) =&gt; require([&apos;../views/view2.vue&apos;], resolve),</span><br><span class="line">    children: [&#123;</span><br><span class="line">      path: &apos;child2-1&apos;,</span><br><span class="line">      name: &apos;子栏目2-1&apos;,</span><br><span class="line">      meta: &#123;</span><br><span class="line">        </span><br><span class="line">      &#125;,</span><br><span class="line">      component: (resolve) =&gt; require([&apos;../views/route2-1.vue&apos;], resolve)</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  path: &apos;*&apos;,</span><br><span class="line">  redirect: &apos;/404&apos;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>那么接下来就需要获取首页以及其子路由们，思路是事先在本地存一份整个项目的完整路由数据，然后根据用户权限对完整路由进行筛选。</p><p>筛选的实现思路是先将后端返回的路由数据处理成如下哈希结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let hashMenus = &#123;</span><br><span class="line">   &quot;/route1&quot;:true,</span><br><span class="line">   &quot;/route1/route1-1&quot;:true,</span><br><span class="line">   &quot;/route1/route1-2&quot;:true,</span><br><span class="line">   &quot;/route2&quot;:true,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后遍历本地完整路由，在循环中将路径拼接成上述结构中的key格式，通过<code>hashMenus[route]</code>就可以判断路由是否匹配，具体实现见<code>App.vue</code>文件中的<code>getRoutes()</code>方法。</p><p>如果后端返回的路由权限数据与约定不同，就需要自行实现筛选逻辑，只要能得到实际可用的路由数据就可以，最终使用<code>addRoutes()</code>方法将他们动态添加到路由实例中，注意404页面的模糊匹配一定要放在最后。</p><h3 id="动态菜单"><a href="#动态菜单" class="headerlink" title="动态菜单"></a>动态菜单</h3><p>路由数据可以直接用来生成导航菜单，但路由数据是在根组件中得到的，导航菜单存在于<code>index.vue</code>组件中，显然我们需要通过某种方式共享菜单数据，方法有很多，一般来说首先想到的是Vuex，但菜单数据在整个用户会话过程中不会发生改变，这并不是Vuex的最佳使用场景，而且为了尽量减少不必要的依赖，这里用了最简单直接的方法，把菜单数据挂在根组件<code>data.menuData</code>上，在首页里用<code>this.$parent.menuData</code>获取。</p><p>另外，导航菜单很可能会有添加栏目图标的需求，这可以通过在路由中添加<code>meta</code>数据实现，例如将图标class或unicode存到路由meta里，模板中就可以访问到meta数据，用来生成图标标签。</p><p>在多角色系统中可能遇到的一个问题是，不同角色有一个名字相同但功能不同的路由，比如说<em>系统管理员</em>和<em>企业管理员</em>都有”账号管理”这个路由，但他们的操作权限和目标不同，实际上是两个完全不同的界面，而Vue不允许多个路由同名，因此路由的name必须做区分，但把区分后的name显示在前端菜单上会很不美观，为了让不同角色可以享有同一个菜单名称，我们只要将这两个路由的<code>meta.name</code>都设置成”账号管理”，在模板循环时优先使用<code>meta.name</code>就可以了。</p><p>菜单的具体实现可以参考<code>views/index.vue</code>。</p><h2 id="视图控制"><a href="#视图控制" class="headerlink" title="视图控制"></a>视图控制</h2><p>视图控制的目标是根据当前用户权限决定界面元素显示与否，典型场景是对各种操作按钮的显示控制。实现视图控制的本质是实现一个权限验证方法，输入请求权限，输出是否获准。然后配合<code>v-if</code>或<code>jsx</code>或自定义指令就能灵活实现各种视图控制。</p><h3 id="全局验证方法"><a href="#全局验证方法" class="headerlink" title="全局验证方法"></a>全局验证方法</h3><p>验证方法的的实现本身很简单，无非是根据后端给出的资源权限做判断，重点在于优化方法的输入输出，提升易用性，经过实践总结最终使用的方案是，将权限跟请求同时维护，验证方法接收请求对象数组为参数，返回是否具有权限的布尔值。</p><p>请求对象格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//获取账户列表</span><br><span class="line">const request = &#123;</span><br><span class="line">  p: [&apos;get,/accounts&apos;],</span><br><span class="line">  r: params =&gt; &#123;</span><br><span class="line">    return instance.get(`/accounts`, &#123;params&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>权限验证方法<code>$_has()</code>的调用格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v-if=&quot;$_has([request])&quot;</span><br></pre></td></tr></table></figure><p>权限验证方法的具体实现见<code>App.vue</code>中<code>Vue.prototype.$_has</code>方法。</p><p>将权限验证方法全局混入，就可以在项目中很容易的配合<code>v-if</code>实现元素显示控制，这种方式的优点在于灵活，除了可以校验权限外，还可以在判断表达式中加入运行时状态做更多样性的判断，而且可以充分利用<code>v-if</code>响应数据变化的特点，实现动态视图控制。</p><p>具体实现细节参考<a href="//refined-x.com/2017/08/29/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/">基于Vue实现后台系统权限控制</a>中的相关章节。</p><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p><code>v-if</code>的响应特性是把双刃剑，因为判断表达式在运行过程中会频繁触发，但实际上在一个用户会话周期内其权限并不会发生变化，因此如果只需要校验权限的话，用<code>v-if</code>会产生大量不必要的运算，这种情况只需在视图载入时校验一次即可，可以通过自定义指令实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//权限指令</span><br><span class="line">Vue.directive(&apos;has&apos;, &#123;</span><br><span class="line">  bind: function(el, binding) &#123;</span><br><span class="line">    if (!Vue.prototype.$_has(binding.value)) &#123;</span><br><span class="line">      el.parentNode.removeChild(el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>自定义指令内部仍然是调用全局验证方法，但优点在于只会在元素初始化时执行一次，多数情况下都应该使用自定义指令实现视图控制。</p><h2 id="请求控制"><a href="#请求控制" class="headerlink" title="请求控制"></a>请求控制</h2><p>请求控制是利用axios拦截器实现的，目的是将越权请求在前端拦截掉，原理是在请求拦截器中判断本次请求是否符合用户权限，以决定是否拦截。</p><p>普通请求的判断很容易，遍历后端返回的的资源权限格式，直接判断<code>request.method</code>和<code>request.url</code>是否吻合就可以了，对于带参数的url需要使用通配符，这里需要根据项目需求前后端协商一致，约定好通配符格式后，拦截器中要先将带参数的url处理成约定格式，再判断权限，方案中已经实现了以下两种通配符格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 格式：/resources/:id</span><br><span class="line">   示例：/resources/1</span><br><span class="line">   url: /resources/**</span><br><span class="line">   解释：一个名词后跟一个参数，参数通常表示名词的id</span><br><span class="line">   </span><br><span class="line">2. 格式：/store/:id/member</span><br><span class="line">   示例：/store/1/member</span><br><span class="line">   url：/store/*/member</span><br><span class="line">   解释：两个名词之间夹带一个参数，参数通常表示第一个名词的id</span><br></pre></td></tr></table></figure><p>对于第一种格式需要注意的是，如果你要发起一个url为<code>&quot;/aaa/bbb&quot;</code>的请求，默认会被处理成<code>&quot;/aaa/**&quot;</code>进行权限校验，如果这里的”bbb”并不是参数而是url的一部分，那么你需要将url改成<code>&quot;/aaa/bbb/&quot;</code>，在最后加一个”/“表示该url不需要转化格式。</p><p>拦截器的具体实现见<code>App.vue</code>中的<code>setInterceptor()</code>方法。</p><p>如果你的项目还需要其他的通配符格式，只需要在拦截器中实现对应的检测和转化方法就可以了。</p><h2 id="演示及说明"><a href="#演示及说明" class="headerlink" title="演示及说明"></a>演示及说明</h2><h3 id="演示说明："><a href="#演示说明：" class="headerlink" title="演示说明："></a>演示说明：</h3><p>DEMO项目中演示了动态菜单、动态路由、按钮权限、请求拦截。</p><p>演示项目后端由<a href="http://rap2.taobao.org/" target="_blank" rel="external">rap2</a>生成mock数据，登录请求通常应该是POST方式，但因为rap2的编程模式无法获取到非GET的请求参数，因此只能用GET方式登录，实际项目中不建议仿效；</p><p>另外登录后获取权限的接口本来不需要携带额外参数，后端可以根据请求头携带的token信息实现用户鉴权，但因为rap2的编程模式获取不到headers数据，因此只能增加一个”Authorization”参数用于生成模拟数据。</p><h3 id="测试账号"><a href="#测试账号" class="headerlink" title="测试账号:"></a>测试账号:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. username: root</span><br><span class="line">   password: 任意</span><br><span class="line">2. username: client</span><br><span class="line">   password: 任意</span><br></pre></td></tr></table></figure><h3 id="演示地址"><a href="#演示地址" class="headerlink" title="演示地址:"></a>演示地址:</h3><p><a href="http://vue-access-control.refined-x.com/" target="_blank" rel="external">vue-access-control.refined-x.com</a></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/11/28/Vue2.0%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Vue2.0开发风格指南</title>
      <link>https://refined-x.com/2017/11/16/Vue2.0%E5%BC%80%E5%8F%91%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/</link>
      <guid>https://refined-x.com/2017/11/16/Vue2.0%E5%BC%80%E5%8F%91%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/</guid>
      <pubDate>Thu, 16 Nov 2017 07:03:32 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;本文是对Vue官方风格指南的注解，过滤了极少数我认为重要性很低的项目，并将其余项按照作用相关性重新归类，便于读者针对性的选择某一方面进行参考。&lt;/p&gt;
&lt;h2 id=&quot;框架或规范约束&quot;&gt;&lt;a href=&quot;#框架或规范约束&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>本文是对Vue官方风格指南的注解，过滤了极少数我认为重要性很低的项目，并将其余项按照作用相关性重新归类，便于读者针对性的选择某一方面进行参考。</p><h2 id="框架或规范约束"><a href="#框架或规范约束" class="headerlink" title="框架或规范约束"></a>框架或规范约束</h2><ol><li>组件名推荐统一使用<code>kebab-case</code>(连字符式)，因为HTML对大小写不敏感，无法识别<code>PascalCase</code>(驼峰式)。</li><li>组件的 <code>data</code> 属性的值必须是返回一个对象的函数，如果直接用一个数据对象，则组件的多个实例之间会产生数据污染，导致失去复用价值。</li><li>组件的<code>Prop</code>在声明时推荐使用<code>PascalCase</code>(驼峰式)，但在模板中必须使用<code>kebab-case</code>(连字符式)，原因同样是因为HTML对大小写不敏感。</li></ol><h2 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h2><ol><li><code>v-for</code>必须配合<code>key</code>使用，可以提高部分情况下Vue的渲染性能。</li><li><code>scoped</code> 样式中避免使用元素选择器，因为遍历元素的效率通常很低。</li></ol><h2 id="健壮性相关"><a href="#健壮性相关" class="headerlink" title="健壮性相关"></a>健壮性相关</h2><ol><li>组件名必须为多个单词，避免与未来的HTML元素冲突，配合<strong>框架或规范约束</strong>第一条理解。</li><li>组件样式必须设置作用域，避免样式冲突，单文件组件可以选择使用<code>scope</code>特性，通用组件可以选择基于class的规则，例如<a href="http://getbem.com/" target="_blank" rel="external">BEM</a>。</li><li>对于混合到Vue对象中的全局资源使用<code>$_</code>前缀，避免与未来版本的Vue属性冲突，必要时可以再添加一个命名空间，避免与其他插件属性冲突。</li><li>组件命名规则：基础组件加特定前缀预示复用性，例如<code>Base</code>；单例组件用<code>The</code>前缀标识预示唯一性；耦合组件中的子组件使用父组件名做前缀预示耦合关系，例如<code>TodoList</code>和<code>TodoListItem</code>；相关组件命名用一般性描述单词开头，用修饰性单词结尾，例如<code>ColorPicker</code>、<code>ColorPickerMulti</code>、<code>ColorPickerQuery</code>。</li><li>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法，因为计算属性和方法利于复用和重构，而且模板也会看起来也更清晰易懂。</li></ol><h2 id="可读性相关"><a href="#可读性相关" class="headerlink" title="可读性相关"></a>可读性相关</h2><ol><li>组件的<code>Prop</code> 定义应该尽量详细，至少要定义类型，利于开发期间调试和提高组件代码可读性。</li><li>推荐用单文件的方式组织组件，利于提高单个组件的编辑查阅效率，即使不使用构建工具，也可以<a href="//refined-x.com/2017/10/28/%E5%A6%82%E4%BD%95%E4%B8%8D%E7%94%A8%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E9%A1%B9%E7%9B%AE/">变通的使用单文件组件开发方式</a>。</li><li>组件文件的命名推荐<code>kebab-case</code>(连字符式)，与组件名写法一致。</li><li>在除了DOM模板以外的任何地方使用自闭合组件写法，使代码更简洁，例如<code>&lt;my-component/&gt;</code>。</li><li>组件命名应使用完整单词，避免歧义。</li><li>拥有多个特性的元素应该分多行撰写，每个特性一行。</li><li>指令缩写要么一直用要么一直不用，提高模板可读性。</li><li>项目中的组件/实例选项声明顺序保持一致，推荐的顺序如下：<code>el,name,parent,functional,delimiters,comments,components,directives,filters,extends,mixins,inheritAttrs,model,props/propsData,data,computed,watch,lifeCircleHooks,methods,template/render,renderError</code>。</li><li>项目中的元素属性书写顺序保持一致。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>指南中的绝大多数优化项都是针对代码健壮性和可读性提出的，基本也都是比较普遍的最佳实践方式，对于有一定经验的开发者来说应该都是很熟悉的内容，或者早已形成了自己的一套习惯，如果部分条目与你所熟知的方式相违背，也不需要过于纠结，只要明确了选择背后的利弊，那就是你的“最佳实践”。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/11/16/Vue2.0%E5%BC%80%E5%8F%91%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何不用构建工具开发Vue全家桶项目</title>
      <link>https://refined-x.com/2017/10/28/%E5%A6%82%E4%BD%95%E4%B8%8D%E7%94%A8%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E9%A1%B9%E7%9B%AE/</link>
      <guid>https://refined-x.com/2017/10/28/%E5%A6%82%E4%BD%95%E4%B8%8D%E7%94%A8%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E9%A1%B9%E7%9B%AE/</guid>
      <pubDate>Sat, 28 Oct 2017 08:40:19 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;Vue是目前最流行的前端开发框架之一，与Vue-router和Vuex组成俗称的Vue全家桶，更是开发前端富交互应用的利器。配合webpack等构建工具，开发大型应用也可以得心应手。随着Vue的普及，可能一些老旧项目也希望能“渐进式”的使用Vue，或者有的项目想用Vue来做
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>Vue是目前最流行的前端开发框架之一，与Vue-router和Vuex组成俗称的Vue全家桶，更是开发前端富交互应用的利器。配合webpack等构建工具，开发大型应用也可以得心应手。随着Vue的普及，可能一些老旧项目也希望能“渐进式”的使用Vue，或者有的项目想用Vue来做但不打算引进构建工具，这种情况该怎样愉快的开发Vue全家桶项目呢？本文将提供一种解决方案。</p><h2 id="构建工具的意义"><a href="#构建工具的意义" class="headerlink" title="构建工具的意义"></a>构建工具的意义</h2><p>首先应该明白构建工具的意义，是为了更好的实现模块化开发。具体来说就是开发的时候“拆”，发布的时候“合”，从而实现以模块为单位的关注点分离，以解决前端项目越来越庞大的背景下，单一开发者很难同时统筹项目所有细节的问题。具体来说都“拆”了什么，无非以下两方面：</p><ul><li>静态资源</li><li>业务模块</li></ul><p>静态资源的打包构建不是什么新鲜东西，编译啊合并啊压缩啊，都是老生常谈。</p><p>业务模块的拆分才是开发大型Vue项目的关键，也是构建工具在这里存在的最大意义。例如基于webpack使用Vue的单文件组件功能，使一个组件的所有部分（样式、模板、逻辑）都集中在一个<code>.vue</code>文件中管理，非常的方便。</p><p>除此之外构建工具通常还额外提供一些别的小恩小惠，比如实时刷新、代码压缩、md5戳等等，都不是很重要，替代方案也很多，这里就忽略它们了。</p><h2 id="如何优雅的摆脱构建工具"><a href="#如何优雅的摆脱构建工具" class="headerlink" title="如何优雅的摆脱构建工具"></a>如何优雅的摆脱构建工具</h2><p>不用构建工具不难，难的是同时实现模块化，没有构建工具的帮助，我们就要自己解决组件及依赖资源的互相引用和加载。核心思路是利用Vue的异步组件特性，借助前端模块加载器实现组件按需加载，只要能通过一个异步请求返回正确的组件对象，我们仍然可以以文件的形式组织组件！</p><p>下面就通过一个小例子来讲解具体如何实现这个方案。示例中用seajs作为加载器，对于借助seajs实现前端模块化开发另一篇讨论参见这里：<a href="//refined-x.com/2017/06/16/Webpack%E6%98%AF%E7%AD%94%E6%A1%88%E5%90%97/">Webpack是答案吗</a>。</p><p>本文不对Vue全家桶及相关类库的使用做讲解，这部分内容请自行查阅文档。示例项目的完整代码及预览地址见文末链接。</p><h3 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h3><p>项目文件被分成两类，一类是通过加载器加载的，一类的是页面文件中直接引用的，为了开发方便应该尽可能将所有文件做模块化改造，但有一部分文件不适合也没有必要，比如类库，项目通用样式，图片文件等，所以这些文件被单独拎出来，项目的整体结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|-- src/                       //模块化文件</span><br><span class="line">|    |-- assets/</span><br><span class="line">|    |-- component/</span><br><span class="line">|    |-- plugin/</span><br><span class="line">|    |-- store/</span><br><span class="line">|    |-- app.js</span><br><span class="line">|    `-- router.js</span><br><span class="line">|-- static/                   //非模块化文件</span><br><span class="line">|    |-- lib/</span><br><span class="line">|    |-- css/</span><br><span class="line">|    |-- font/</span><br><span class="line">|    `-- images/</span><br><span class="line">·-- index.html                 //入口页面</span><br></pre></td></tr></table></figure><h3 id="文件加载"><a href="#文件加载" class="headerlink" title="文件加载"></a>文件加载</h3><p>非模块化文件基本都是各种类库，主要是在入口页面中引用，没什么可说的，对于项目“本体”来说，已经彻底实现了模块化改造，可以说项目中的“一切皆是模块”。</p><p>访问入口页面会加载包括Vue三件套、seajs以及其他类库，然后seajs会加载并执行入口模块<code>app.js</code>，在入口模块中完成Vue实例的创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//app.js 部分代码</span><br><span class="line">const router = require(&apos;js/router&apos;);</span><br><span class="line">const store = require(&apos;js/store/store&apos;);</span><br><span class="line"></span><br><span class="line">let app = new Vue(&#123;</span><br><span class="line">el: &apos;#app&apos;,</span><br><span class="line">router,</span><br><span class="line">store,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>创建实例后会启动路由并跳转首页，路由中使用异步组件，此时会发起请求加载首页的路由组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//router.js 部分代码</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">base: seajs.root,</span><br><span class="line">routes: [&#123;</span><br><span class="line">path: &apos;/&apos;,</span><br><span class="line">component: function (resolve, reject) &#123;</span><br><span class="line">require.async(&apos;js/component/main&apos;, function(main)&#123;</span><br><span class="line">resolve(main);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;,</span><br><span class="line">children: [&#123;</span><br><span class="line">path: &apos;/channel/:cid&apos;,</span><br><span class="line">children: [&#123;</span><br><span class="line">path: &apos;type/:tid&apos;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;]</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>创建实例的同时<code>store</code>也同时初始化完成了，<code>store</code>的”actions”,”getters”,”mutations”各部分的实现比较简单，请直接参考项目源码。</p><p>到这里项目就启动完成了。</p><h3 id="组件的实现"><a href="#组件的实现" class="headerlink" title="组件的实现"></a>组件的实现</h3><p>上一小节是从宏观角度描述项目如何启动以及组件如何被加载，这里着重看一下Vue组件文件该如何实现。</p><p>一个Vue组件本质上是一个包含特定属性的对象，比如它可以包含<code>template</code>,<code>components</code>,<code>created</code>等等属性，因此只要是能返回这种对象的模块化文件，就已经是一个低配版的单文件组件了，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">template: `hello $&#123;name&#125;!`,</span><br><span class="line">data() &#123;</span><br><span class="line">    name: &apos;Vue&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件中很有可能还需要依赖其他资源，比如样式，比如插件，或者其他子组件，也都很容易通过加载器实现，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">const box = require(&apos;box&apos;);     //加载插件</span><br><span class="line">const wilddogApp = require(&apos;js/assets/wilddog&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">template: `&lt;div class=&quot;body flex-col&quot;&gt;</span><br><span class="line">    &lt;v-head&gt;&lt;/v-head&gt;</span><br><span class="line">    &lt;div class=&quot;flex-1 flex-col main&quot;&gt;</span><br><span class="line">        &lt;v-nav&gt;&lt;/v-nav&gt;</span><br><span class="line">        &lt;v-body&gt;&lt;/v-body&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;`,</span><br><span class="line">components: &#123;</span><br><span class="line">&quot;v-head&quot;: require(&apos;js/component/head&apos;), //加载子组件</span><br><span class="line">&quot;v-nav&quot;: require(&apos;js/component/nav&apos;),</span><br><span class="line">&quot;v-body&quot;: require(&apos;js/component/body&apos;)</span><br><span class="line">&#125;,</span><br><span class="line">created: function() &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果组件希望独立管理自己的样式，seajs也有加载css的解决方案，可以参考<code>src/plugin/dropdown.js</code>里的实现。但就做不到<code>.vue</code>文件里的”scoped”特性了，这方面就需要开发者自己约定命名空间来避免冲突了。</p><h3 id="插件的实现"><a href="#插件的实现" class="headerlink" title="插件的实现"></a>插件的实现</h3><p>与Vue组件类似，Vue插件本质上是一个包含”install”属性的对象，因此一个模块化的Vue插件大概是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">install: function(Vue, options) &#123;</span><br><span class="line">Vue.mixin(&#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在全局方法<code>Vue.mixin</code>中就可以具体实现我们的插件功能了，这个插件可以这样被加载并调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const Dropdown = require(&apos;js/plugin/dropdown&apos;);</span><br><span class="line">Vue.use(Dropdown);</span><br></pre></td></tr></table></figure><p>由于插件本质上还是调用<code>Vue.mixin</code>方法，因此如果你的插件不需要参数的话，也可以省掉<code>install</code>这一层包装，这样插件模块一旦加载就会生效，也不需要调用<code>Vue.use()</code>方法了，效果一样。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这个方案有明显的局限和短板，主要是由于组件加载会发起大量的请求，使项目整体运行效率受到影响，因此需要着重强调的是，组件最好不要一次同步加载，尽量的使用异步组件，分散各界面的加载压力，另外配合<a href="//refined-x.com/2017/06/16/Webpack%E6%98%AF%E7%AD%94%E6%A1%88%E5%90%97/">恰当的缓存方案</a>，效果应该也不错。</p><p>项目代码：<a href="https://github.com/tower1229/WidgetsPlayground" target="_blank" rel="external">https://github.com/tower1229/WidgetsPlayground</a><br>预览地址：//refined-x.com/WidgetsPlayground/</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/10/28/%E5%A6%82%E4%BD%95%E4%B8%8D%E7%94%A8%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E9%A1%B9%E7%9B%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>RESTful学习及应用</title>
      <link>https://refined-x.com/2017/09/22/RESTful%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%BA%94%E7%94%A8/</link>
      <guid>https://refined-x.com/2017/09/22/RESTful%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%BA%94%E7%94%A8/</guid>
      <pubDate>Fri, 22 Sep 2017 09:31:42 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;RESTful是什么&quot;&gt;&lt;a href=&quot;#RESTful是什么&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="RESTful是什么"><a href="#RESTful是什么" class="headerlink" title="RESTful是什么"></a>RESTful是什么</h2><p>RESTful是一种API架构，符合REST设计原则的API都可以被称为RESTful，REST的全称是<em>Representational State Transfer</em>。</p><p>REST的核心原则是后端将资源发布为URI，前端通过URI访问资源，并通过HTTP动词表示要对资源进行的操作，典型的RESTful API长这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /article           //增加一篇文章</span><br><span class="line">DELETE /article/1       //删除id为1的文章</span><br><span class="line">PUT /article/1          //修改id为1的文章</span><br><span class="line">GET /articles/1         //查询id为1的文章</span><br></pre></td></tr></table></figure><p>这里需要明确一个概念：<strong>资源</strong>，后端提供的所有内容都可以被定义为资源，前端用户的一切行为，本质都是与一系列后端资源互动的结果。从这个角度来讲，前端的意义就是连接用户与资源，使用户能以最简单的方式调度后端资源，并将调度结果以用户最容易接受的方式呈现出来。</p><h2 id="为什么使用RESTful"><a href="#为什么使用RESTful" class="headerlink" title="为什么使用RESTful"></a>为什么使用RESTful</h2><p>前后端分离的本质是前后端以API为界限进行开发解耦，所以前后端分离的副产品是大量的API，采用RESTful架构可以让API的表现力更强，更易于被理解；对于接口开发来说，RESTful风格也更易于扩展，这对于大型项目非常重要。</p><p>RESTful是无状态的，因此无论前端是什么设备，前端是什么状态，都可以无差别的请求资源，有利于后端实现分布式。</p><p>RESTful允许前端索取指定格式的信息，因此可以实现一套统一的API服务于不同的前端设备。</p><h2 id="如何构建RESTful-API"><a href="#如何构建RESTful-API" class="headerlink" title="如何构建RESTful API"></a>如何构建RESTful API</h2><h3 id="一、每个网址代表一种资源，网址中只能有名词"><a href="#一、每个网址代表一种资源，网址中只能有名词" class="headerlink" title="一、每个网址代表一种资源，网址中只能有名词"></a>一、每个网址代表一种资源，网址中只能有名词</h3><p>网址仅用来表示资源的名称，而不包括操作，因此只能由名词组成；但有些资源可能自带操作属性，比如转账，这时候我们应该将转账看成一种服务（名词），将转账的其他信息作为参数传递</p><h3 id="二、对于资源的操作类型由HTTP动词表示"><a href="#二、对于资源的操作类型由HTTP动词表示" class="headerlink" title="二、对于资源的操作类型由HTTP动词表示"></a>二、对于资源的操作类型由HTTP动词表示</h3><p>常用的四种HTTP动词以及对应的SQL操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET（SELECT）：从服务器取出资源（一项或多项）。</span><br><span class="line">POST（CREATE）：在服务器新建一个资源。</span><br><span class="line">PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）</span><br><span class="line">DELETE（DELETE）：从服务器删除资源。</span><br></pre></td></tr></table></figure><h3 id="三、统一的返回结果"><a href="#三、统一的返回结果" class="headerlink" title="三、统一的返回结果"></a>三、统一的返回结果</h3><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /collection：返回资源对象的列表（数组）</span><br><span class="line">GET /collection/resource：返回单个资源对象</span><br><span class="line">POST /collection：返回新生成的资源对象</span><br><span class="line">PUT /collection/resource：返回完整的资源对象</span><br><span class="line">PATCH /collection/resource：返回完整的资源对象</span><br><span class="line">DELETE /collection/resource：返回一个空文档</span><br></pre></td></tr></table></figure><h3 id="四、返回正确的状态码"><a href="#四、返回正确的状态码" class="headerlink" title="四、返回正确的状态码"></a>四、返回正确的状态码</h3><p>常用状态码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">200 ：服务器成功返回用户请求的数据</span><br><span class="line">400 ：用户发出的请求有错误</span><br><span class="line">401 ：表示用户没有权限</span><br><span class="line">403 : 表示用户得到授权（与401错误相对），但访问被禁止的</span><br><span class="line">404 ：用户发出的请求针对的是不存在的记录</span><br><span class="line">500 ：服务器发生错误，用户无法判断发出的请求是否成功</span><br></pre></td></tr></table></figure><h3 id="五、允许通过HTTP内容协商"><a href="#五、允许通过HTTP内容协商" class="headerlink" title="五、允许通过HTTP内容协商"></a>五、允许通过HTTP内容协商</h3><p>客户端可以通过Accept头请求一种特定格式的表述，服务端则通过Content-Type告诉客户端资源的表述形式。若服务器不支持，它应该返回一个HTTP 406响应，表示拒绝处理该请求。</p><p>通常项目中最常用的还是直接预定为JSON格式。</p><h2 id="web端的应用"><a href="#web端的应用" class="headerlink" title="web端的应用"></a>web端的应用</h2><p>目前最流行的web端AJAX类库当属axios，axios与RESTful完美兼容，主要体现在以下几个方面。</p><p>axios将HTTP动词直接封装为方法，正好对应RESTful的API风格，在RESTful架构中使用起来非常方便</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.post(`/article`, params)</span><br><span class="line">axios.delete(`/article/1`, params)</span><br><span class="line">axios.put(`/article/1`, params)</span><br><span class="line">axios.get(`/article/1`, params)</span><br></pre></td></tr></table></figure><p>而且axios的返回数据包括响应正文和状态码等信息，配合拦截器很容易实现对RESTful API错误码的统一处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//错误处理</span><br><span class="line">axios.interceptors.response.use(function(response) &#123;</span><br><span class="line">  return response;</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  if (error.response) &#123;</span><br><span class="line">    switch (error.response.status) &#123;</span><br><span class="line">      case 400:</span><br><span class="line">        </span><br><span class="line">        break;</span><br><span class="line">      case 401:</span><br><span class="line">        </span><br><span class="line">        break;</span><br><span class="line">      case 403:</span><br><span class="line">        </span><br><span class="line">        break;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>更多axios内容参考<a href="https://www.npmjs.com/package/axios" target="_blank" rel="external">这里</a>。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>其实RESTful的绝大多数内容都是规范推荐的做法，没有什么新东西，只不过前几年后端MVC盛行的时期，没有这么重的API开发需求，在这方面就一切从简了，近来赶上前后端分离的东风，API设计又被大家重视起来了，重回规范的RESTful相当于让大家见识了一下当年规范制定者们的远见卓识，就像小时候不听话的孩子在长大的某一天里突然想起来长辈曾经的教诲一样。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/09/22/RESTful%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%BA%94%E7%94%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>纯前端实现人脸识别-提取-合成</title>
      <link>https://refined-x.com/2017/09/06/%E7%BA%AF%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-%E6%8F%90%E5%8F%96-%E5%90%88%E6%88%90/</link>
      <guid>https://refined-x.com/2017/09/06/%E7%BA%AF%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-%E6%8F%90%E5%8F%96-%E5%90%88%E6%88%90/</guid>
      <pubDate>Wed, 06 Sep 2017 01:10:07 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;最近火爆朋友圈的军装照H5大家一定还记忆犹新，其原理是先提取出照片中的面部，然后与模板进行合成，官方的合成处理据说由&lt;em&gt;天天P图&lt;/em&gt;提供技术支持，后端合成后返回给前端展示，形式很新颖效果也非常好，整个流程涉及的人脸识别和图像合成两项核心技术在前端都有对应的解决方案
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>最近火爆朋友圈的军装照H5大家一定还记忆犹新，其原理是先提取出照片中的面部，然后与模板进行合成，官方的合成处理据说由<em>天天P图</em>提供技术支持，后端合成后返回给前端展示，形式很新颖效果也非常好，整个流程涉及的人脸识别和图像合成两项核心技术在前端都有对应的解决方案，因此理论上前端也可以完成人脸识别-提取-合成整个流程，实现纯前端的军装照H5效果。</p><h2 id="前端人脸识别"><a href="#前端人脸识别" class="headerlink" title="前端人脸识别"></a>前端人脸识别</h2><p>首先需要的是人脸识别，这个一听就觉得高大上的东西原理并不深奥，无非是用人的面部特征规则对图像进行匹配和识别，这项工作前端虽然可以实现，但前端实现基本就只能依据内置规则库进行匹配，这个库的质量就决定了识别质量，而通常更成熟的方案是引入机器学习，让程序不断自我修正和提高，进一步提高识别率，机器学习的前端库倒是也有，但把这两者结合起来的还没发现，因此对前端人脸识别的准确率不要报太高期望。</p><p>现有的前端人脸识别库不算多，这里我们选择的是效果相对好点的<a href="https://trackingjs.com/" target="_blank" rel="external">trackingjs</a>，这个类库功能非常强大，库如其名，它可以完成各种追踪类的图像处理任务，人脸识别只是其众多功能之一，而且通过选配插件，还可以精确识别眼睛、鼻子等五官的位置，貌似稍微折腾一下也可以实现<em>美图秀秀</em>的效果。</p><p>这里我们只用<code>trackingjs</code>实现面部识别，初始化一个面部识别任务的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//实例化</span><br><span class="line">var tracker = new tracking.ObjectTracker([&apos;face&apos;]);</span><br><span class="line">//识别回调</span><br><span class="line">tracker.on(&apos;track&apos;, function(event) &#123;</span><br><span class="line">    if (!event.data.length) &#123;</span><br><span class="line">        return console.log(&apos;画面中没有人脸&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    event.data.forEach(function(rect, i) &#123;</span><br><span class="line">        console.log(rect);//单个面部数据</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">//配置参数</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样一个面部识别任务就初始化完成了，调用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tracking.track(&apos;#img&apos;, tracker);</span><br><span class="line">//其中&apos;#img&apos;参数是目标图像的选择器</span><br></pre></td></tr></table></figure><p>在识别回调中<code>event.data</code>就是数组格式的面部数据，如果长度为0则表示图像中没有人脸或者识别失败，如果识别成功，单个面部数据的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    x: number,          //面部位于原图x轴方向位置</span><br><span class="line">    y: nuber,           //面部位于原图y轴方向位置</span><br><span class="line">    width:number,       //面部区域宽度</span><br><span class="line">    height:nubmer       //面部区域高度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个面部数据就可以很容易的将该区域从原图中提取出来，前端当然就用<code>canvas</code>啦，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var img = document.getElementById(&quot;img&quot;);</span><br><span class="line">var faceCtx = document.getElementById(&quot;mycanvas&quot;).getContext(&apos;2d&apos;);</span><br><span class="line"></span><br><span class="line">var theFace = ...; //假设我们识别到了theFace</span><br><span class="line"></span><br><span class="line">//使用drawImage()方法将面部绘制出来</span><br><span class="line">faceCtx.drawImage(img, theFace.x, theFace.y, theFace.width, theFace.height, 0, 0, theFace.width, theFace.height);</span><br></pre></td></tr></table></figure><p>到这里我们已经实现了面部识别 + 提取，而且代码量也没多少，其实这里面有个小坑要在实践中才会发现，那就是<code>trackingjs</code>的配置，文档中能找到4个跟识别有关的配置，分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setClassifiers(classifiers)</span><br><span class="line">setEdgesDensity(edgesDensity)</span><br><span class="line">setScaleFactor(scaleFactor)</span><br><span class="line">setStepSize(stepSize)</span><br></pre></td></tr></table></figure></p><p>看不懂吧，我也看不懂，而且文档中对他们没有任何有用的说明，在测试中我只使用了后两个配置，翻译过来分别是”比例因子”和”步长”，经过枯燥的人肉测试发现，这两个参数的有效取值范围分别在<code>1 - 2</code>和<code>1.1 - 2</code>，其中<code>setStepSize</code>不能为<code>1</code>，否则会浏览器会卡死，所以从1.1开始取值，取值超过2也可以，但识别成功的概率就很低了。通过调整这两个参数绝大多数图像都可以成功识别，唯独对面部大特写很难识别，这可能需要配合另外两个参数吧，我实在没耐心继续人肉测试下去了，感兴趣的自己回去玩吧。</p><h2 id="前端图像处理"><a href="#前端图像处理" class="headerlink" title="前端图像处理"></a>前端图像处理</h2><p>经过上一步的识别+提取我们已经得到了面部图像，要实现合成军装照效果我们还需要对面部图像进行处理，使色调与模板一致，将来才能毫无违和感的融合在一起，具体到军装照这个例子我们需要将面部重新着色，并达到”做旧”的老照片效果，如果用PS想必大家都会，但在前端怎么实现呢？</p><p>这里我们需要借助腾讯前端团队出品的<a href="http://alloyteam.github.io/AlloyImage/" target="_blank" rel="external">AlloyImage</a>，这是一个堪称<em>前端PS</em>的前端图像处理类库，比如要实现上述效果，我们只需要这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var faceImg = document.getElementById(&quot;theFace&quot;);</span><br><span class="line">faceImg.loadOnce(function() &#123;</span><br><span class="line">    AlloyImage(this).act(&quot;灰度处理&quot;).add(</span><br><span class="line">        AlloyImage(this.width, this.height, &quot;#808080&quot;)</span><br><span class="line">        .act(&quot;高斯模糊&quot;, 4)</span><br><span class="line">        .act(&quot;色相/饱和度调节&quot;, 22, 45, 0, true),</span><br><span class="line">        &quot;叠加&quot;</span><br><span class="line">    ).replace(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你就得到了一个做旧的人脸，还是非常简单的，AlloyImage的使用基本可以说是傻瓜化，感兴趣的就自己花个五分钟去看下官方文档吧，这里不再赘述。</p><p>然后就要说一下我们这个图像处理和人家<em>天天P图</em>的差距了，虽然我们得到了理想的色调，但要想把随便一张人脸与特定模板做合成，有两件事必不可少。首先是面部角度矫正，如果模板是正的而你的照片是歪的，直接暴力拼接肯定很违和，所以需要先识别出面部角度，并纠正到指定角度；然后是面部中心定位，因为人脸识别的结果提取出来后不一定是以面部中心为中心的，所以在合成之前要识别出面部中心线，并以此为依据与模板进行定位。然而这些我们都没有，所以我们只能对输入的图像的要求更高，如果输入了嘴歪眼斜的图片，结果就只能尴尬了。</p><p>最后的图片合成部分就更简陋了，先将处理好的面部画到画布指定位置，然后将抠好图的脸部透明png模板铺在上面，完成。实际过程中需要处理一些小问题，比如要根据模板的面部尺寸将面部图像缩放到合适的尺寸；抠模板时要将边缘模糊处理，而且尽量保留模板本来的面部轮廓，只将五官抠掉。即便这样，合成结果还是很容易穿帮，不过纯前端处理也没有更好的办法了。</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>好了，说的再多不如看个例子，示例提供三种图片输入源，分别是本地图片、远程图片、内置示例。其中内置的图片大部分是提前在PS中纠正过角度的，而且内置图片会自动匹配到我事先调校好的参数，不出意外可以直接识别出人脸；如果选择本地图片作为图片源，最好选择头部姿态垂直的正面照，同时参考内置图片的 参数设置调节参数，一次识别不成功很正常，需要多调几次；也可以使用远程图片识别，但因为canvas受到跨域策略影响，远程图片只能识别不能提取和合成。</p><p>示例：<a href="//refined-x.com/projects/codes/tracking.html">纯前端军装照合成</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最初是抱着好奇的心态开始捣鼓这个项目的，虽然最终的合成效果远远达不到生产要求，但整个示例撸下来后对人脸识别和图片处理技术都有了基本的认识，对canvas操作中一些细节问题的解决也略微补足了一下这方面的知识空白，算略有收获吧。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/09/06/%E7%BA%AF%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-%E6%8F%90%E5%8F%96-%E5%90%88%E6%88%90/#disqus_thread</comments>
    </item>
    
    <item>
      <title>用addRoutes实现动态路由</title>
      <link>https://refined-x.com/2017/09/01/%E7%94%A8addRoutes%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/</link>
      <guid>https://refined-x.com/2017/09/01/%E7%94%A8addRoutes%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/</guid>
      <pubDate>Fri, 01 Sep 2017 02:25:16 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;之前在&lt;a
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>之前在<a href="//refined-x.com/2017/08/29/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/">基于Vue实现后台系统权限控制</a>一文中提到路由权限的实现思路，因为不喜欢在每次路由跳转的before钩子里做判断，所以在初始化Vue实例前对路由做了筛选，再用实际路由初始化Vue实例，代价是登录页需要从Vue实例中独立出来，实现上倒没什么问题，不过这种做法需要在登录和首页之间通过url跳转，感觉总是不太”优雅”，实际上只要能在登录后动态修改当前实例的路由就行了，之前确实没办法，但vue-router 2.2版本新增了一个<code>router.addRoutes(routes)</code>方法，让动态路由得以实现。</p><h2 id="想当然的实现方案"><a href="#想当然的实现方案" class="headerlink" title="想当然的实现方案"></a>想当然的实现方案</h2><p>用动态路由实现路由权限控制貌似是一个完美的方案，初始路由只有登录和404，登录后动态添加可用路由，同时将菜单数据保存到Vuex或本地用于实现动态菜单，关键节点大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//初始路由：</span><br><span class="line">[&#123;</span><br><span class="line">  path: &apos;/login&apos;,</span><br><span class="line">  name: &apos;login&apos;,</span><br><span class="line">  component: (resolve) =&gt; require([&apos;../views/common/404.vue&apos;], resolve)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  path: &apos;/404&apos;,</span><br><span class="line">  name: &apos;404&apos;,</span><br><span class="line">  component: (resolve) =&gt; require([&apos;../views/common/404.vue&apos;], resolve)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  path: &apos;*&apos;,</span><br><span class="line">  redirect: &apos;/404&apos;</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line">//登录逻辑</span><br><span class="line">let vm = this;</span><br><span class="line">axios.get(&apos;/login&apos;, vm.user).then((res) =&gt; &#123;</span><br><span class="line">    let extendsRoutes = filterRoutes(res.menus); </span><br><span class="line">    &lt;!--</span><br><span class="line">    //假设得到的可用路由如下</span><br><span class="line">    [&#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      name: &apos;首页&apos;,</span><br><span class="line">      component: (resolve) =&gt; require([&apos;../views/index.vue&apos;], resolve),</span><br><span class="line">      children: [&#123;</span><br><span class="line">        path: &apos;/menus&apos;,</span><br><span class="line">        name: &apos;菜单管理&apos;,</span><br><span class="line">        component: (resolve) =&gt; require([&apos;../views/menus.vue&apos;], resolve)</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        path: &apos;/resources&apos;,</span><br><span class="line">        name: &apos;资源管理&apos;,</span><br><span class="line">        component: (resolve) =&gt; require([&apos;../views/resources.vue&apos;], resolve)</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;]--&gt;</span><br><span class="line">    //存菜单</span><br><span class="line">    sessionStorage.setItem(&apos;menus&apos;,JSON.stringify(extendsRoutes[0].children));</span><br><span class="line">    //动态添加路由</span><br><span class="line">    vm.$router.addRoutes(extendsRoutes);</span><br><span class="line">    //跳转到应用界面</span><br><span class="line">    vm.$router.push(&#123;path:&apos;/&apos;&#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//首页获取菜单数据</span><br><span class="line">this.menus = JSON.parse(sessionStorage.getItem(&apos;menus&apos;)); </span><br><span class="line">//用此数据循环菜单</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p>目前为止看上去一切顺利，然而前方有坑。</p><h2 id="动态路由的坑"><a href="#动态路由的坑" class="headerlink" title="动态路由的坑"></a>动态路由的坑</h2><p>第一个坑是，如果你将这套逻辑实现之后会发现打开应用看到的第一个页面是404，这是因为启动服务后将默认打开首页’/‘，然而初始路由中没有这个路径，因此根据路由规则跳转到了404。我们希望结果当然是跳转到’/login’，因此需要对这种情况做判断，在用户登录之前所有请求都要指向’/login’，这个判断可以在before钩子里做也可以在根组件里做，建议做在根组件的created回调里，核心代码大概这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let isLogin = sessionStorage.getItem(&apos;user&apos;);</span><br><span class="line">if(!isLogin)&#123;</span><br><span class="line">    return this.$router.push(&#123;path:&apos;/login&apos;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候已经可以顺利登录了，登录后很快就会发现第二个坑，手动刷新页面又会跳到404，这是因为刷新会导致Vue重新实例化，路由也恢复到了初始路由，于是当前路径又被重定向到了404，这个问题的根源是可用路由没有实现持久化，那么可以通过将路由数据存sessionStorage来解决，实例化之前如果检测到本地路由就直接合并路由，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//检测本地路由</span><br><span class="line">let localRoutes = sessionStorage.getItem(&apos;routes&apos;);</span><br><span class="line">if(localRoutes)&#123;</span><br><span class="line">    router.addRoutes(JSON.parse(localRoutes));</span><br><span class="line">&#125;</span><br><span class="line">//实例化</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  router,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>理论上可以，但实际操作要远比上述代码复杂，因为存在本地的只能是权限数据而不是真实路由，路由在存、取之前都要先根据权限匹配获得，过程还是挺繁琐的，而且必须依赖sessionStorage这种持久存储，没有其他方法。问题就出在这个sessionStorage上，原则上权限只能在内存变量中流转，不能直接暴露到用户可操作的地方，试想只要用户手动修改了sessionStorage里的权限，再刷新一下页面就能突破前端路由控制了，非常的不靠谱。</p><h2 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h2><p>既然不能存本地，那就每次刷新都重新从服务端获取，所以改进后的方案是本地存用户token，每次刷新要凭token从服务端重新获取用户信息和权限，然后动态更新路由，获取权限操作可以跟登录检测一起放在根组件的created回调中进行，确保访问任何路径都会先执行这一步，但因为获取权限是异步操作，在此之前仍然会经过应用初始化，所以还是会遇到404的问题，为此我们只需做一个小调整，将不匹配路径(‘*’)跳404的路由从初始路由中移除，动态更新路由时再把这个配置加进去，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let userPath = ...//我们的动态路由</span><br><span class="line">//注入时拼接404处理路由</span><br><span class="line">this.$router.addRoutes(userPath.concat([&#123;</span><br><span class="line">  path: &apos;*&apos;,</span><br><span class="line">  redirect: &apos;/404&apos;</span><br><span class="line">&#125;]));</span><br></pre></td></tr></table></figure><p>这样就解决了刷新问题，后面还有几个小问题就简单了。</p><p>首先是菜单，之前通过<code>$router.options.routes</code>访问路由数据实现动态菜单，但这个数据不是响应式的，无法追踪动态路由的变化，因此我们需要将得到的导航菜单数据存到sessionStorage或Vuex里实现数据共享。</p><p>资源权限控制也受到很大的影响，实现较为细致的权限控制需要一个自定义权限验证指令和一个全局验证方法，之前的方案里权限是在Vue实例化之前获取的，所以可以很方便的拿到权限后实现验证方法，然后用验证方法实现自定义指令，再将方法全局混合进Vue，然后实例化，这样实例中的 所有组件都可以使用自定义指令和验证方法；但现在的方案是先实例化再获取权限，实例化之前根本没有权限数据，所以自定义指无法实现，等拿到权限后实现了验证方法，却无法再全局混合了。</p><p>这个问题最后也解决了，但解决方案就彻底的”有辱斯文”了，首先是全局方法的实现，直接这么做:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.has = function()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式跟全局混合的方法完全一样。</p><p>自定义指令的实现本来很头疼，因为全局指令只能在实例化之前实现，但那时候又确实没有权限，不过既然验证方法这么做的话，指令倒是也顺便解决了，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//权限指令</span><br><span class="line">Vue.directive(&apos;has&apos;, &#123;</span><br><span class="line">  bind: function(el, binding) &#123;</span><br><span class="line">    if (!Vue.prototype.has(binding.value)) &#123;</span><br><span class="line">      el.parentNode.removeChild(el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>神奇的<code>prototype</code>貌似自带惰性效果，可以先注册后实现，具体原因我也不太明白，如过有大牛路过，希望能留下答案。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>生命不息，折腾不止啊，本来已经放弃的思路，捋着捋着竟然捋顺了，然后又花了大半天把原来多入口的项目改成了单入口，虽然麻烦了一顿，但心里总算舒坦了。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/09/01/%E7%94%A8addRoutes%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>基于Vue实现后台系统权限控制</title>
      <link>https://refined-x.com/2017/08/29/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</link>
      <guid>https://refined-x.com/2017/08/29/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</guid>
      <pubDate>Tue, 29 Aug 2017 01:28:27 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文中的菜单权限控制方案由于没有使用<code>router.addRoutes()</code>实现动态路由，需要将登录页独立出来单独做，基于相同思路的动态路由方案参见]<a href="//refined-x.com/2017/09/01/%E7%94%A8addRoutes%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/">用addRoutes实现动态路由</a>。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>用Vue这类双向绑定框架做后台系统再适合不过，后台系统相比普通前端项目除了数据交互更频繁以外，还有一个特别的需求就是对用户的权限控制，那么如何在一个Vue应用中实现权限控制呢？下面是我的一点经验。</p><h2 id="权限控制是什么"><a href="#权限控制是什么" class="headerlink" title="权限控制是什么"></a>权限控制是什么</h2><p>在权限的世界里服务端提供的一切都是资源，资源可以由请求方法+请求地址来描述，权限是对特定资源的访问许可，所谓权限控制，也就是确保用户只能访问到被分配的资源。具体的说，前端对资源的访问通常是由界面上的按钮发起，比如删除某条数据；或由用户进入某一个页面发起，比如获取某个列表数据。这两种形式覆盖了资源请求的大部分场景，因此权限控制也可以被笼统的分成菜单权限控制和按钮权限控制。</p><h2 id="Vue菜单权限控制"><a href="#Vue菜单权限控制" class="headerlink" title="Vue菜单权限控制"></a>Vue菜单权限控制</h2><p>菜单是对路由的直接体现，菜单控制实际上就是路由控制。实现路由控制一个简单的方式是，在路由的before钩子里校验当前即将跳转的路由地址是否有权访问，根据校验结果决定路由是否放行，伪码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">    //权限校验</span><br><span class="line">    let pass = valid(to);</span><br><span class="line">    if(!pass)&#123;</span><br><span class="line">        return console.log(&apos;无权访问&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种实现方式既简单又直观，用于路由总数不多的系统非常合适，但这么做本质上是将所有路由全部注册了，直接带来的缺点有两个：一、如果路由组件不是按需加载的话，应用将加载大量冗余代码；二、每次跳转都要遍历一次完整路由，是对计算能力的浪费。</p><p>理想的实现方式是本地保存完整路由，但并不立即初始化Vue应用，待用户登录拿到权限后，用菜单权限筛选出可用路由，再用可用路由初始化Vue应用。也就是说，要将登录页独立出去做成一个单独的页面，登录后将用户数据保存在本地，再通过url跳转到Vue应用所在页面，Vue应用启动前通过本地用户数据完成路由筛选，然后初始化Vue应用，伪码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//main.js</span><br><span class="line">let user = sessionStorage.getItem(&apos;user&apos;);</span><br><span class="line">if (user) &#123;</span><br><span class="line">    user = JSON.parse(user);</span><br><span class="line">    //筛选得到实际路由</span><br><span class="line">    let fullPath = require(&apos;fullPath.js&apos;);</span><br><span class="line">    let routes = filter(fullPath, user.menus);</span><br><span class="line">    //创建路由对象</span><br><span class="line">    let router = new Router(&#123;routes&#125;);</span><br><span class="line">    //生成Vue实例</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: &apos;#app&apos;,</span><br><span class="line">        router,</span><br><span class="line">        render: h =&gt; h(App)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    location.href = &apos;/login/&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们还希望能直接用路由数据生成导航菜单，常规的路由数据可能无法满足菜单组件的需求，所以我们要事先在路由的<code>meta</code>里维护上菜单数据，比如菜单名称菜单图标等，只要在模板中通过<code>$router.options</code>就可以访问到当前路由数据，如果使用element-ui的菜单组件实现，代码大致是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-menu router&gt;</span><br><span class="line">    &lt;el-menu-item v-for=&quot;(route, index) in $router.options.routes[2].children&quot;</span><br><span class="line">    :route=&quot;route&quot;</span><br><span class="line">    :index=&quot;route.name&quot;&gt;</span><br><span class="line">        &lt;i class=&quot;ion&quot; v-html=&quot;route.icon&quot;&gt;&lt;/i&gt;&#123;&#123;route.name&#125;&#125;</span><br><span class="line">    &lt;/el-menu-item&gt;</span><br><span class="line">&lt;/el-menu&gt;</span><br></pre></td></tr></table></figure><p>当然这样只能循环出一级菜单，如果还有二级路由需要对应二级菜单的话，就得判断并循环<code>children</code>节点，比较简单就不放更多代码了，菜单权限控制到这里就完成了。</p><h2 id="Vue按钮权限控制"><a href="#Vue按钮权限控制" class="headerlink" title="Vue按钮权限控制"></a>Vue按钮权限控制</h2><p>按钮权限控制与菜单权限控制的实现思路类似，也是根据用户权限判断各个按钮的显示与否，方式无非是<code>v-if</code>或自定义指令，而且只要将<code>v-if</code>背后的权限校验逻辑抽象成方法，无论是代码量还是使用形式上都跟自定义指令几乎一样，但<code>v-if</code>的特点是它会响应数据变化，因此随着应用的运行会频繁触发权限校验，而权限在应用的整个生命周期内其实只需校验一次，为了避免无谓的程序执行，这里可以用自定义指令来实现，伪码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(&apos;has&apos;, &#123;</span><br><span class="line">  bind: function (el, binding) &#123;</span><br><span class="line">    if(!has(binding.value))&#123;</span><br><span class="line">        el.parentNode.removeChild(el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//用法：</span><br><span class="line">&lt;btn v-has=&apos;get,/sources&apos;&gt;按钮&lt;/btn&gt;</span><br></pre></td></tr></table></figure><p>注意在指令<code>bind</code>回调里有一个<code>has()</code>方法，这就是权限校验方法，我们同时将这个方法全局混合到Vue对象中，使应用里的每个组件都可以访问到这个方法，便于为界面上的<code>v-if</code>提供支持，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;has(&apos;get,/sources&apos;) &amp;&amp; something&quot;&gt;</span><br><span class="line">    一个需要同时具备&apos;get,/sources&apos;权限和somthing为真值才显示的div</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>验证方法的实现不是本文重点，只讲大致思路，假设服务端用请求方法+请求url定义资源，如”get,/resources”，那么资源权限数据应该是由于资源组成的数组，我们需要先将数组转换成对象格式，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let permissions = &#123;</span><br><span class="line">  &quot;get,/resources&quot;:true,</span><br><span class="line">  &quot;delete,/resources&quot;:true,</span><br><span class="line">  &quot;post,/resources&quot;:true,</span><br><span class="line">  &quot;put,/resources&quot;:true,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在验证方法里就可以通过直接访问permissions的属性来确定是否拥有权限，效率远高于遍历原始权限数组，代码应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let has = function(permission)&#123;</span><br><span class="line">  if(!permissions[permission])&#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来凡是需要依据权限实现的按钮显隐控制和界面变化都可以很方便的实现。</p><p>但做按钮权限麻烦的地方不在于如何实现，而在于高昂的维护成本。我们假设按钮Btn绑定了点击回调Fn，回调Fn里发起了请求Req，请求Req需要某个资源的访问权限，最终你要根据用户是否拥有Req的权限决定Btn是否显示，而Req跟Btn之间并没有直接关联，所以我们就要人肉维护他们的关系，一个复杂项目里的按钮有个几十上百都很正常，随着业务的变更去维护这么多按钮的权限，想想都头疼。</p><p>有一个方法可以绕开这个烂摊子，那就是前端放弃对视图层的控制，退到请求层面，在请求发起前集中拦截，这时可以直接根据请求方法和请求地址来校验权限，除了实现一个拦截器之外不需要额外的代码，可以说非常优雅了。以<code>axios</code>为例，拦截器大概长这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(function (config) &#123;</span><br><span class="line">  let permission = config.method + config.url.replace(config.baseURL,&apos;,&apos;);</span><br><span class="line">  if(!has(permission))&#123;</span><br><span class="line">  //验证不通过</span><br><span class="line">    return Promise.reject(&#123;</span><br><span class="line">      message: `no permission`</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  return config;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但如果仅仅这样做权限控制，界面上将显示出所有的按钮，用户看到的按钮却不一定可以点击，这种体验我认为只能停留在理论层面，根本无法应用到实际产品中。请求控制可以作为整个控制体系的第二道防线，或某些特殊情况下的辅助手段，最终还是要回到按钮控制的思路上来。</p><p>那么怎样能尽可能方便的采集到每个按钮所需的权限呢？按钮和权限之间隔着两层东西，第一层是click回调，第二层是回调里的AJAX请求，不想人肉维护就得想办法突破这两层隔阂，让按钮和权限产生联系，按钮必然要绑定click事件，最理想的采集方式是在绑定事件的同时得到所需权限，让一切自然而然的发生，比如我们可以实现一个完美的<code>v-do</code>指令，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;btn v-do=&quot;Fn&quot;&gt;按钮&lt;/btn&gt;</span><br></pre></td></tr></table></figure><p>如果<code>Fn</code>能以某种形式采集到内部的AJAX请求参数，并转化成权限信息传递出来就完美了，然而我没找到可行的方法，并且这种形式在应用上也存在缺陷，因为不一定每个操作按钮都会发起AJAX请求，比如编辑按钮本身并不会触发请求，真正触发请求的是另一个保存按钮，所以这个思路只是看起来很美。</p><p>退而求其次的做法是让按钮和请求联系起来，比如说按钮涉及一个名称为A的请求，那么我希望权限指令可以这样写，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;btn v-has=&quot;A&quot; @click=&quot;Fn&quot;&gt;按钮&lt;/btn&gt;</span><br></pre></td></tr></table></figure><p>比完美形态是差了不少，但起码不需要手动维护到<code>&#39;get,/resources&#39;</code>这个级别了，这里对A的实现可以有多种形式，比如A可以是一个包含两个属性的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const A = &#123;</span><br><span class="line">  p: [&apos;put,/menu/**&apos;],</span><br><span class="line">  r: params =&gt; &#123;</span><br><span class="line">    return axios.put(`/menu/$&#123;params.id&#125;`, params)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//用作权限：</span><br><span class="line">&lt;btn v-has=&quot;[A]&quot; @click=&quot;Fn&quot;&gt;按钮&lt;/btn&gt;</span><br><span class="line"></span><br><span class="line">//用作请求：</span><br><span class="line">function Fn()&#123;</span><br><span class="line">    A.r().then((res) =&gt; &#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们会将项目里所有的api放在一个api模块里集中管理，在写api时顺便就把权限给维护了，换来的是在组件界面里可以直接用请求名称来描述权限，而不需要来回奔波于界面和api模块之间，一定程度上实现了关注点分离，而且has指令还可以进一步做优化，例如参数只需要接收A，指令内部根据约定自动访问A.p来获取权限，还可以接收数组，允许多个权限联合校验，尽可能降低按钮权限的维护成本。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>总结一下，因为我的项目包含了管理端和客户端的所有功能，角色差异比较大，因此路由权限没有在before钩子里做，而是在登录后启动前进行路由筛选，省去了每次都要在before钩子里做校验的麻烦；按钮权限使用自定义指令实现，并且将验证方法全局混入，便于在界面上使用<code>v-if</code>；最后为axios设置拦截器，作为权限控制的第二道防线。</p><p>好了，这就是我对前端权限控制的一些实践和思考，如有不当欢迎指正。</p><p>最后吐槽一下Element-UI，真心难看。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/08/29/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>混合应用从开发到发布</title>
      <link>https://refined-x.com/2017/08/08/%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E4%BB%8E%E5%BC%80%E5%8F%91%E5%88%B0%E5%8F%91%E5%B8%83/</link>
      <guid>https://refined-x.com/2017/08/08/%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E4%BB%8E%E5%BC%80%E5%8F%91%E5%88%B0%E5%8F%91%E5%B8%83/</guid>
      <pubDate>Tue, 08 Aug 2017 06:47:56 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;前段时间基于&lt;a
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>前段时间基于<a href="//refined-x.com/HybridStart/">HybridStart</a>开发了一个公司内部APP，重走了一遍混合应用从开发到发布的整个流程，唤起了很多坑的记忆，也为HybridStart修复了不少细节bug，下面简单回顾一下过程中值得一提的几个点。</p><h2 id="开发前准备"><a href="#开发前准备" class="headerlink" title="开发前准备"></a>开发前准备</h2><p>基于APICloud+HybridStart开发混合应用的门槛是极低的，一个初级水平的前端开发就应该可以从容搞定，这里有一个详细的<a href="http://jingyan.baidu.com/article/eb9f7b6d60e18f869264e847.html" target="_blank" rel="external">混合应用新手入门教程</a>；对于有一定经验的开发者，在做好项目准备工作之后，应该排查以下几项东西有没有准备好：</p><ul><li>APP图标 200x200 png格式</li><li>APP启动页 1080x1920 格式不限</li><li>IOS测试证书和发布证书（安卓证书平台可以自动生成）</li><li>添加所需模块，移除冗余模块</li><li>核对<code>config.xml</code>中的信息，包括appID、权限信息</li></ul><p>以上都准备就绪后就可以在平台上打包一个”自定义Loader”，安装到安卓手机上，打开IDE，开启wifi调试，进入无忧无虑的APP开发阶段了。</p><h2 id="开发中可能遇到的坑"><a href="#开发中可能遇到的坑" class="headerlink" title="开发中可能遇到的坑"></a>开发中可能遇到的坑</h2><p>安卓上的问题自4.4.2之后就比较少了，可能出现的绝大多数问题都属于表现层面上的兼容问题，基本上都是由于ROM厂商对webview的篡改导致的，这次开发的APP面向的主要用户群体是IOS用户，安卓上面没有做大规模的测试，仅在开发中遇到了一个页面切换闪白色块的问题，表现为返回到部分页面时屏幕上会随机闪现大块的白色色块，页面进场后消失。首先排查模块，发现不是模块导致的，加上受影响的页面很固定，所以猜测问题出在webview上，可能是问题页面的部分样式写法触发了渲染bug，经过对样式的排查，果然找到原因了，是一个绝对定位的伪元素引起的，加上<code>transform:translate3d(0,0,0);</code>强制开启硬件加速之后解决了问题。</p><p>IOS上的问题历来是不多，但很奇葩，这次遇到的问题也算IOS上的一个经典问题了，就是把滚动元素的事件委托在<code>body</code>上无效，只能委托在<code>body</code>内的一个容器元素上，而且<code>body</code>的高度还必须自动，如果<code>body</code>高度<code>100%</code>，那么会出现更奇葩的情况，当前屏幕范围内的元素事件可以触发，滚动后新进入屏幕的元素事件不会触发，只能理解为滚动后相当于把<code>body</code>整体上移了，导致点击事件没有落在<code>body</code>元素上，而这毫无疑问是个bug。</p><h2 id="IOS上架"><a href="#IOS上架" class="headerlink" title="IOS上架"></a>IOS上架</h2><p>开发完成后最大的一个难关就是IOS上架了，这次上架总体还算顺利，被驳回一次是因为自己的疏忽，申请了一个没有必要的权限，因为HybridStart默认集成了百度地图插件并开发了定位相关的功能演示，所以在<code>config.xml</code>里申请了一个后台定位的权限，新APP并不需要定位和地图相关功能，因此将模块及相关代码都移除了，但百密一疏忘了将<code>config.xml</code>的权限删掉，导致被驳回，这里也给大家提个醒，如果要上架的话这些细节一定记得检查。</p><p>混合应用IOS上架另一个最常犯的错误就是忘了屏蔽自动更新，自动更新太方便了，基本所有的APP都会做，但如果IOS版要上架苹果商店，一定记得在IOS里隐藏相关功能按钮，否则一定上不了架的。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>经过这次项目的检验HybridStart已经准备好了应对各种类型的混合应用开发，代码仍在持续维护，文档主要内容已完成，解决方案部分和细节修缮我会抽时间完成。</p><p>附：</p><ol><li><a href="//refined-x.com/HybridStart/">HybridStart项目主页</a></li><li><a href="http://jingyan.baidu.com/article/eb9f7b6d60e18f869264e847.html" target="_blank" rel="external">混合应用新手入门教程</a></li><li>本次项目部分截屏</li></ol><p><img src="https://github.com/tower1229/tower1229.github.io/raw/master/asset/yjk-screen%20%281%29.png" alt="此处输入图片的描述"><br><img src="https://github.com/tower1229/tower1229.github.io/raw/master/asset/yjk-screen%20%285%29.png" alt="此处输入图片的描述"><br><img src="https://github.com/tower1229/tower1229.github.io/raw/master/asset/yjk-screen%20%282%29.png" alt="此处输入图片的描述"><br><img src="https://github.com/tower1229/tower1229.github.io/raw/master/asset/yjk-screen%20%283%29.png" alt="此处输入图片的描述"><br><img src="https://github.com/tower1229/tower1229.github.io/raw/master/asset/yjk-screen%20%284%29.png" alt="此处输入图片的描述"></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/08/08/%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E4%BB%8E%E5%BC%80%E5%8F%91%E5%88%B0%E5%8F%91%E5%B8%83/#disqus_thread</comments>
    </item>
    
    <item>
      <title>混合应用页面打开速度优化</title>
      <link>https://refined-x.com/2017/07/21/%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E9%A1%B5%E9%9D%A2%E6%89%93%E5%BC%80%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/</link>
      <guid>https://refined-x.com/2017/07/21/%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E9%A1%B5%E9%9D%A2%E6%89%93%E5%BC%80%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/</guid>
      <pubDate>Fri, 21 Jul 2017 07:15:58 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;我们都知道混合应用的流畅性不如原生应用，除了不能像原生一样轻松驾驭各种狂拽酷炫的效果，混合应用还有一个难以消除的弱点在于页面打开速度上，如果有机会在同一台手机上直接对比的话，这种差距是普通人都能直观感受到的，这主要是由于web页面每次打开前需要初始化，在那一瞬间需要完成DO
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>我们都知道混合应用的流畅性不如原生应用，除了不能像原生一样轻松驾驭各种狂拽酷炫的效果，混合应用还有一个难以消除的弱点在于页面打开速度上，如果有机会在同一台手机上直接对比的话，这种差距是普通人都能直观感受到的，这主要是由于web页面每次打开前需要初始化，在那一瞬间需要完成DOM创建、资源下载、样式渲染、js执行，这些时间消耗造成了按键按下与页面进场之间短暂的停顿，也造成了混合应用整体“不流畅，不跟手”的印象，HybridStart 1.1.1版本针对性的优化了页面打开速度，下面就介绍一下具体是怎么做的。</p><h2 id="怎么做优化"><a href="#怎么做优化" class="headerlink" title="怎么做优化"></a>怎么做优化</h2><p>混合应用乃至所有前端项目的优化工作，总结起来其实都是在试图消除延迟感，消除延迟感要从两方面着手，一是提升绝对速度，做到不慢；二是增加过度效果，填充停顿，让用户无瑕感知到慢；这两方面是做好优化的关键。</p><h2 id="提升绝对速度"><a href="#提升绝对速度" class="headerlink" title="提升绝对速度"></a>提升绝对速度</h2><p>在混合应用中打开一个页面，会发生如下几个事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">渲染完成 =&gt; 加载完成 =&gt; runtime就绪</span><br></pre></td></tr></table></figure><p>这三个事件是依次发生的，apicloud为了保证页面打开即是显示完整的，所以会在页面<em>加载完成</em>之后开始进场动画，这里是优化的关键，我们分析一下加载完成之前都发生了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">载入DOM节点</span><br><span class="line">加载css/js/img</span><br><span class="line">页面渲染</span><br><span class="line">运行js</span><br><span class="line">js运行时创建DOM节点并渲染</span><br><span class="line">资源加载完成</span><br><span class="line">页面加载完成</span><br></pre></td></tr></table></figure></p><p>以上所有事情都发生在页面初始化，其中远程图片的加载是最耗时的，所以图片较多的页面建议使用<a href="//refined-x.com/HybridStart/docs/#lazyload%28%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%29">懒加载插件</a>，懒加载并不是简单的减少了第一批图片加载数量，而是将所有图片加载从初始化队列中移除，在页面打开后才开始加载，这能有效提高初始化速度，但代价是用户有大概率会看到图片加载过程，这里的取舍就需要分情况讨论了，我的建议是优先提升页面打开速度，多数情况下的图片加载过程不会造成很坏的用户体验。</p><p>排除掉图片之后，通常意义上讲已经没什么可优化的地方了，但在混合应用场景下，仍然有一部分提速空间可以被压榨，那就是js资源的加载和执行，与js相关的操作有这么几项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">载入js</span><br><span class="line">执行js</span><br><span class="line">js运行时创建DOM节点并渲染</span><br></pre></td></tr></table></figure></p><p>载入和执行本地js在桌面端可以被认为是实时的，但移动端的计算能力和IO能力都远差于桌面端，HybridStart中的每个页面需要加载一个配置文件和一个核心类库，核心类库运行后再异步获取页面脚本并执行，经过对比测试这些操作平均耗时在100ms左右，如果页面脚本中还有其他插件的引用或者同步创建DOM操作，那么耗时还会延长，并且会导致不同的页面打开速度差别很大。</p><p>我们知道混合应用页面打开后通常有一个进场动画，这个动画的时长默认300ms，所以我们可以想办法利用这300ms，将js相关操作从初始化队列中移除，转而在动画过程中进行，多数情况下所有的js加载和执行都可以在页面动画结束前完成，对用户体验的影响几乎为零，却可以提高页面初始化的速度。</p><p>具体实施过程是：先将页面底部脚本链接移除，写一段代码创建脚本节点，在合适的时机将脚本节点插入页面。关键是插入时机的选择，apicloud会监听页面加载完成事件，我们必须跳过这个时间节点，所以同步插入脚本是不行的，测试发现<code>apiready</code>事件可以跳过加载完成，而且耗时很少，完全可以被动画过程覆盖，因此就选择在<code>apiready</code>之后插入节点，可以满足需求，而且还带来一个不大不小的副产品，那就是业务代码不再需要<code>app.ready()</code>回调函数了，因为所有js的加载执行都在runtime就绪之后发生的。</p><p>优化后在测试机上普通页面的打开速度较之前至少提升100ms，对于大量依赖js运行的页面提速效果更明显。</p><h2 id="增加过度效果"><a href="#增加过度效果" class="headerlink" title="增加过度效果"></a>增加过度效果</h2><p>绝对速度的提升有明确的瓶颈，而且跟手机性能有很大关系，即使排除了图片和js的加载，页面初始化仍然需要处理DOM节点的创建和样式的渲染，为了保证用户体验这部分是无论如何都不能动的，但这部分操作的耗时多数情况下仍然能被用户感知到，这时我们只能使用障眼法，增加一些过度效果，减缓用户等待的焦虑感，v1.1.1中实验性的为<a href="//refined-x.com/HybridStart/docs/#list%28%E5%88%97%E8%A1%A8%29">列表组件</a>添加了触摸状态波纹效果，具体实现在<code>sdk/common.js</code>中，效果参见<a href="http://downloadpkg.apicloud.com/app/download?path=http://7xm7pq.com1.z0.glb.clouddn.com/8cb26eca4ee9f6ef2a06debb470b0eec_d" target="_blank" rel="external">v1.1.1示例APP</a>。</p><p>过渡效果更多的还是需要根据业务场景自定义，这个内置效果就当抛砖引玉了。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>项目主页：//refined-x.com/HybridStart/<br>项目文档：//refined-x.com/HybridStart/docs/</p><p>另外，HybridStart项目一直都是beta状态，近期手头正好有一个小项目，准备上手操练一下，估计近期将迎来bugfixed版本。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/07/21/%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E9%A1%B5%E9%9D%A2%E6%89%93%E5%BC%80%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/#disqus_thread</comments>
    </item>
    
    <item>
      <title>小程序上手指南</title>
      <link>https://refined-x.com/2017/07/20/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/</link>
      <guid>https://refined-x.com/2017/07/20/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/</guid>
      <pubDate>Thu, 20 Jul 2017 03:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;这是一门微信小程序入门课程，通过学习本节课程可以使你快速上手小程序开发，在学习这门课之前，需要你先具备基本的前端开发能力，包括html/css/JavaScrip，起码你得会切图，了解js语法。&lt;/p&gt;
&lt;h2 id=&quot;为什么学习小程序&quot;&gt;&lt;a
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>这是一门微信小程序入门课程，通过学习本节课程可以使你快速上手小程序开发，在学习这门课之前，需要你先具备基本的前端开发能力，包括html/css/JavaScrip，起码你得会切图，了解js语法。</p><h2 id="为什么学习小程序"><a href="#为什么学习小程序" class="headerlink" title="为什么学习小程序"></a>为什么学习小程序</h2><p>学习小程序之前要先了解，小程序是什么，有什么独特的地方值得我们一定要去学习它，小程序是<em>基于微信实现特定功能</em>的一种载体，同样基于微信实现功能的我们知道还有公众号和微网站，那小程序的特点是什么，我们用HTML5做一个手机站不行吗，再接入微信的SDK，功能也很强大，小程序最大的特点，就是可以拥有媲美原生App的流畅体验，这一点是非常诱人的，也是相比HTML5最大的优势，尤其学到后面你会发现小程序的开发还特别简单，开发又简单体验又好，天底下哪有这么便宜的事，但小程序就是这样一个东西。</p><p>小程序为什么能做到接近原生的体验呢，这是因为小程序在底层就是调用的原生组件，我们开发小程序编写的前端代码，可以理解为是调用微信内部原生组件的快捷方式，因此，开发小程序使用的必然是一种全新的语言，不可能是HTML5，本节课程就是带领大家一起来学习这门语言，并且完成一个小示例，让大家可以快速的对小程序开发有一个直观的认识。</p><h2 id="小程序开发语言介绍"><a href="#小程序开发语言介绍" class="headerlink" title="小程序开发语言介绍"></a>小程序开发语言介绍</h2><p>小程序的开发语言跟HTML5是非常相似的，视图层的两种语言WXML和WXSS就分别对应了HTML和CSS，逻辑层就仍然还是Javascript，为了便于理解，下面我就用小程序和HMLT5对比的方式，来讲解小程序的这三种开发语言。</p><p>首先我们说区别最小的，就是小程序里的这个JS，它跟web开发中的JS只有两点区别，第一，没有任何DOM操作相关功能，这一点跟Nodejs是一样的，大家知道Js语言本身就是不包括DOM操作的，DOM操作是浏览器环境为JS做的扩展；第二点区别，小程序里的Js增加了一些微信特有的API，这个很好理解，像微信扫码啊，上传下载啊这些功能，肯定是要单独提供API的。总结一下，去掉了DOM操作，增加了一些API，另外值得一提的是小程序中的js是支持模块化的，也支持ES6。</p><p>WXSS与CSS的区别，也是两点，第一，增加了一个rpx单位，这个单位具有自动适应屏幕宽度的特点，规则是1rpx = 屏幕宽度/750，这是个很好用的单位，可以说完美解决了屏幕适配的问题，如果你用过HTML5里的vw单位，会发现他俩是一回事，只不过1vw = 屏幕宽度/100，比例不太一样；第二个区别，WXSS支持的选择器类型有限，目前只支持<code>.class, #id, element, ele,ele, ::before, ::after</code>，注意，后代选择器是不支持的，这个我再开发工具里测试发现可以支持，但文档是明确说只支持上面那些，那我们就听文档的，后代选择器就不要用了。总结一下，WXSS相比CSS增加了rpx单位，不支持后代选择器；</p><p>最后WXML这块的内容比较多，尤其有一部分HTML里完全没有的东西，比如说数据绑定、条件渲染、列表渲染、模板、引用，这些东西我在这里就不展开讲了，如果你之前用过任何的前端MVVM框架或者前端模板引擎，那对这块内容应该是轻车熟路的，如果说这些东西都不知道，那也没关系，自己回去把文档这块内容仔细的阅读一遍，相信都能看明白是怎么回事。</p><p>这里我们就说两个东西，标签和事件，首先，标签彻底换了一套，所有的HTML标签都不能用，取而代之的是小程序提供的一套标签，官方把他们叫组件，不管叫什么，这个组件的写法和HTML标签是一样的，也是由标签名，属性，内容组成，也可以嵌套，也可以通过<code>class，id，style</code>来添加样式，但是小程序组件相对来说拥有更强大的功能，自带样式也更丰富，举个例子，</p><p><img src="https://github.com/tower1229/tower1229.github.io/raw/master/asset/weapp-picker.png" alt="weapp-picker"></p><p>如果要做这样一个从底部弹起的滚动选择器，想想是不是好麻烦，有很多样式和js要写，但是用小程序的组件来做，一个picker组件拿过来，全有了，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;picker bindchange=&quot;pickerChange&quot; value=&quot;&#123;&#123;index&#125;&#125;&quot; range=&quot;&#123;&#123;array&#125;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure><p>代码就这么多，样式都是自带的，工作量一下就小了很多，这是小程序在设计上非常好的一点，它在背后做了很多封装，就为了让开发者开发起来简单，实际上也达到了目的；</p><p>小程序的事件与HTML5里的事件，有哪些不一样呢，第一个就是事件绑定的写法不一样了，小程序里是bind+事件名或catch+事件名，bind绑定不阻止冒泡，而catch会阻止冒泡；另外支持的事件种类也不一样，常规事件只支持<code>touchstart，touchmove，touchend，touchcancel，tap，longtap</code>，除了这些事件以外，再有的事件就是组件的自定义事件，比如picker组件就有一个change事件，可以通过bindchange来绑定处理函数；第三个区别是事件对象不一样了，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;type&quot;:&quot;tap&quot;,</span><br><span class="line">&quot;timeStamp&quot;:895,</span><br><span class="line">&quot;target&quot;: &#123;</span><br><span class="line">  &quot;id&quot;: &quot;tapTest&quot;,</span><br><span class="line">  &quot;dataset&quot;:  &#123;</span><br><span class="line">    &quot;hi&quot;:&quot;WeChat&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;currentTarget&quot;:  &#123;</span><br><span class="line">  &quot;id&quot;: &quot;tapTest&quot;,</span><br><span class="line">  &quot;dataset&quot;: &#123;</span><br><span class="line">    &quot;hi&quot;:&quot;WeChat&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;detail&quot;: &#123;</span><br><span class="line">  &quot;x&quot;:53,</span><br><span class="line">  &quot;y&quot;:14</span><br><span class="line">&#125;,</span><br><span class="line">&quot;touches&quot;:[&#123;</span><br><span class="line">  &quot;identifier&quot;:0,</span><br><span class="line">  &quot;pageX&quot;:53,</span><br><span class="line">  &quot;pageY&quot;:14,</span><br><span class="line">  &quot;clientX&quot;:53,</span><br><span class="line">  &quot;clientY&quot;:14</span><br><span class="line">&#125;],</span><br><span class="line">&quot;changedTouches&quot;:[&#123;</span><br><span class="line">  &quot;identifier&quot;:0,</span><br><span class="line">  &quot;pageX&quot;:53,</span><br><span class="line">  &quot;pageY&quot;:14,</span><br><span class="line">  &quot;clientX&quot;:53,</span><br><span class="line">  &quot;clientY&quot;:14</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义事件会有detail属性，touch事件包括两个不同的属性，这些东西不用记，用到的时候知道去哪找就行了，总结一下，事件绑定的写法bind/catch，事件类型6种+组件自定义事件，事件对象的内容有区别；</p><h2 id="小程序开发框架介绍"><a href="#小程序开发框架介绍" class="headerlink" title="小程序开发框架介绍"></a>小程序开发框架介绍</h2><p>掌握了小程序的开发语言之后，我们还必须掌握小程序的开发框架，框架故名思意就是条条框框，是用来具体的告诉你怎样开发小程序，我们先看一下小程序的目录结构，</p><p><img src="https://github.com/tower1229/tower1229.github.io/raw/master/asset/weapp-tree.png" alt="weapp-tree"></p><p>这是一个比较典型的微信小程序项目结构，最下面三个文件名字都叫app，一个js一个json一个wxss，这三个是固定的，就得叫这个名字，就得放在这，另外的三个文件夹分别是放页面、放样式的、放工具类的，当然你可以根据项目实际需求随便改。</p><p>其中这个app.json就是小程序的配置文件，可以看到打开里面是一个对象，配置了页面和window的一些属性，具体还有哪些配置以及他们的意义可以自己到文档中去进一步的了解。</p><p>然后我们就从上往下说这个目录结构，首先你会发现页面是以文件夹为组织单位的，每个页面至少要包含<code>js    wxml wxss</code>这三个文件，而且这些文件都跟文件夹同名，这是一个约定，必须这么干，然后还有一个json文件是可选的，里面可以对当前页面做单独的设置。下面这个util文件夹没什么说的，不是硬性要求，可有可无。再然后app.js，这个文件是非常重要的，它主要做两件事，一是定义小程序的生命周期函数，二是可以在这里定义全局数据或全局方法，我们看代码，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//app.js</span><br><span class="line">App(&#123;</span><br><span class="line">  onLaunch: function () &#123;</span><br><span class="line">    //调用API从本地缓存中获取数据</span><br><span class="line">    var logs = wx.getStorageSync(&apos;logs&apos;) || []</span><br><span class="line">    logs.unshift(Date.now())</span><br><span class="line">    wx.setStorageSync(&apos;logs&apos;, logs)</span><br><span class="line">  &#125;,</span><br><span class="line">  getUserInfo:function(cb)&#123;</span><br><span class="line">    var that = this</span><br><span class="line">    if(this.globalData.userInfo)&#123;</span><br><span class="line">      typeof cb == &quot;function&quot; &amp;&amp; cb(this.globalData.userInfo)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      //调用登录接口</span><br><span class="line">      wx.login(&#123;</span><br><span class="line">        success: function () &#123;</span><br><span class="line">          wx.getUserInfo(&#123;</span><br><span class="line">            success: function (res) &#123;</span><br><span class="line">              that.globalData.userInfo = res.userInfo</span><br><span class="line">              typeof cb == &quot;function&quot; &amp;&amp; cb(that.globalData.userInfo)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  globalData:&#123;</span><br><span class="line">    userInfo:null,</span><br><span class="line">    apiKey: &quot;c2d3e04cc633644f1c3ae3f6eea94564&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个onLaunch就可以定义一个小程序初始化的回调，下面getUserInfo显然就是一个自定义的函数了，再往下是一个globalData属性，也是自定义的，用这些配置将小程序初始化后，可以在任意页面中使用getApp()方法获取到小程序示例，进而访问到这些自定义方法或数据。</p><h2 id="开发一个《星座配对》小程序"><a href="#开发一个《星座配对》小程序" class="headerlink" title="开发一个《星座配对》小程序"></a>开发一个《星座配对》小程序</h2><p>《星座配对》小程序功能虽然很简单，但大多数小程序开发常用的API都用到了，是一个很好的上手项目。</p><p>源码：<a href="https://github.com/tower1229/weapp-star" target="_blank" rel="external">weapp-star</a></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/07/20/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hexo自定义页面的方法</title>
      <link>https://refined-x.com/2017/07/10/Hexo%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <guid>https://refined-x.com/2017/07/10/Hexo%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <pubDate>Mon, 10 Jul 2017 06:06:46 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;Hexo是静态页博客生成利器，同很多博主一样，&lt;a href=&quot;//refined-x.com&quot;&gt;前端路上&lt;/a&gt;原创技术博客也是使用Hexo生成并托管在Github
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>Hexo是静态页博客生成利器，同很多博主一样，<a href="//refined-x.com">前端路上</a>原创技术博客也是使用Hexo生成并托管在Github Page上的，但在使用Hexo的过程中遇到一个小问题，Hexo默认会对<code>/source/</code>里的所有页面应用主题模板渲染，但有一些前端作品或demo页我们不希望经过渲染，而是能保持完全自定义的样子，那该怎么用Hexo添加自定义的web页面呢？</p><p>下面介绍两种方法。</p><p>第一种方法是使用Hexo提供的跳过渲染配置，适用于整个目录的设置。具体步骤，打开博客根目录<code>_config.yml</code>，找到其中<code>skip_render</code>项，这个项目用来配置<code>/source/</code>中需要跳过渲染的文件或目录，例如希望跳过<code>/source/projects/</code>里的所有文件渲染，可以配置为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip_render: projects/**</span><br></pre></td></tr></table></figure></p><p>匹配规则是一种类似正则的规则，官方给出的参考是<a href="https://github.com/isaacs/minimatch" target="_blank" rel="external">这个</a>。另外在测试这个功能的时候发现，Hexo的内部缓存不是特别好用，有时候你修改了配置但生成出来的内容不一定及时应用了新配置，最好在生成之前执行一下<code>hexo clean</code>命令，清除掉旧的生成文件和缓存。</p><p>第二种方法是给单个文件添加不应用模板的标记，适用于个别特殊文件的处理。例如我们的网站如果要使用百度统计，往往需要在根目录放一个html格式的验证文件，这个文件默认也会经过用主题模板渲染，避免渲染的办法就是在文件头部添加如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">layout: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>这样，这个文件就不会经过模板渲染，最终发布到<code>/public/</code>里的文件就是去掉标记后的文件的样子。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/07/10/Hexo%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HybridStart v1.0开发纪要</title>
      <link>https://refined-x.com/2017/07/07/HybridStart%20v1.0%E5%BC%80%E5%8F%91%E7%BA%AA%E8%A6%81/</link>
      <guid>https://refined-x.com/2017/07/07/HybridStart%20v1.0%E5%BC%80%E5%8F%91%E7%BA%AA%E8%A6%81/</guid>
      <pubDate>Fri, 07 Jul 2017 06:58:47 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;自混合应用前端开发框架&lt;code&gt;HybridStart v1.0&lt;/code&gt;&lt;a
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>自混合应用前端开发框架<code>HybridStart v1.0</code><a href="//refined-x.com/2017/07/03/%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF%E6%A2%B3%E7%90%86/">升级计划</a>开始后，经过近一周的开发测试，现已发布<a href="https://github.com/tower1229/HybridStart" target="_blank" rel="external">预览版</a>，基本实现了最初定下的四个目标：核心易用、UI可剥离、开发模式清晰、开发体验优秀，这也是我理想中的以web前端技术为主的，混合应用开发的正确姿势。在这个过程中将一些笼统的思路细化并落地，也将一些过去思路不对的地方推倒了重构，在通用性方面也做了更多的考量，下面就从核心和UI两大部分入手，详细拆解一下升级后的HybridStart。</p><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><h3 id="移除依赖"><a href="#移除依赖" class="headerlink" title="移除依赖"></a>移除依赖</h3><p>之前的<code>core.js</code>直接集成部分第三方插件，并且内部实现也互相依赖，这对于不同技术栈的开发者来说很不友好，比如有的开发者喜欢用Vue做模板渲染，那他看到依赖jQuery后心里一定恶心无比，因此要做的第一件事就是移除核心库的依赖。</p><p>移除掉jQuery势必就要自己动手做一个<code>util</code>工具类，以简化原生JavaScript语法，这里我偷了个懒直接把mui的部分代码拿过来，稍作修剪和扩充就ok了。在功能取舍方面，除了满足核心库的需求外还增加了少数几个常用操作，使这部分功能对外开放后能一定程度上发挥jQuery的作用，通过<code>app.util</code>可以获取到这个内部工具集合，经过内置示例的开发体验，应该说只要DOM操作不是很重的情况，基本可以让jQuery歇息了，当然前提是大量的jQuery语法糖都不能用了，其实用习惯了原生语法，会觉得除了单词长一点也并没有多麻烦。</p><h3 id="功能梳理"><a href="#功能梳理" class="headerlink" title="功能梳理"></a>功能梳理</h3><p>框架功能都挂载在<code>app</code>对象上，主要提供这五类功能：核心功能、窗口操作、数据操作、设备访问、原生控件。</p><h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h4><p>核心功能以APP运行周期内的事件或操作为主，比如各种事件监听、按键监听，全局事件的发布/订阅，原生能力就绪的回调方法等，这些方法都直接挂载在<code>app</code>对象上，例如<code>app.ready(callback)</code>。</p><p>着重说一下原生能力就绪回调，HybridStart里一个典型的页面js文件是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * script</span><br><span class="line"> */</span><br><span class="line">define(function(require) &#123;</span><br><span class="line">    require(&apos;sdk/common&apos;);</span><br><span class="line">    var $ = app.util;</span><br><span class="line">    //立即执行</span><br><span class="line"></span><br><span class="line">    app.ready(function() &#123;</span><br><span class="line">    //runtime就绪</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>可以看到正文明显被<code>app.ready()</code>方法分隔成上下两部分，上面空白处的代码将在页面加载后立即执行，ready回调内的代码将等待原生能力就绪后被执行，我们鼓励将所有不需要原生能力的操作放在上面，以提升脚本响应速度，这个没什么问题。</p><p>但可能遇到的一个问题是，如果一个依赖原生能力的功能被开发者立即执行了，将会因为runtime未就绪而报错，也就是说需要开发者明确的知道那些功能依赖runtime哪些不依赖，如果试图解决这个问题很容易想到的一个办法是，将所有依赖runtime的功能在内部用ready方法包裹一下，这样表面上可以解决问题，但因为ready的异步特性，可能导致代码执行顺序与书写顺序不一致，这无疑是不可接受的。最终在两者间做了妥协，将这些功能在内部用另一个readyEval方法包裹，readyEval方法仅仅在检测到runtime未就绪时给控制台抛出调试信息，而不会中断后续代码的执行，算是一个容错性的处理吧。</p><h4 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h4><p>窗口操作包括对window和frame的常用操作，比如打开、关闭、移动、执行脚本等，这些方法都挂载在<code>app.window</code>对象上，例如<code>app.window.open()</code>。</p><p>作为最基础也最常用的操作，封装目标就是易用，比如打开窗口这个操作，即便有了<code>app.window.open()</code>也仍然觉得不够简单，因此进一步封装了<code>app.openView()</code>，可以说让绝大多数场景下的打开窗口变得极致简单了，看下两个方法的对比：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.window.open(&#123;</span><br><span class="line">    url:&apos;./view/member/index/temp.html&apos;,</span><br><span class="line">    pageParam: &#123;</span><br><span class="line">        id: 123</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.openView(123, &apos;member&apos;, &apos;index&apos;);</span><br></pre></td></tr></table></figure></p><p>openView方法的详细介绍可以参见<a href="//refined-x.com/2017/06/26/%E5%9F%BA%E4%BA%8EAPICloud%E7%9A%84%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/">这里</a>，openView的参数传递是借助本地存储实现的，这次升级也为其配套了一个获取参数的方法<code>app.getParam()</code>，专门用来获取openView方法传递的参数，并且支持对象类型的存取。</p><h4 id="内建机制"><a href="#内建机制" class="headerlink" title="内建机制"></a>内建机制</h4><p>简化开发另一个很重要的方向是内建机制，举个例子，实现会员退出登录，需要跳转到登录页同时关闭所有后台页面，关闭后台页面的功能apicloud提供了，但本着<em>尽量不使用特定平台提供的特殊能力</em>原则，这个功能在框架中用另一种方式实现了，而且使用起来超简单，比如可以这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.openView(&#123;</span><br><span class="line">    closeback: true</span><br><span class="line">&#125;, &apos;member&apos;, &apos;login&apos;);</span><br></pre></td></tr></table></figure></p><p>内部实现是，每一个页面打开后会在window上挂载一个”isBack”属性，通过监听本窗口的前后台状态更改这个属性的值，当openView方法的closeback被设置为<code>true</code>时，将在打开新页面前在本地存储埋下一个标记，新页面打开后通过这个标记得知自己的任务，然后发布一个相应的全局事件，所有页面都能通过这个事件得知自己的任务，比如任务是<em>关闭后台页面</em>，那么就会检查自己的<code>window.isBack</code>属性，发现是真值就关闭自身，从而完成这个任务。</p><p>其实就是利用全局通信能力建立起来的关闭机制，依据这个思路，还可以扩展出打开新窗口同时关闭自身的方法，比如订单提交场景，提交成功后通常会跳转到一个提示页，但是我们不希望从这个提示页可以返回到刚才的提交订单页，所以希望打开提示页的同时关闭订单页，那么实现的代码将是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.openView(&#123;</span><br><span class="line">    closeself: true</span><br><span class="line">&#125;, &apos;shop&apos;,&apos;orderSubmitSuccess&apos;)</span><br></pre></td></tr></table></figure></p><p><code>closeself</code>与<code>closeback</code>的区别仅仅是给当前页面增加了一个”closeByNew”的属性，然后本地存储埋了另外一个标记，发布了另外一个任务，新页面打开后照例发布全局事件公布任务，订单页收到任务后发现自己具有”closeByNew”属性，于是关闭了自身。</p><p>这些功能都集成在openView方法的配置中，说起来很罗嗦，用起来确特别简单，这类问题只在安卓系统上有，因为IOS没有返回键，只要界面不提供返回按钮用户是不可能随意返回上一个页面的。</p><p>框架另外还做了一件事，就是为frame页面的window对象扩展了一个”selfTop”属性，属性值是当前frame距离屏幕顶部的距离，这个值当在frame需要打开带界面的原生插件时很有用，比如打开百度地图，需要你指定地图距离屏幕顶部的距离，如果frame不知道自己距离屏幕顶部有多远，就不可能知道这个值应该是多少，这也算一个隐性需求，不用不知道，用了都说好。</p><h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><p>数据操作分为数据请求和数据存储两块内容。</p><p><strong>数据请求</strong>也就是<code>app.ajax()</code>方法，主要用来异步获取数据，当然也包括上传和下载，但他们都被单独封装成了插件，这里不做讨论。</p><p><code>app.ajax()</code>在易用性上的改进体现为增加了默认错误处理，约定交互格式以及格式检查，api风格几乎照搬<code>jQuery.ajax</code>，没有太多值得说的。在此基础上<code>app.ajax()</code>还针对APP开发场景做了两项功能扩展，一是请求加密，二是快照式缓存。</p><p>请求加密通过默认集成的加密模块<code>app.crypto</code>实现，加密算法为3DES，加密后的所有Ajax请求将集中发送到一个url地址，本次请求的真实url和参数以特定方式组织并加密，并将密文以参数形式发送，服务端需要有对应的解密方法得知请求url和参数，并将返回数据也做3DES加密返回给前端，前端解密后得到真实数据，整个过程中的关键是3DES算法的<code>secret</code>，这个值使用apicloud提供的加密存储方式存储，APP被反编译也无法拿到这个密匙，因此理论上实现不可逆加密。至于加密请求为什么要集中发送到一个url，其实是因为之前有的项目后端是这样处理的，如果要修改这个加密逻辑其实也很简单，详细的加密过程参考文档，这里不做赘述（如果发现文档没写完，也请不要奇怪- -!）。</p><p>ajax缓存功能apicloud的原生接口也有提供，不过他的缓存是没有更新机制的，一次缓存终生使用，除非做全局的缓存清理，简单说，这个功能很鸡肋。<code>app.ajax()</code>专门增加了一种快照式缓存，每一次请求成功后都会将结果保存为快照，下次这个请求再发起时会先将快照结果返回，待真实数据到达后再返回真实数据，也就是说启用快照缓存的请求将执行两次回调，这个听起来有点奇葩，但应用场景确很普遍，比如说打开一个列表页，通常要有一个loading然后请求到数据后显示到页面上，而使用快照缓存的结果是，打开页面马上呈现最近一次的数据，待新数据拿到后再更新一次页面，我认为这是体验更佳的方式。</p><p>可能有的同学会想，如果单纯只是渲染页面还好，万一请求数据后还有一些业务操作，那你执行两次肯定是不行的，没错，为了解决这个问题，快照数据如果是对象的话，会自动为这个数据增加一个”snapshoot”属性，你可以通过检测这个属性来得知当前数据是否为快照，以避免业务操作重复执行。</p><p>快照缓存目前来看的问题是，没有做新数据与快照是否相同的检测，导致如果两次数据相同，也会让页面白白重新渲染一次，后续会考虑改进这个功能。</p><p><strong>数据存储</strong>模块提供本地数据的增删改查功能，适用于少量应用数据的存储方法挂载在<code>app.storage</code>对象上，比如<code>app.storage.val()</code>。</p><p>因为是依托<code>localStorage</code>实现的，所以原来不支持对象类型的存取，这次升级支持了对象类型，其实也就是内部自动做了转化；另外增加了一个<code>app.storage.clear()</code>方法，用来清除存储的数据，但我们常常会有一些数据是希望能不受影响的、持久的存储，比如用户信息、权限等等，那么可以将这些值的key加到配置文件中的<code>appcfg.set.safeStorage</code>安全存储项目里，多个值用逗号隔开，”clear”方法默认会跳过不清理这些存储项，除非启用强制清理。</p><p>顺带说另外一个相关的配置<code>appcfg.set.temporary</code>临时存储，这个配置的意思是这些值每次APP退出后都将自动清除。</p><h5 id="设备访问"><a href="#设备访问" class="headerlink" title="设备访问"></a>设备访问</h5><p>设备访问能力提供对手机硬件的信息获取和其他操作能力，比如获取系统信息、拨打电话、安装文件等等，他们被挂载在<code>app.device</code>对象上，例如<code>app.device.call()</code>。</p><p>这部分就是单纯的封装引擎功能，没什么可说的，目前支持的功能并不很多，因为这些东西我用的不多，不确定哪些是必要的，所以这部分有待后期观察，再做调整。</p><h4 id="原生控件"><a href="#原生控件" class="headerlink" title="原生控件"></a>原生控件</h4><p>原生控件就是系统自带的UI控件，比如loading、alert、confirm、actionSheet等，因为还比较常用所以直接挂载到了<code>app</code>对象上，比如<code>app.alert()</code>。</p><p>这部分一开始我还纠结要不要封装，因为他们应该归到UI层面，既然是UI的东西核心里不应该集成，但想了想，目前apicloud没有一个拿得出手的同类插件，总得有东西用啊，所以就封装进来了。这肯定不是个长久之计，因为大部分安卓系统的原生控件实在太丑，这个后期再想想办法，争取解决掉。</p><p>目前有一个不成熟的思路是用web来做，但web有一个致命的问题是可能受到frame窗口的限制，无法做到模态，还可能被其他控件遮挡，这个问题可以通过打开一个透明window来解决，在这个window上显示控件，操作后再隐藏到底层去，可能的问题有两个，一个是响应速度不知道够不够快，再就是跨窗口通信内容比较多，可能导致实现很复杂，进一步拖慢速度。最好还是找到一个靠谱的原生插件。</p><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><h3 id="css组件"><a href="#css组件" class="headerlink" title="css组件"></a>css组件</h3><p>框架自带一套css组件放在<code>sdk/ui.css</code>中，这次经过小幅修改，着重删掉了一些冗余代码和微调了部分组件的样式。</p><p>为了实现<em>UI可剥离</em>，放弃了之前做的主题功能，这个主题功能简单说就是页面一开始是隐藏的，模板引擎解析得到主题css后动态插入页面才让页面显示出来，从性能角度讲放弃这种做法也算是走上了正道，但我记得之前在一次项目中发现，部分安卓机会出现页面打开之初先按照物理分辨率解析，随后布局抖动再恢复为像素分辨率，感觉是webview打开过程发生了一个异步的调整，这个体验是毁灭性的，主题功能的另一个作用就是解决这个问题，不过现在我已经找不到那台测试机了，目前这个问题是否还存在是未知的，有待经过实际项目检验。</p><p>如果不满意这套UI是可以直接抛弃掉的，跟框架其他部分几乎没有耦合，如果感觉还能凑合用，换主题功能就只能通过修改<code>less</code>文件来实现了，<code>less</code>文件估计将在文档写完后放出，在这之前暂时只能手动改样式了。</p><h3 id="js插件"><a href="#js插件" class="headerlink" title="js插件"></a>js插件</h3><p>框架内置了部分常用插件，比如图片轮显、相册、各种选择器、滚动加载、图片懒加载等等，体验都还不错，部分来自<a href="//refined-x.com/Flow-UI/docs/">Flow-UI</a>的插件库，针对移动端做了微调，使用上还是一贯的模块化。</p><p>虽然有了<code>app.util</code>之后就不再提倡使用jQuery了，但如果有人在乎的话，内置jQuery的版本已经升级到3.x。</p><p>原来内置在<code>core.js</code>里的<code>etpl</code>也成为了一个插件模块，用来实现前端页面渲染。应该说开发混合应用免不了大量的页面渲染，Vue当然是最好用的工具之一，但把一个功能完备的MVVM框架拿来做渲染，总觉得的有点冗余，而且依我过去的项目经验，大部分渲染其实都是单向的，也就是展示型的，需要将界面操作反应到数据中的情况不太多，在这种情况下，单从代码利用率的角度讲前端模板引擎是“实惠”的选择。</p><p>但模板引擎的使用体验比Vue差太多了，先要解析模板，再应用数据，最后填充到页面中，为了减轻这部分负担插件库中提供了一个<a href="//refined-x.com/Flow-UI/docs/#Render%28%E6%B8%B2%E6%9F%93%E5%99%A8%29">Render</a>插件，可以实现<code>数据=&gt;界面</code>的单向绑定，除了不是双向绑定，在渲染操作上已经接近Vue的体验了，当然差别还是有的，因为内部是使用<code>etpl</code>实现的，并没有高大上的差量更新，所以大范围的页面更新理论上效率不如Vue，这个有待低端机测试，千元以上的手机应该不太会看出差别。</p><p>当然，这些也都属于UI，可以用自己喜欢的任意方案替换掉。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>还有一些功能，散布在框架<code>sdk/</code>里的common.js和server.js中，严格来说这些代码已经不属于框架核心范畴，开发者可以根据自己的业务情况做删改，但其中有一些还是很实用的，举个例子。</p><p>不知道大家有没有发现，apicloud在引擎层面对页面显示做了优化，打开一个页面前多少会有一点停顿，猜测是在页面没有完全渲染完之前不会开始进场动画，因此有动态渲染内容的页面打开会很迟钝，纯静态的页面打开就利索很多，虽然这可以有效解决布局闪动的问题，但有时候这并不是开发者想要的，而造成打开速度差异的最重要原因就是图片元素的加载，所以为了解决这个问题，我们可以先将页面里的图片”src”值赋给”data-src”，使图片不会立即加载，当页面显示完毕后再将”data-src”赋给”src”以加载图片，从而绕过引擎的优化方案，提升页面打开的响应速度，这个操作已经在框架默认的<code>sdk/common.js</code>中实现了，并在示例APP中部分应用，效果明显。</p><p>common.js和server.js中还有很多实用的功能，比如图片自动缓存、给按钮添加点击效果、封装获取经纬度功能、通过经纬度反查地址功能、推送功能等等，具体有啥就自己去看吧，这里不一一列举了。</p><h2 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h2><h3 id="瓶颈明显"><a href="#瓶颈明显" class="headerlink" title="瓶颈明显"></a>瓶颈明显</h3><p>混合应用目前的体验确实不理想，为此我还特地对比性的研究了下Dcloud，感觉文档好专业好极客，各种优化手段好极致，但他们的体验APP也并有明显的流畅性差异，所以我甚至认为，这就是以web技术为主的混合应用开发模式的瓶颈，这种体验跟当下大家对主流APP的期待已经产生了不小的差距，做混合应用很重要的一项工作就是修补这些瑕疵。</p><p>要说apicloud跟Dcloud完全没差别也是不准确的，粗略的看至少有两点apicloud不如Dcloud做的好，第一是apicloud的后台页面更容易被回收，当连续打开几个apicloud应用页面后切到其他稍微重一点的APP操作一会儿，再切回apicloud，然后返回上一个页面会发现页面已经空白了，需要重新渲染；同样的手机同样的场景Dcloud应用不存在这个问题。第二是apicloud缺少页面预加载功能，Dcloud的示例应用中利用预加载做了列表到详细页最佳实践，有力证明了预加载的价值，而这个需求被提交给apicloud后，管理员的回复是</p><blockquote><p>“打开页面其实用不着进行预加载，正常的openWin打开然后加载已经足够了。”</p></blockquote><p>最终示例APP中只能勉强用frame模拟了详细页预加载，用frame模拟的缺点有两个，一是frame无法实现“推入”效果，只能“飞入”，因此可能与APP的全局页面切换效果相违背；第二点更致命，因为frame是依赖window的，也就是说不同的列表页无法共享预加载的详细页，即便同一个列表页只要退出了，下次进来也需要重新预加载详细页。</p><h3 id="曲线救国"><a href="#曲线救国" class="headerlink" title="曲线救国"></a>曲线救国</h3><p>刚开始接触混合应用时很喜欢搞一些看上去“很原生”的效果，比如划出菜单、滑动选项卡式列表之类的，后来发现实现是能实现，但结果太糟糕了，因为这些东西太重了，不是web能消费得起的，不要用web的弱点去死磕。</p><p>在整体的体验把控上我的看法是，只要功能实现了，有没有某个特效是第二位的，APP的流畅体验和赏心悦目永远是第一位的，尤其要避免任何反常的界面表现，比如web特有的布局抖动和界面先空白后闪现，都会给用户造成“不稳定”的心理暗示，这些问题稍微用点心其实都可以克服。比如frame第一次打开就会出现典型的闪动现象，这时候就需要做预加载，可以参考示例APP的首页第四个栏目，在做了预加载之后有效避免了闪动，而且可以秒开。</p><p>像侧滑菜单这种东西，多数情况都可以用一个从左往右打开的页面来代替，流畅性有保证，开发难度也低，不一定非得是侧滑到屏幕一半。</p><p>web开发的优势在于布局的灵活性，利用好这一点有时候能让原本不那么好的体验变得可以接受，比如给列表页实现占位元素，实现成本非常低，却能有效降低等待加载的焦虑感，可以参考示例APP的<em>列表到详细页</em>。</p><p>总结起来，从绝对性能上混合不可能比得过原生，混合能做的就是用各种手段提高用户的忍耐阈值，或者转移用户的注意力。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>文档正在撰写中，目前线上的文档版本仅供娱乐。</p><p>未经实际项目检验，渴望暴风雨猛烈抽打，感兴趣的<a href="https://github.com/tower1229/HybridStart" target="_blank" rel="external">戳此</a>Star。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/07/07/HybridStart%20v1.0%E5%BC%80%E5%8F%91%E7%BA%AA%E8%A6%81/#disqus_thread</comments>
    </item>
    
    <item>
      <title>混合应用框架优化思路梳理</title>
      <link>https://refined-x.com/2017/07/03/%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF%E6%A2%B3%E7%90%86/</link>
      <guid>https://refined-x.com/2017/07/03/%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF%E6%A2%B3%E7%90%86/</guid>
      <pubDate>Mon, 03 Jul 2017 13:01:16 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;前一阵攒了个&lt;a
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>前一阵攒了个<a href="//refined-x.com/HybridStart/docs/">HybridStart</a>，本来只是自己平时在混合应用项目中用用，后来发现不少前端同行也有这个需求，市面上的同类产品基本都是引擎厂家自己推出的，没办法作为通用框架，于是决定重新整理一下HybridStart，尝试把它做成一个更好用、更通用的混合应用开发框架。</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>框架定位于混合应用开发最佳实践。</p><p>代码层面由核心和UI两部分组成。核心提供一套固定的、足够简单的api，实现混合开发中必不可少的功能；UI由插件和前端组件组成，插件具有一定的通用性，可以适度结合核心功能，前端组件则应该保持独立性，必要时可随意替换。</p><p>开发体验上结合混合开发的特点做进一步优化，包括代码组织、文件组织和一些细节优化等。</p><h2 id="平台通用性"><a href="#平台通用性" class="headerlink" title="平台通用性"></a>平台通用性</h2><p>虽然框架当前版本底层基于APICloud，但各家引擎的核心功能应该是一致的，这些功能使基于web前端技术开发混合应用成为可能，通用框架只能建立在这些核心特性上，周边功能以插件、模板的形式提供，这样适度降低对引擎的依赖，使UI层面的大部分代码掌握在前端开发者手里，同时也可以降低更换引擎的成本。</p><p>单从APIcloud的插件库质量来看，原生插件的效果真心不一定好过web前端插件，所以不能迷信原生，原生只是理论上效果最好，到底好不好还得看开发者的能力。</p><p>更换引擎的需求也很有必要，长期来看Appcan/APICloud/Dcloud不可能一直共存，短期来看APICloud的api封装对比Dcloud有其不足之处，而且从我自己的角度，也很想在通用性上做一点尝试。</p><h2 id="UI可剥离"><a href="#UI可剥离" class="headerlink" title="UI可剥离"></a>UI可剥离</h2><p>前几天对比研究了一下Dcloud，从文档各方面看好像更专业，介绍的优化手段也很极致，但演示APP的体验并没有拉开差距，测试机型是红米4高配，已经是千元机了，可能在更低端的机型上有差距？没有进一步测试。不过Dcloud的路数确实跟APICloud不一样，api设计的更底层，确实像是个规范该有的样子，问题是操作起来很麻烦，估计他们也知道这个问题，所以推出mui，mui声称只做UI，但其实还有一个很大的作用是将常用操作集成进来了，也就是说对自家引擎做了易用性封装，这就使得剥离mui的成本变得很高，需要将底层api都重新封装一遍。</p><p>我对UI的理解就是一套前端组件，应该可以很容易的从功能上剥离出来，随意替换，否则就是对开发者的绑架。mui已经深度结合了Dloud，做不到单纯的剥离UI同时保留封装功能，对于不愿意使用或学习mui的开发者就不太友好，所以HybridStart要做的就是一个自由度更高的mui，功能该有的有，还可以换引擎，UI不想用可以整个拿掉，一切为了方便。</p><h2 id="只解决60-的需求"><a href="#只解决60-的需求" class="headerlink" title="只解决60%的需求"></a>只解决60%的需求</h2><p>应用场景是无穷无尽的，妄图覆盖到任何程度都是徒劳。这里的60%并不是严格意义上的大多数，而是结合经验对最常用需求的猜测，在核心功能封装上取最小集合，其他功能以插件或模板的形式体现，或者干脆留给开发者自己去做。</p><p>重要的不是做什么，而是不做什么。框架的开箱可用很重要，其中一个指标是冗余程度在接受范围内，否则有代码洁癖的开发者就得花时间去删改，这就违背了框架的初衷。</p><p>最后，可能无论如何尝试，结果也只是满足了一小部分人的需求，其他人看看就算了，因为所有的封装理论上都是定向的，不存在哪一个框架能适应各种场景，所以从设计之初就要摒弃这种虚妄，功能不求多，只求精。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>总体思路就是这样，具体工作正在展开，有更好的建议或想看看进度，参看<a href="https://github.com/tower1229/HybridStart/projects/1" target="_blank" rel="external">这里</a>。</p><p>附：最近跟APICloud的技术支持打交道比较多，体验真心不咋地。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/07/03/%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF%E6%A2%B3%E7%90%86/#disqus_thread</comments>
    </item>
    
    <item>
      <title>基于APICloud的混合应用开发框架</title>
      <link>https://refined-x.com/2017/06/26/%E5%9F%BA%E4%BA%8EAPICloud%E7%9A%84%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/</link>
      <guid>https://refined-x.com/2017/06/26/%E5%9F%BA%E4%BA%8EAPICloud%E7%9A%84%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/</guid>
      <pubDate>Mon, 26 Jun 2017 02:10:42 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;接上一篇对&lt;a
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>接上一篇对<a href="//refined-x.com/2017/06/23/2017%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%8E%B0%E7%8A%B6/">各种混合应用开发方案</a>的探讨，个人觉得现阶段最适合自己的还是以APICloud为代表的混合应用云平台，对于不懂原生开发的前端来说，其他方案的坑真的踩不起，为了让踩过的坑不再坑人，我将自己基于云平台的项目经验总结并封装到了一个混合应用开发框架中去，下面就聊聊这个框架<a href="//refined-x.com/HybridStart/">HybridStart</a>。</p><h2 id="为什么需要HybridStart"><a href="#为什么需要HybridStart" class="headerlink" title="为什么需要HybridStart"></a>为什么需要HybridStart</h2><h3 id="平台提供什么"><a href="#平台提供什么" class="headerlink" title="平台提供什么"></a>平台提供什么</h3><p>APICloud集成了包括窗口系统、应用管理、网络通信、数据存储、消息事件、设备访问、UI组件、多媒体等功能，这些功能不需要额外插件支持就可以直接调用，可以说是当之无愧的”开箱即用”，<a href="http://docs.APICloud.com/Client-API/api" target="_blank" rel="external">官方文档</a>对api的介绍还是非常细致的，第一次打开文档可能会觉得信息量太大，不知从何看起，这里我们就以<em>窗口系统</em>为例，介绍一下APICloud到底为我们提供了什么样的能力，以及为什么在实际项目中仍然需要对其做二次封装。</p><p>多<code>webview</code>是APICloud的核心，这意味着APP像网站一样，是由若干个独立页面组成的，APP的使用过程会依次打开多个页面，这些页面形成一个堆栈，最新打开的显示在顶层，曾经打开的堆在底下，通过返回、跳转、关闭等操作可以在页面堆栈中穿梭，这些操作能力就由窗口系统提供，他至少包括以下功能：</p><ul><li>打开/关闭页面</li><li>打开/关闭浮动窗口</li><li>跳转页面</li><li>跳转浮动窗口</li><li>跨页面执行脚本</li><li>本地存储</li><li>页面状态监听</li><li>全局事件发布/订阅</li></ul><p>这些功能足以满足窗口管理中的所有需求，有一些功能甚至非常强大，比如跨页面执行脚本，意味着你可以在A页面遥控B页面执行指定脚本；还有的功能可以直接操作堆栈，比如将指定页面/浮动窗口置顶/置底；还有非常实用的发布订阅机制，是一种有效的穿透页面隔阂的工具。</p><p>功能是够用了，但估计看完了你还是不会写代码。</p><h3 id="平台欠缺什么"><a href="#平台欠缺什么" class="headerlink" title="平台欠缺什么"></a>平台欠缺什么</h3><p>平台不缺功能，但我仍然有很多疑问，起码我在第一次接触到窗口系统时，心里就有很多疑问。</p><p>第一个疑问，什么是浮动窗口？浮动窗口产生的背景是，安卓机上只有<code>&lt;body&gt;</code>节点产生的滚动才具有流畅的原生弹动效果，<code>&lt;div&gt;</code>或其他标签产生的滚动则很生涩，那在APP上我们要做局部滚动怎么办呢，我们通过在当前<code>webview</code>上覆盖一个小点的<code>webview</code>，来实现平顺的局部滚动，非常像web开发中的<code>&lt;iframe&gt;</code>，这就是浮动窗口。浮动窗口与主窗口具有从属关系，浮动窗口不能调用关闭方法关闭自己的父窗口。细心的同学会问，那为什么不用<code>&lt;iframe&gt;</code>呢，因为有兼容问题。</p><p>第二个疑问，窗口之间怎么传参？主要有两种方式，第一种是打开窗口的方法本身支持传参，可以在新窗口通过指定api获取参数，然而这个官方方法并不是最佳方案，最大的缺点是需要等待原生功能就绪，就是说要在一个异步回调函数里才能取得参数，不够快；另一种方法是利用本地存储，在原页面存参数，打开新页面后取参数，本地存储是web能力，可以直接调用而不必等待原生功能就绪，所以效率更高；理论上还有第三第四种方法，比如用跨页面脚本执行去获取另一个页面中的变量，或者用事件监听机制让两个页面建立联系从而传参，不过这些就很奇葩了，需要说明一下理论上给url后面加<code>?a=b&amp;c=d</code>这种方式也是可以的，但在部分安卓系统上不兼容，因此不能用。</p><p>第三个疑问，多页面如何同步状态？多页面机制最大的问题就是状态被分散在每个页面中，需要手动同步状态，比如打开了N个页面后用户突然退出登录了，后台页面就需要更新到非登陆状态，这时就要用到全局事件的发布和订阅了；还有一个场景是列表数据的实时更新，可以通过监听列表页面的前后台状态，使页面每次回到前台时执行更新操作。还有一个”点对点”的做法是跨页面执行脚本，可以让任意页面执行任意操作，很强大但使用场景有限。可以看到，这些操作虽然都能实现，但都挺麻烦，而且好像没有哪个是标准实现，怎样都行。</p><p>第四个疑问，什么时候用<em>窗口</em>什么时候用<em>浮动窗口</em>？只要不是局部滚动页面都用<em>窗口</em>，有一种可能要用<em>浮动窗口</em>的情况是，希望在父窗口的框架下通过控制多个<em>浮动窗口</em>切换来更新局部内容，这个理论上可以，但需要量力而行，因为父子窗口的通信基本是靠跨页面脚本执行，交互多的话会很麻烦，而且<em>浮动窗口</em>的打开速度比想象的慢，开发中建议规避这种做法。</p><p>第五个疑问，一个APP包含很多个页面，代码怎么组织？这个问题和上一个问题其实都应该由官方来回答，然而官方的新手指南基本上没啥用，只能自己看开源代码，然而这些官方示例的代码组织可以说一团糟，不出意外你会在一个文件夹里看到一大堆html文件，每一个文件名由栏目名称、页面名称、页面类型组成，打开html会在底部发现script标签里面写着当前页面的js代码，唯一一点<em>有组织</em>的迹象，大概就是提取了公用css和公用js，弱爆了。</p><p>第六个疑问，怎么开始？给个套路？嗯，你只要通读文档，再踩上几个项目的坑，就全明白啦。</p><p>可以看到，APICloud对所有的问题都有答案，甚至对有的问题有不止一个答案，唯独缺乏一个清晰的梳理，新手上来免不了要踩坑，<a href="//refined-x.com/HybridStart/">HybridStart</a>的定位就是一个基于APICloud平台的混合应用开发脚手架，把可能出现的坑都填上。</p><h2 id="HybridStart提供什么"><a href="#HybridStart提供什么" class="headerlink" title="HybridStart提供什么"></a>HybridStart提供什么</h2><h3 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h3><p>如果是跟我一样之前从未接触过APP开发的前端，我认为首先需要知道的是，APP不同于web的地方是需要很多<em>初始化</em>操作，比如判断是否已登录、数据预取、检查更新、注册推送、注册全局监听等等，经过这个过程后APP才能打开第一个页面，进入页面的生命周期。</p><p>APICloud里有一个非常重要但官方没怎么强调的概念叫<em>根页面（root）</em>，就是APP启动后第一个打开的那个页面，这个页面非常特殊，相当于其他所有页面的父页面，它被关闭了意味着APP退出，他无法被其他页面调用关闭方法关闭，它是到达其他页面的必经之路。综合这些特征，这个页面非常适合用来做APP初始化，初始化完成后再立即切换到首页或者登录页，这时用户看到了第一个页面，但实际上是APP打开的第二个页面。</p><p>APP启动后root页就常驻后台，对于安卓机还需要在可能返回到root页的页面上做返回键拦截，提示退出APP而不允许返回到root，因为root是个只有js代码的空白页。那么混合应用的页面生命周期就应该是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root -&gt; index(exit) &lt;=&gt; page &lt;=&gt; page ...</span><br></pre></td></tr></table></figure><p>开发中我们第一个要实现的就是root页的初始化功能，比如检查登录状态，然后决定是跳转到登录页还是主页，然后再去实现登录页 or 主页。</p><p>APP的数据交互几乎全部依靠后端接口，因此很有必要事先约定一个交互格式，方便统一做异常处理。比如最简单的先把<code>json</code>的大结构定下来，起码状态、数据、提示信息字段都得有，对于列表数据还需要一个信息总数字段，这样下来一个基本的交互格式就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;Y&quot;,      //请求的状态 &quot;Y&quot;/&quot;N&quot;，也可以根据情况扩展其他</span><br><span class="line">    &quot;data&quot;: [&#123;...&#125;],    //请求的数据 数组或对象</span><br><span class="line">    &quot;msg&quot;: &quot;&quot;,          //【可选】服务端提示信息</span><br><span class="line">    &quot;count&quot;: [number]   //【可选】当获取列表数据时，需附加count数据指明列表总数，用于前端分页</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以封装一个数据请求方法，在方法里对某些情况做自动处理，比如当发现<code>status</code>不是”Y”的时候就自动提示<code>msg</code>字段的信息，就不用在每一个业务逻辑里写错误处理了。</p><h3 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h3><p>稍微复杂点的APP有个几十近百的页面很正常，所以APP代码组织首先要解决的是页面组织。</p><p>页面肯定得放在一起管理，但又不能直接罗列在一起，那就先建一个<code>view/</code>文件夹，然后按功能模块分二级文件夹，把会员相关页面都放进<code>member/</code>，商品页面都放进<code>product/</code>……；页面的脚本和样式也不希望内联，最好每个页面对应模板、样式、脚本三个文件，那就将他们三个也装进文件夹，以页面名称命名。这样页面文件就形成了<code>channel-page-pagefile</code>的结构，目录就变成了这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">view/</span><br><span class="line"> |--- member/               //会员栏目</span><br><span class="line"> |      |--- info/              //会员信息页</span><br><span class="line"> |      |        |--- temp.html</span><br><span class="line"> |      |        |--- style.css</span><br><span class="line"> |      |        `--- script.js</span><br><span class="line"> |      `--- set/               //会员设置页</span><br><span class="line"> |              |--- temp.html</span><br><span class="line"> |              |--- style.css</span><br><span class="line"> |              `--- script.js</span><br><span class="line"> |      </span><br><span class="line"> |--- home/                 //APP首页</span><br><span class="line"> |      |--- temp.html</span><br><span class="line"> |      |--- style.css</span><br><span class="line"> |      `--- script.js</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p>这样即使有再多的页面，找起来也有迹可循，不至于在文件堆里看花了眼，将页面样式和脚本拆分出来也是为了开发方便，因为页面代码一旦很长，上上下下的巴拉css和js也挺痛苦的，不如拆开干净利索，反正都是本地文件，几乎没什么加载问题，将页面用文件夹的形式管理还有一个好处，就是可以将页面的独有资源放在各自文件夹内管理，比如图片就不需要全部丢进公用文件夹了，将来打开一看一大堆图片，都分不清哪个有用哪个没用。</p><p>然后是脚本组织，APP开发需要写大量的js，组织js的目的就是层层过滤，将非业务代码过滤出去，使注意力可以更多的放在业务脚本的开发上。</p><p>首先我们肯定要将类库剥离出来，在类库和业务之间再划分出插件、服务、公用脚本。</p><p>公用脚本就是类似返回按钮的监听、图片点击的监听、兼容性处理等，每个页面都得引用它（除了root），可以把他们都抽到<code>common.js</code>里，方便统一修改；还有一些业务上常用的方法，比如格式化、查坐标等等，不是每个页面都能用到，但也很有必要集中在一起管理，暂且就叫他<code>server.js</code>；另外还有一些插件类的脚本，比如上传、表单验证，这种就分别封装成模块，一起放进<code>modules/</code>文件夹；最后是类库，也是框架的核心，我们称之为<code>core.js</code>，这里面放的是常用类库以及对引擎接口做二次封装，二次封装至少有三个好处，一是可以精简api，如果看过APICloud的文档感觉还好的话，建议去看一下Appcan的文档，那醉人的api设计，简直欲仙欲死；二是底层引擎的api假如更新了，不需要修改业务代码，只改<code>core.js</code>中对应的封装就好了；三是便于更换底层，实际上这个框架的雏形就是基于Appcan实现的，后来弃坑转到APICloud无非就是换了一套底层api，框架自身api没有大的改动。</p><p>最后剩下的就是散落在各个页面里的<code>script.js</code>了，那么最终的脚本组织是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|--- sdk/</span><br><span class="line">|       |--- modules/</span><br><span class="line">|       |      |--- upload.js</span><br><span class="line">|       |      |--- ...</span><br><span class="line">|       |--- core.js</span><br><span class="line">|       |--- server.js</span><br><span class="line">|       `--- common.js</span><br><span class="line">|--- view/</span><br><span class="line">|       |--- page/</span><br><span class="line">|       |       |--- script.js</span><br><span class="line">|       |--- ...</span><br></pre></td></tr></table></figure><p>css以及其他静态资源的组织就很简单了，没必要细讲，再上一个完整的目录结构吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|-- docs/                 //文档(不需要上传打包平台)</span><br><span class="line">|-- error/                //app错误页</span><br><span class="line">|-- res/                  //app静态资源(图片、模板等)</span><br><span class="line">|-- sdk/ </span><br><span class="line">|    |-- modules/             //插件模块</span><br><span class="line">|    |-- font/                //字体图标</span><br><span class="line">|    |-- core.js              //核心库</span><br><span class="line">|    |-- server.js            //业务方法</span><br><span class="line">|    |-- common.js            //页面公用代码</span><br><span class="line">|    `-- ui.css               //公共样式</span><br><span class="line">|-- view/                 //app页面</span><br><span class="line">|-- config.js             //框架配置</span><br><span class="line">`-- config.xml            //APICloud配置</span><br></pre></td></tr></table></figure></p><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><p>js分的这么零碎肯定离不开模块化，因此整个项目是基于<code>seajs</code>实现的模块化加载；DOM操作用的<code>jQuery 2.x</code>，很多人觉得做混合应用还上jQuery太low，我要说多<code>webview</code>模式让混合应用真的很像一个网站，DOM操作少不了，当然你大可换成<code>zepto</code>或自己封装几个方法去用，我觉得差别不见得有多大，都是本地资源差个几KB有区别吗；模板引擎用的<code>etpl</code>，这个很有用，大量的异步数据渲染，没有模板引擎不行。</p><p>类库都是直接将压缩后的代码放进<code>core.js</code>顶部，理论上可以随意增删改，但上述三个类库在其后的<code>app</code>对象实现中也有应用，因此不能直接删掉。除这三个以外的类库如果不需要可以删，比如<code>xss.js</code>，一个防御跨站脚本攻击的库。</p><h2 id="HybridStart的意义"><a href="#HybridStart的意义" class="headerlink" title="HybridStart的意义"></a>HybridStart的意义</h2><h3 id="目的及原则"><a href="#目的及原则" class="headerlink" title="目的及原则"></a>目的及原则</h3><p>我有一点代码洁癖，体现在我不喜欢任何二次封装的东西，我希望<strong>通过最短的路径去触及功能实现的关键</strong>，所以抱着这样的目的，最开始我连官方的<code>js SDK</code>也不用，直接调用引擎api开发业务，我认为这是最快、性能最高的方式。</p><p>然而事实是，<strong>引擎提供的api效率真心不高，而且可靠性堪忧</strong>，当年用Appcan开发第一个项目的时候，简直难受的想死，bug多到”举步维艰”你能想象吗，转到APICloud后虽然没有这么多明显的bug了，但部分api偶发性失灵还是有的，这种问题基本就没办法了，后来看了一些对混合应用实现原理的介绍才知道，这玩意本来就是个hack，反射弧就是比较长，体验上”不利索”啊，偶发性的失灵啊，也就可以理解了，其实难怪，要真能像调用原生一样快那还要原生干什么。</p><p>所以后来我改变了思路，不能再面向引擎编程了，因为你不知道一个api背后是怎样实现的，就不知道这个api的真实使用成本，所以我开始接受二次封装，并且原则上<strong>尽量少的使用引擎能力</strong>。</p><p>一开始是修改官方的<code>js SDK</code>，将无用的功能删掉，将需要的功能加上，改着改着发现这个<code>js SDK</code>跟我的需求差别太大，干脆就重写了一个，该有的有，该扩的扩，用起来很爽。随着开发的深入，越来越发现其实利用有限的几个api就可以实现绝大多数需求，如果仔细研究引擎的api，会发现真有些功能是非必需的，或者说是语法糖，怎么说呢，感觉就是api”设计的不优雅”。甚至有的功能实现还不如js模拟来的效果好，背后的开发质量可见一斑。</p><p>在这样的目的和原则下，引擎api被二次封装进了<code>app</code>对象，除了常用核心方法被直接挂载在<code>app</code>上之外，还包括了<code>app.crypto</code>、<code>app.ls</code>、<code>app.window</code>、<code>app.ajax</code>几个模块。</p><h3 id="app-openView"><a href="#app-openView" class="headerlink" title="app.openView"></a>app.openView</h3><p><code>app</code>对象里封装了所有混合应用开发需要的功能，但是很多琐碎的功能实现都尽量的被隐藏起来了，可能开发中只需要修改一个配置就能使用，目的就是为了简化开发。这里我们就说一下<code>app.openView()</code>这个方法，这个方法用来打开一个页面，可以说是开发中最常用的方法，借此也让大家对<a href="//refined-x.com/HybridStart/">HybridStart</a>到底做了什么有一个感性的认识。</p><p>首先我们看引擎本来提供的api是什么样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">api.openWin(&#123;</span><br><span class="line">    name: &apos;page1&apos;,          //为窗口命名，方便调用关闭方法将其关闭</span><br><span class="line">    url: &apos;./page1.html&apos;,    //页面路径</span><br><span class="line">    pageParam: &#123;            //参数</span><br><span class="line">        name: &apos;test&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    animation: &apos;push&apos;,      //动画效果</span><br><span class="line">    subType: &apos;form_right&apos;   //动画方向</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个方法的配置项还有很多，列出来的是开发中最常用到的几个，即便只是这几个配置每次写也已经够罗嗦了，<code>app.openView()</code>可以说就是对这个api 的封装，希望通过各种方式在不牺牲功能的前提下简化配置，那我们就从这几个配置入手，挨个来看怎么简化。</p><p><code>name</code>属性用来为一个窗口命名，这个名称将来可以用于调用某些方法对其进行操作。我们要省掉这个配置就只能自动生成，但这个名称日后还有用，所以不能随机生成，必须有一定的规律，这里可以结合页面组织来解决，按照我们前面讲的规则组织后页面分为两种，一级页面<code>&quot;/view/channel/temp.html&quot;</code>和二级页面<code>&quot;/view/channel/page/temp.html&quot;</code>，规律还是很明显的，只要提供页面所属的<code>channel</code>名称以及如果是二级页面的话再加上<code>page</code>名称，就可以定位到这个页面，并且通过<code>channel + &quot;_&quot; + page</code>来得到一个唯一的<code>name</code>值。那我们就先假定openView方法需要<code>channel</code>和<code>page</code>两个参数，<code>page</code>是可选的，调用时将是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.openView(&apos;home&apos;);           //url: &quot;/view/home/temp.html&quot;, name: &quot;home&quot;</span><br><span class="line"></span><br><span class="line">app.openView(&apos;member&apos;,&apos;set&apos;);   //url: &quot;/view/member/set/temp.html&quot;, name: &quot;member_set&quot;</span><br></pre></td></tr></table></figure><p>还不错，<code>name</code>和<code>url</code>都解决了，属性<code>pageParam</code>的处理相对复杂，我们放在后面说，先来看<code>animation</code>和<code>subType</code>。</p><p>这两个属性是最应该被封装掉的，页面切换的动画类型肯定要集中到一个全局配置中管理，调用时<code>animation</code>可以省掉；动画方向配置基本上就是个伪需求，打开自然就是右推，关闭自然就是左推，分别封装进打开和关闭页面方法里就好了，<code>subType</code>也可以省掉。</p><p>现在来看<code>pageParam</code>，用来给页面传参，参数格式是<code>Object</code>。好，这个需求必须有，我们要让<code>app.openView()</code>支持传参，语法将变成这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.openView(param[Object], channel[String], page[String]);</span><br></pre></td></tr></table></figure><p>因为<code>page</code>是可选的，放在最后便于实现，因此将<code>param</code>参数放到前面。好像看上去也还行，但肯定还会有其他配置，不能一再的往上加参数吧，怎么办。</p><p>这里有一条经验，页面传参多数发生在从列表页打开详细页的时候，这时我们传的参数是一个<code>id</code>，也就是一个字符串，实际上绝大多数情况下的页面传参都只是一个字符串，需要<code>Object</code>的情况不多，基于这个前提，我们将<code>param</code>参数扩展一下，既可以接受字符串也可以接受对象，当接受字符串时将该值作为参数传递给新页面，当是对象时允许该对象包含对openView方法的所有配置，当然其中也包括了页面参数，说起来有点绕，看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.openView(&apos;newsID&apos;, &apos;news&apos;, &apos;detail&apos;);           //实际开发中最常用的字符串传参</span><br><span class="line"></span><br><span class="line">app.openView(null, &apos;home&apos;);                         //如果不需要传参，抱歉必须传一个null/undefined占位</span><br><span class="line"></span><br><span class="line">app.openView(&#123;                                      //Object类型的参数得这么传</span><br><span class="line">    param: Object</span><br><span class="line">&#125;, &apos;home&apos;);  </span><br><span class="line"></span><br><span class="line">app.openView(&#123;                                      //这里还可以配置openView方法的其他参数</span><br><span class="line">    duration: 350</span><br><span class="line">&#125;, &apos;home&apos;);</span><br></pre></td></tr></table></figure><p>这样所有的问题都解决了，但有一个小瑕疵，就是没有参数必须传<code>null/undefined</code>占位，因为<code>page</code>参数已经是可省的了，<code>param</code>参数实在没办法再做判断，不过这个<code>null/undefined</code>传的也不是一点意义没有，这里又得说来话长了。</p><p>前面说过给页面传参有两种方法，一种是通过api提供的<code>pageParam</code>，另一种是通过<code>localStorage</code>跨页面存取值，<code>pageParam</code>的问题是新页面取值比较慢，取值代码可能是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//原生功能就绪回调</span><br><span class="line">app.ready(function()&#123;</span><br><span class="line">    var pageParam = api.pageParam; </span><br><span class="line">    //基于pageParam的后续操作，比如页面渲染、表单验证，事件绑定</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>app.ready()</code>是框架封装的原生功能就绪回调，这是一个异步回调，通常，为了提高脚本响应速度我们会把不需要原生能力的操作放在<code>app.ready()</code>之外，使其同步执行，问题在于，如果基于页面参数的后续操作恰好是不需要原生能力的，但为了等待取参数，也必须被放进<code>app.ready()</code>内执行，这就很不爽了。</p><p>所以框架提倡的传参方式是用<code>localStorage</code>，在新页面可以同步取值，这种方式唯一的问题是可能造成资源浪费，各种参数放进本地，怎么清理？我的方法是约定一个专门用来传参的键<code>crossParam</code>，每次传参都写进这里，反复擦写最终留下的只是最后一次的参数值，<code>app.openView()</code>已经对此做了封装，参数将自动存进<code>localStorage.crossParam</code>，参数如果是对象类型将做<code>JSON.stringfiy()</code>处理，因此如果传的是对象，取值后需要自己做<code>JSON.parse()处理</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//同步取得页面参数</span><br><span class="line">var param = app.ls(&apos;crossParam&apos;);       </span><br><span class="line">//执行不需要原生能力的操作</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">app.ready(function()&#123;</span><br><span class="line">    //执行需要原生能力的操作</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>回到<code>app.openView()</code>方法第一个参数必须占位的问题，他的意义在于，当<code>app.openView()</code>检测到<code>null/undefined</code>时会将本地存储中的<code>crossParam</code>键删掉，将造成浪费的可能性降至最低。</p><p>当然，官方的<code>pageParam</code>方式也没有废弃，如果传递的参数是对象的话，<code>pageParam</code>和<code>localStorage</code>两种方式都生效，通过<code>api.pageParam</code> 的方式也可以取到值。</p><p>经过这些封装，打开页面的语法已经非常简单了，但<code>app.openView()</code>还有很多其他功能，比如以弹窗形式打开页面、以带标题栏的形式打开页面、打开新页面同时关闭当前页面、或者打开一个网页，这些功能的实现都相对复杂，就不一一展开了，这里只着重介绍封装思路，如果有兴趣可以去<a href="//refined-x.com/HybridStart/docs/">HybridStart 文档</a>看一看。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>吹了半天，还得回到选型上来，我并不觉得多数项目适合这种方案，我甚至觉得只有少数项目，或者只有项目的起步时期，可以用这种方案快速上马快速迭代，我理想中的混合应用形态是原生为主web为辅的，但从一个前端的角度看，我并没有发现更好的可行性方案，有人可能会说<code>React Native</code>，但那个东西还是需要原生开发基础的好吗，而且如果APICloud在UI组件方面再进一步，貌似也可以接近<code>React Native</code>的效果。</p><p>总之，如果你觉得自己的项目正好适合这个方案的话，这个框架可能对你有帮助。</p><p>源码： <a href="https://github.com/tower1229/HybridStart" target="_blank" rel="external">Github</a></p><p>框架本身就是一个演示APP，自带部分功能的演示页面，将代码同步到你的项目就可以编译下载了，如果这个项目对你有帮助的话，请去Github尽情的Star不要客气。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/06/26/%E5%9F%BA%E4%BA%8EAPICloud%E7%9A%84%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2017混合应用开发现状</title>
      <link>https://refined-x.com/2017/06/23/2017%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%8E%B0%E7%8A%B6/</link>
      <guid>https://refined-x.com/2017/06/23/2017%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%8E%B0%E7%8A%B6/</guid>
      <pubDate>Fri, 23 Jun 2017 03:10:09 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;混合应用的概念是相对于原生应用而来的，也就是部分采用了web前端技术所开发的应用，曾经的&lt;em&gt;混原之争&lt;/em&gt;也是相当热闹了一阵，如今已经尘埃落定，他们的各种利弊都经过了充分的讨论和验证，相信大部分开发者都已经清楚自己需要的是什么了，那么2017年的今天，混合应用开发到
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>混合应用的概念是相对于原生应用而来的，也就是部分采用了web前端技术所开发的应用，曾经的<em>混原之争</em>也是相当热闹了一阵，如今已经尘埃落定，他们的各种利弊都经过了充分的讨论和验证，相信大部分开发者都已经清楚自己需要的是什么了，那么2017年的今天，混合应用开发到底是怎样一个状况呢？</p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="破”壳”而出"><a href="#破”壳”而出" class="headerlink" title="破”壳”而出"></a>破”壳”而出</h3><p>一切都得有个源头。</p><p>前端同学应该还记得曾经大名鼎鼎的<code>phonegap</code>，当年的<code>phonegap</code>对前端圈的影响力不亚于今天的<code>nodejs</code>，因为他们都做了同一件事：拓展前端的开发能力。<code>phonegap</code>后来有了一个叫<code>cordova</code>的分支，其实都是一个东西，它能让一名前端开发者，在几乎不需要额外技术的情况下开发APP，而且跨平台！</p><p>要知道，对于处在程序员鄙视链底端的前端工程师来说，对新技能的渴求可以用嗷嗷待哺来形容，这种不自信的影响是深远的，直到今天仍然随处可见，但至少有一个影响是正面的，那就是全行业广泛的、时刻保有的、旺盛的好奇心，这使<code>phonegap/cordova</code>这种拥有恰当题材和恰当质量的项目，能够迅速积累起足够体量的第一批用户，后面就如你所知道的那样，铺天盖地的上手体验、技术讨论、野教程迅速填满了大部分的前端技术博客，让后来人想学不会都难。</p><h3 id="混合应用的本质"><a href="#混合应用的本质" class="headerlink" title="混合应用的本质"></a>混合应用的本质</h3><p>混合应用的本质是一个原生的”壳”里跑着web的芯，通常这个”壳”有两方面作用，一是提供跑web页面的<code>webview</code>，二是充当一个桥梁，将操作系统的原生功能嫁接给<code>webview</code>里的js调用，这样，就可以用web的方式去开发APP，效率和能力兼得。<code>phonegap/cordova</code>是一个存粹的”壳”，除了一个<code>webview</code>之外只提供少数几样原生功能，这样开发出来的混合应用更像是一个<code>Web APP Plus</code>，但混合应用不限于这一种形式，哪怕一个APP大部分都是原生，只有一个页面是web的，理论上这也算混合应用。</p><h3 id="速度为王"><a href="#速度为王" class="headerlink" title="速度为王"></a>速度为王</h3><p>快速开发快速迭代是做产品的永恒追求，新产品验证需求需要快，成熟产品甩掉竞争对手也需要快。</p><p>混合开发模式最突出的优点就是开发速度快，比起原生开发，本来web开发速度就很快，再加上一次开发多端发布，那就不是一般的快，而是快上加快，省下一个人的同时，开发进度还能提前，何乐而不为。</p><p>当然，”省下一个人”这个说法并不准确，实际上除了少数简单项目，多数情况的APP项目即使采用混合开发模式，也不能完全摆脱掉原生开发，因为通用”壳”的功能是有限的，很多时候还是需要针对”壳”做原生开发。</p><p>成也速度，败也速度。混合应用最为人诟病的缺点就是运行”慢”，受限于前端语言表现力和<code>webview</code>的能力，混合应用在精致和流畅方面恐怕永远也达不到原生水准，复杂动画的实现往往只能停留在理论层面，另外嫁接过来的功能肯定不如直接调api来的效率高，这些问题积累起来，导致混合应用整体”慢”的印象。</p><p>现实世界中原生同学的抵制也算是混合应用的一大缺点吧，这里就不展开了，默哀一分钟。</p><h2 id="混合应用的现状"><a href="#混合应用的现状" class="headerlink" title="混合应用的现状"></a>混合应用的现状</h2><h3 id="机遇与挑战"><a href="#机遇与挑战" class="headerlink" title="机遇与挑战"></a>机遇与挑战</h3><p>如今很多大厂APP也都是混合应用了，毕竟不是所有项目都需要那么极致的效果，尤其偏”内容类”的项目，如果没有大的技术变革，混合模式将是这类APP开发的首选。</p><p>针对混合应用”慢”的问题，目前最有效的方法是通过自定义”壳”，将重要的部分用原生实现，其他部分用web实现，从而灵活的避免web性能短板，总有一个混合程度是你的项目能接受的。</p><p>自制”壳”说起来简单，运行一个webview，为js和系统做嫁接，顺便还可以做做静态资源缓存之类的功能，甚至可以针对不同平台区别对待，但实际开发下来，需求点还是挺多的，这样一来各平台的原生开发成本就都回来了，而且如果遇到经常改需求的试水项目，一旦需求改到了原生头上，那混合的意义就不大了。</p><p>混合应用还有一个<em>业界难题</em>就是页面转场动画，<code>css3</code>不是不能实现动画，无奈的是不同配置的机器跑起来的差别太大，低端安卓机下的效果令人泪奔，完全无法用于商业项目，这个问题目前只能在”壳”的层面解决，可以为每个页面跑一个<code>webview</code>，页面切换即<code>webview</code>切换，这样就可以实现原生的转场效果了，这个思路已经在<code>Appcan/APICloud</code>这些产品上实现了。</p><h3 id="“壳”的演进"><a href="#“壳”的演进" class="headerlink" title="“壳”的演进"></a>“壳”的演进</h3><p>总结起来，开发一个混合应用目前有三种”壳”可以选。</p><p>一是<code>phonegap/cordova</code>，已经更新到<code>7.x</code>版本了，但只对兼容平台做调整，核心插件始终是那几样，铁了心只做底层。这个方案我个人不太看好，在一个<code>webview</code>里跑整个web应用，基本上就只能定位在玩具级了，长远来看性能问题没有解决的希望，因为操作系统没有动力去为<code>webview</code>做更多优化，人家图什么？</p><p>二是自己开发原生外壳，功能要啥有啥，从结果上来说是最佳方案，就是整体开发效率不高，适合成熟的团队，做成熟的项目，个人认为绝大多数项目到了后期应该都是奔着这个方向去的。</p><p>第三种就是<code>Appcan/APICloud</code>之流，可以说介于前两者之间，既是通用框架，功能又比<code>phonegap/cordova</code>多，一定程度上解决了转场问题，还集成推送、更新、诊断之类的常用功能，一般的项目基本就不需要原生介入了，目的就是一个，把开发一个各方面都还差不多的APP的成本降下来。</p><h3 id="云开发平台"><a href="#云开发平台" class="headerlink" title="云开发平台"></a>云开发平台</h3><p>着重说一下<code>Appcan/APICloud</code>这类云平台，他们最初能吸引到用户最大的噱头是多<code>webview</code>机制，一举解决了混合应用页面转场性能问题，再针对多<code>webview</code>机制推出一整套完善的api，满足开发中的大多数基础需求，使基于平台的开发可以做到”开箱可用”，加上本土化的官方插件生态，基本上常见需求都可以在没有原生开发介入的情况下实现，这对很多小团队或者说试水项目还是很有吸引力的。</p><p>之所以叫云平台，是因为他们的所有服务都在云端，包括最核心的应用引擎也就是原生外壳，我们得上传web代码然后在云端编译，然后下载APP安装包。这种模式就很敏感了，首先开发者会感觉不安全，因为我们的代码不可避免的暴露了；然后引擎不在自己手里，引擎的开发和维护就只能完全依靠平台，当遇到bug或特殊需求时，开发者除了求助就只能摊手坐等，开发进度在一定程度上是失控的。这些问题可以通过购买他们的企业服务解决，企业用户可以部署本地打包，也将得到更好的技术支持。<code>Appcan/APICloud</code>这两个平台我都深度使用过，其中Appcan就是个纯坑，bug多到令人发指，拜其所赐，”开发进度失控”的情况真的发生过，那个项目结束后果断转到APICloud，几个项目体验下来基本没bug，不过除此以外，他们在功能和服务上也就没啥区别了。</p><p>如果对云平台这种模式不是特别敏感的话，就很有可能成为他们的目标用户，因为这种模式还是颇有一些优点的，从APP的名称、图片、证书等各种设置开始，到代码管理、调试机制、插件生态、云端打包、版本管理，整个开发周期里能用到的功能一应俱全，概括起来至少有以下几个优点：</p><ol><li>多webView + 原生动画转场，提升页面切换流畅度；</li><li>多webView可以取代前端路由，降低开发门槛；</li><li>官方提供插件和第三方扩展，进一步降低开发门槛；</li><li>官方定制IDE集成调试、预览、同步等功能，开发体验非常好。</li></ol><p>为了让一名前端就能搞定APP开发，他们真做了不少工作，可以说是一种颇具性价比的混合应用开发方案。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>介绍了目前几种混合应用开发方案后，不得不说这就是个理想与现实的较量，势单力薄的我只好选择了云平台方案，但即便平台做的再好，仍然有很多问题需要自己解决，近期将更新一个姊妹篇，讲讲基于云平台的混合应用开发框架<a href="https://github.com/tower1229/HybridStart" target="_blank" rel="external">HybridStart</a>。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/06/23/2017%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%8E%B0%E7%8A%B6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>再做一条贪吃蛇</title>
      <link>https://refined-x.com/2017/06/19/%E5%86%8D%E5%81%9A%E4%B8%80%E6%9D%A1%E8%B4%AA%E5%90%83%E8%9B%87/</link>
      <guid>https://refined-x.com/2017/06/19/%E5%86%8D%E5%81%9A%E4%B8%80%E6%9D%A1%E8%B4%AA%E5%90%83%E8%9B%87/</guid>
      <pubDate>Mon, 19 Jun 2017 03:21:17 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;贪吃蛇，呵呵。&lt;/p&gt;
&lt;p&gt;在开发难度上，贪吃蛇算得上是游戏界的耻辱了，这么简单的东西，我知道你们是拒绝继续往下看的，但是，我这条贪吃蛇不一样，我这条贪吃蛇，更简单。。。&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>贪吃蛇，呵呵。</p><p>在开发难度上，贪吃蛇算得上是游戏界的耻辱了，这么简单的东西，我知道你们是拒绝继续往下看的，但是，我这条贪吃蛇不一样，我这条贪吃蛇，更简单。。。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这还要从一次午休说起，本来睡得迷迷糊糊突然想到一个问题，怎么优化贪吃蛇运动过程中涉及的大量DOM操作？用js做贪吃蛇游戏，思路无非是画蛇、运动、碰撞检测，蛇通常是由多个连续正方形元素组成的，蛇的运动通常做法是遍历元素，将蛇头向移动方向移一位，其后的元素挨个前移，也就是组成蛇身的每一个正方形元素都要移动位置，感觉很浪费。</p><p>我的方法是，将蛇尾元素直接移到蛇头即将移动的方向上充当蛇头，身体其余节点不需要动，这样也能实现贪吃蛇的移动效果，而且只要一次DOM操作。为了验证这个方法，于是我补齐了贪吃蛇游戏的其他部分，也就是地图、食物、碰撞检测、关卡设计。</p><p>先看效果：</p><p><img src="https://github.com/tower1229/tower1229.github.io/raw/master/asset/snake.png" alt="snake"></p><p>下面简单说一下。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="地图"><a href="#地图" class="headerlink" title="地图"></a>地图</h3><p>贪吃蛇的所谓地图看上去其实就是一堆网格线，这里面至少包含两个信息，第一单元格尺寸，第二游戏区域尺寸，设置好这两个尺寸，循环填充横线和竖线就可以了。</p><h3 id="食物"><a href="#食物" class="headerlink" title="食物"></a>食物</h3><p>贪吃蛇里的食物是随机生成位置的，总量保持一定，吃一个生成一个，这个总量通常可以根据游戏区域的大小按比例取得，比如<code>边长 * 0.5</code>，另外生成的食物不能与蛇身重叠，需要注意检测随机生成位置的可用性。</p><h3 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h3><p>运动环节的思路前面说过了，在运动进行之前，要先做碰撞检测，这是驱动游戏进行的关键步骤。</p><p>贪吃蛇的碰撞检测区分三种情况，分别是边界碰撞、自身碰撞、吃到食物。其中前两种会导致游戏结束，最后一种会得分，并且每吃一个食物蛇就会变长一个单元长度。</p><h3 id="关卡设计"><a href="#关卡设计" class="headerlink" title="关卡设计"></a>关卡设计</h3><p>为提升挑战性，一般要给游戏设计关卡，在这个游戏中的关卡只跟刷新率有关，每得到<code>10</code>分就会进入下一关，同时游戏的刷新时间缩短为上一关的<code>80%</code>，游戏速度就会加快，也就会越来越难玩。实际上，对于贪吃蛇这个游戏来说，就算没有关卡游戏的难度也会随着蛇身变长而越来越难，因为在一个既定范围内越长就容易撞到自己，只不过这个变难的速度太慢了。</p><p>对了，说到这儿想起还有一个临界点没做判断，那就是假如遇到一个超高手，把游戏玩到地图上刚好能容不下蛇身和剩余食物的时候，生成食物随机位置的程序会发现生成的随机位置不可用，从而一直试图生成新的可用位置，于是进入了死循环，这是一个美好的坑，我赌能跳进去的人，想必是不会玩这个游戏的。。。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>演示：<a href="//refined-x.com/projects/codes/snake.html">snake</a><br>源码：<a href="https://github.com/tower1229/tower1229.github.io/blob/master/projects/codes/snake.html" target="_blank" rel="external">Github</a></p><p>UI部分借助<a href="//refined-x.com/Flow-UI/docs/">Flow-UI</a>实现</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/06/19/%E5%86%8D%E5%81%9A%E4%B8%80%E6%9D%A1%E8%B4%AA%E5%90%83%E8%9B%87/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
