<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>前端路上</title>
    <link>https://refined-x.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>原创前端技术博客，致力于分享前端学习路上的第一手资料，专注web开发、移动端开发、混合应用开发、前端自动化、前端工程化，Nodejs开发。</description>
    <pubDate>Tue, 04 Dec 2018 10:58:23 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Vue CLI 3 浏览器兼容性配置</title>
      <link>https://refined-x.com/2018/12/04/VueCLI3%20%E5%85%BC%E5%AE%B9%E6%80%A7%E9%85%8D%E7%BD%AE/</link>
      <guid>https://refined-x.com/2018/12/04/VueCLI3%20%E5%85%BC%E5%AE%B9%E6%80%A7%E9%85%8D%E7%BD%AE/</guid>
      <pubDate>Tue, 04 Dec 2018 10:16:17 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;开发代码兼容&quot;&gt;&lt;a href=&quot;#开发代码兼容&quot; class=&quot;headerlink&quot; title=&quot;开发代码兼容&quot;&gt;&lt;/a&gt;开发代码兼容&lt;/h2&gt;&lt;p&gt;Vue CLI
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="开发代码兼容"><a href="#开发代码兼容" class="headerlink" title="开发代码兼容"></a>开发代码兼容</h2><p>Vue CLI 3初始化的项目，构建时会根据<code>package.json</code>中的<code>browserslist</code>配置自动检测需要转译的语言特性，为构建代码转译JavaScript 并为 CSS 添加浏览器前缀，通常只需要修改<code>browserslist</code>即可兼容目标浏览器，例如兼容IE10可以做如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;browserslist&quot;: [</span><br><span class="line">    &quot;ie 10&quot;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h2 id="依赖包兼容"><a href="#依赖包兼容" class="headerlink" title="依赖包兼容"></a>依赖包兼容</h2><p>但该特性仅对源码(src/)有效，对依赖包无效，当依赖包需要做兼容性转译时，有三种选择：</p><ol><li>如果确切知道有兼容性问题的依赖包名，可以配置项目根目录下的<code>vue.config.js</code>（默认不存在），将依赖包名添加到<code>transpileDependencies</code>键中，这会为该依赖同时开启语法语法转换和根据使用情况检测 polyfill。例如：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    transpileDependencies: [&quot;vue-plugin-load-script&quot;]       // 需要编译的依赖包名</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果确切的知道需要转译的语言特性，可以配置根目录下的<code>babel.config.js</code>，为<code>presets</code>的值添加所需要的 polyfill，例如：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [&apos;@vue/app&apos;, &#123;</span><br><span class="line">      polyfills: [</span><br><span class="line">        &apos;es6.symbol&apos;</span><br><span class="line">      ]</span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>然而更多的情况是，我们并不确切的知道项目中引发兼容问题的具体原因，这时还可以配置为根据兼容目标导入所有 polyfill，需要设置<code>babel.config.js</code>为：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [&apos;@vue/app&apos;, &#123;</span><br><span class="line">        useBuiltIns: &apos;entry&apos;</span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时在入口文件（main.js）第一行添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &apos;@babel/polyfill&apos;</span><br></pre></td></tr></table></figure><p>这种方式可能导入代码中不需要的polyfill，从而使打包体积更大。</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul><li>IE10中的node节点列表不支持<code>forEach</code>方法</li><li>IE10中background的参数中如果包括background-size参数，则background-size必须跟在background-position后面，且加上/前缀，例如：<code>background:url(./img/b.jpg) center /cover no-repeat;</code></li></ul>]]></content:encoded>
      
      <comments>https://refined-x.com/2018/12/04/VueCLI3%20%E5%85%BC%E5%AE%B9%E6%80%A7%E9%85%8D%E7%BD%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HTML5实现文件读取、编辑、保存</title>
      <link>https://refined-x.com/2018/09/03/HTML5%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E3%80%81%E7%BC%96%E8%BE%91%E3%80%81%E4%BF%9D%E5%AD%98/</link>
      <guid>https://refined-x.com/2018/09/03/HTML5%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E3%80%81%E7%BC%96%E8%BE%91%E3%80%81%E4%BF%9D%E5%AD%98/</guid>
      <pubDate>Mon, 03 Sep 2018 04:49:28 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;最近自己捣鼓了一个好玩的项目&lt;a href=&quot;https://github.com/tracesr&quot; target=&quot;_blank&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>最近自己捣鼓了一个好玩的项目<a href="https://github.com/tracesr" target="_blank" rel="external">觅迹导航</a>，核心功能已经开发完成，后续会抽时间完善一下细节，并开放使用。做这个项目的过程中涉及到本地文件的读写，而且项目的定位不涉及兼容性问题，所以就直接用HTML5实现了，这里将实现过程以及涉及到的知识点整理一下。</p><h2 id="HTML5读取文件"><a href="#HTML5读取文件" class="headerlink" title="HTML5读取文件"></a>HTML5读取文件</h2><p>HTML5读取文件主要利用的就是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader" target="_blank" rel="external">FileReader</a>这个API，它的使用需要从一个构造函数开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reader = new FileReader();      // 返回一个FileReader实例</span><br></pre></td></tr></table></figure><p>返回的实例具有以下3个属性：</p><ul><li>FileReader.result</li><li>FileReader.readyState</li><li>FileReader.error</li></ul><p>其中result属性是文件读取成功后的读取结果，数据的格式取决于使用哪个方法来启动读取操作。</p><p>FileReader实例具有以下4个方法：</p><ul><li>FileReader.readAsText()</li><li>FileReader.readAsDataURL()</li><li>FileReader.readAsArrayBuffer()</li><li>FileReader.abort()</li></ul><p>前3个方法分别是以文本、图片、其他格式读取内容，读取的对象可以是<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="external">Bolb</a>或<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File" target="_blank" rel="external">File</a>，在读取本地文件的场景下，我们读取的实际上就是File。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reader.readAsText(file);    //读取文本文件</span><br></pre></td></tr></table></figure><p>FileReader.abort()方法不需要说了，就是中断文件读取。</p><p>同时FileReader实例具有以下6个事件：</p><ul><li>FileReader.onprogress</li><li>FileReader.onloadend</li><li>FileReader.onloadstart</li><li>FileReader.onload</li><li>FileReader.onerror</li><li>FileReader.onabort</li></ul><p>其中onload事件是我们最关心的一个，该事件将在读取操作完成时触发，在这个事件中我们才能访问到FileReader.result属性，得到读取结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reader.onload = function() &#123;</span><br><span class="line">    console.log(this.result);       //文本内容</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用FileReader读取文件的整个流程就是这样，File对象我们可以通过<code>&lt;input type=&quot;file&quot; &gt;</code>获取。</p><h2 id="HTML5保存文件"><a href="#HTML5保存文件" class="headerlink" title="HTML5保存文件"></a>HTML5保存文件</h2><p>保存文件的关键是生成文件对象，可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURL" target="_blank" rel="external">URL.createObjectURL()</a>方法实现，该方法能返回给定对象的URL，用在<code>&lt;a&gt;</code>标签的<code>href</code>属性上就可以创建可下载的文件链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let DownloadDom = document.getElementById(&quot;Download&quot;);      // a标签</span><br><span class="line">DownloadDom.href = window.URL.createObjectURL(myBlob);      // 生成下载链接</span><br></pre></td></tr></table></figure><p>createObjectURL()方法的参数可以是File对象或者Blob对象，前端保存文件通常是希望将已有“内容”保存成文件，这种场景我们需要的是Blob对象。</p><p>Blob构造函数可以根据传入的数组数据返回Blob对象，数组可以是ArrayBuffer、ArrayBufferView、Blob、DOMString，假如我们希望将一段JSON字符串保存成JSON文件，那么可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let myBlob = new Blob([&apos;&#123;&quot;hello&quot;:&quot;world&quot;&#125;&apos;], &#123; type: &quot;application/json&quot; &#125;);     //Blob对象</span><br></pre></td></tr></table></figure><p>关于Blob构造函数的详细用法可以从<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/Blob" target="_blank" rel="external">这里</a>了解。</p><p>有了createObjectURL和Blob，实际上，我们就可以封装一个方法，将任意字符串保存成文件，并点击链接下载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let saveFile = function(fileText) &#123;</span><br><span class="line">    let DownloadDom = document.getElementById(&quot;Download&quot;);</span><br><span class="line">    if (this.DownloadDom) &#123;</span><br><span class="line">        let myBlob = new Blob([fileText], &#123; type: &quot;application/json&quot; &#125;);</span><br><span class="line">        this.DownloadDom.href = window.URL.createObjectURL(myBlob);</span><br><span class="line">        console.log(&apos;下载文件已就绪&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>结合HTML5读取文本文件功能，我们还可以实现对文本文件的编辑功能，比如JSON文件压缩，实际上就是拿到文本内容后，对内容过滤空字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let fileText = reader.result;</span><br><span class="line">fileText.replace(/\s/g, &quot;&quot;);</span><br><span class="line">saveFile(fileText)</span><br></pre></td></tr></table></figure><p>再补充一点内容，createObjectURL()方法还有一个对应的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/revokeObjectURL" target="_blank" rel="external">URL.revokeObjectURL()</a>方法，用来释放生成的URL对象，用法是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj_url = window.URL.createObjectURL(blob);</span><br><span class="line">var iframe = document.getElementById(&apos;viewer&apos;);</span><br><span class="line">iframe.setAttribute(&apos;src&apos;, obj_url);</span><br><span class="line">window.URL.revokeObjectURL(obj_url);</span><br></pre></td></tr></table></figure><p>当obj_url已经赋值给图片之后，就可以释放这个URL对象。这里的关键在于确定URL对象已经使用完了，在我们的例子中如果也这么做，实际上是不行的，当用户点击下载链接的时候会提示网络错误，因为href指向的链接已经失效了。猜测原因是，图片加载并显示的时候已经将数据载入内存了，这时候释放URL不会影响到图片的显示；而链接地址属于“引用”，点击瞬间会去访问URL对象，如果这时候对象已经释放了就会导致链接失效。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>HTML5实现文件读取、编辑、保存其实非常简单，只不过涉及到的API兼容性都比较堪忧，以上示例仅在chrome里测试过。</p><p>完整的示例代码地址：<br><a href="https://github.com/tower1229/htm5-file-operations" target="_blank" rel="external">https://github.com/tower1229/htm5-file-operations</a></p><p>演示地址:<br><a href="https://refined-x.com/htm5-file-operations/">https://refined-x.com/htm5-file-operations/</a></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2018/09/03/HTML5%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E3%80%81%E7%BC%96%E8%BE%91%E3%80%81%E4%BF%9D%E5%AD%98/#disqus_thread</comments>
    </item>
    
    <item>
      <title>《Hybrid App开发快速指南》新课上线！</title>
      <link>https://refined-x.com/2018/08/09/%E3%80%8AHybrid%20App%E5%BC%80%E5%8F%91%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97%E3%80%8B%E6%96%B0%E8%AF%BE%E4%B8%8A%E7%BA%BF/</link>
      <guid>https://refined-x.com/2018/08/09/%E3%80%8AHybrid%20App%E5%BC%80%E5%8F%91%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97%E3%80%8B%E6%96%B0%E8%AF%BE%E4%B8%8A%E7%BA%BF/</guid>
      <pubDate>Thu, 09 Aug 2018 04:53:21 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;混合应用开发作为技术热点的时代已经过去了，但作为一种轻便可靠的开发手段，却早已在前端开发领域落了地。&lt;/p&gt;
&lt;p&gt;我四年前就开始从事混合应用开发，从Cordova到Appcan再到APICloud，经年累月的摸索，逐渐形成一套对前端开发者更友好的混合开发最佳实践。对于刚接
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>混合应用开发作为技术热点的时代已经过去了，但作为一种轻便可靠的开发手段，却早已在前端开发领域落了地。</p><p>我四年前就开始从事混合应用开发，从Cordova到Appcan再到APICloud，经年累月的摸索，逐渐形成一套对前端开发者更友好的混合开发最佳实践。对于刚接触混合开发的新人，与其自己摸索文档或者到论坛里发帖求助，最快的学习路径莫过于直接上手一套经过验证的方式方法。</p><p>《Hybrid App开发快速指南》这门课从去年上半年就开始筹备，起因是过去四年里我在混合开发中遇到非常多的困扰和疑问，当我试图从论坛或Q群里获取帮助时，发现这些地方根本指望不上，很多问题到最后还得靠自己摸索。所以我将自己的学习历程提炼汇总，梳理成一套课程，希望能为其他混合应用开发者带来帮助，不再经历我所经历过的迷茫。</p><p>为答谢关注公众号的朋友，最先评论公众号同名推送文章的两位读者，我将赠送免费学习名额，公众号：<a href="https://refined-x.com/programmerslife/">programmerslife（看风景）</a>。</p><p>另外还可以参加抽奖活动，中将的两位也将获得免费学习名额。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/7wyhibGKvoP0dESNeYfADG0Eo9ZBqfXYc0eQE5aXUZjE52yrTbLPhicaPA5msibTNl8m2OhVK6jZgicdwtwN4KdrvQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt=""></p><p>感兴趣的朋友还可以扫描下方二维码，或者<a href="https://gitbook.cn/gitchat/column/5b679a1d201ffa4ab88e7d5d" target="_blank" rel="external">点此链接</a>学习课程。</p><p><img src="https://refined-x.com/asset/course-hybrid.png" alt=""></p><h2 id="附：课程介绍"><a href="#附：课程介绍" class="headerlink" title="附：课程介绍"></a>附：课程介绍</h2><p>本课程为混合应用开发入门课程，将带领读者快速掌握 Hybrid App 开发能力，内容涵盖混合应用原理、混合应用开发基础、混合应用开发进阶、混合应用开发最佳实践。</p><p>课程主要分为两大部分：</p><p>第一部分（第01-05课），理论篇，带大家明确了解混合应用开发与普通 Web 前端开发的差异，内容包括混合应用原理、混合应用界面开发、混合应用体验优化、性能优化、混合应用安全性等，属于混合应用开发基础理论内部。</p><p>第二部分（第06-13课），实战篇，从技术选型开始，讲解如何基于 APICloud 平台开发混合应用，内容包括平台特性、前端项目工程规划、界面交互、数据交互、数据缓存等开发中的各个方面，并将遇到的所有需求一一封装，最终将带你从零搭建一套混合应用开发框架。<br>课程以实战干货为主，在保证学习连贯性的前提下，尽量减少文档可查、引擎可搜的内容。通过认真学习本课程，读者将对混合应用开发有深入的理解，并有能力基于 APICloud 平台快速开发跨平台混合应用。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2018/08/09/%E3%80%8AHybrid%20App%E5%BC%80%E5%8F%91%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97%E3%80%8B%E6%96%B0%E8%AF%BE%E4%B8%8A%E7%BA%BF/#disqus_thread</comments>
    </item>
    
    <item>
      <title>基于Vue实现动态组织结构图</title>
      <link>https://refined-x.com/2018/08/03/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E5%9B%BE/</link>
      <guid>https://refined-x.com/2018/08/03/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E5%9B%BE/</guid>
      <pubDate>Fri, 03 Aug 2018 09:36:23 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;Vue-Tree-Chart&quot;&gt;&lt;a href=&quot;#Vue-Tree-Chart&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Vue-Tree-Chart"><a href="#Vue-Tree-Chart" class="headerlink" title="Vue-Tree-Chart"></a>Vue-Tree-Chart</h2><p>最近一个项目里有个前端绘制家谱图的需求，大概是下面这个样子：</p><p><img src="https://refined-x.com/asset/vue-tree-chart.png" alt=""></p><p>点击节点会弹出操作菜单，实现增删改查等操作，查阅网上资料发现，现有案例基本都是基于<a href="http://www.getorgchart.com/" target="_blank" rel="external">orgchart</a>这个jQuery插件实现的，我们的项目是基于Vue的，不希望因为这个功能引入jQuery，所以就基于Vue实现了一个简易版的树形图/组织结构图组件：<a href="https://github.com/tower1229/Vue-Tree-Chart" target="_blank" rel="external">Vue-Tree-Chart</a>。</p><p><a href="https://github.com/tower1229/Vue-Tree-Chart" target="_blank" rel="external">Vue-Tree-Chart</a>实现了最核心的组织结构图动态绘制和点击节点回调，基于这两点已经可以满足绝大多数相关需求了，例如前端动态增删改，无非是编辑组件数据，利用Vue的数据驱动特性界面就会自动更新；服务端增删改就更简单了，前端只管请求操作接口，操作结束后拉取最新数据同步给组件就行了；组件默认界面非常简单，只引入了图表呈现所必须的少量样式，后期非常方便自定义风格；至于拖动、缩放、导出等不太普遍的需求，组件没有内置，但是在源码基础上实现这些扩展也都比较简单。</p><h2 id="如何绘制结构图"><a href="#如何绘制结构图" class="headerlink" title="如何绘制结构图"></a>如何绘制结构图</h2><h3 id="不靠谱的思路"><a href="#不靠谱的思路" class="headerlink" title="不靠谱的思路"></a>不靠谱的思路</h3><p>拿到这个需求后我首先想到的思路是用DIV布局+JS动态计算实现，如果不考虑节点连线的话，这个思路其实勉强也能应付，大致实现分为三步：</p><h4 id="一、将数据按“代”拆分"><a href="#一、将数据按“代”拆分" class="headerlink" title="一、将数据按“代”拆分"></a>一、将数据按“代”拆分</h4><p>原始数据格式只能是层层深入的JSON对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: &apos;root&apos;,</span><br><span class="line">    children: [&#123;</span><br><span class="line">        name: &apos;child&apos;,</span><br><span class="line">        children: [&#123;</span><br><span class="line">            name: &apos;grandchild&apos;,</span><br><span class="line">            ...</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按“代”拆分后成为这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    [&#123;</span><br><span class="line">        id: 0,</span><br><span class="line">        name: &apos;root</span><br><span class="line">    &#125;],</span><br><span class="line">    [&#123;</span><br><span class="line">        id: 1,</span><br><span class="line">        name: &apos;child&apos;,</span><br><span class="line">        pid: 0</span><br><span class="line">    &#125;],</span><br><span class="line">    [&#123;</span><br><span class="line">        id: 2</span><br><span class="line">        name: &apos;grandchild&apos;,</span><br><span class="line">        pid: 1</span><br><span class="line">    &#125;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>形象一点，我想要的其实是这种结构：</p><p><img src="https://refined-x.com/asset/nodes-1.png" alt=""></p><h4 id="二、按“代”绘制节点"><a href="#二、按“代”绘制节点" class="headerlink" title="二、按“代”绘制节点"></a>二、按“代”绘制节点</h4><p>有了上一步的数据，再将每一代的节点从上到下生成出来简直不要太容易，然后居中一下，树形结构基本就出来了：</p><p><img src="https://refined-x.com/asset/nodes-2.png" alt=""></p><p>这时节点的间距是相同的，我们需要在下一步中计算并更新节点间距，使他们呈现出正确的归属关系。</p><h4 id="三、计算节点间距"><a href="#三、计算节点间距" class="headerlink" title="三、计算节点间距"></a>三、计算节点间距</h4><p>我们需要的是这样的效果：</p><p><img src="https://refined-x.com/asset/nodes-3.png" alt=""></p><p>观察图形得知，除了初代节点始终居中之外，其他节点所占空间应该等于后代节点所占空间，所以我们需要从最后一代节点开始遍历，依次向上得到父级节点应该占据的空间，从而计算出其需要的左右<code>marin</code>值，将所有包含子节点的节点应用正确的<code>margin</code>后，应该就可以得到上图的效果。</p><p>另外，家谱图还需要节点间连线，如果仍然按照这个思路，用div模拟画线也可以，但这样一来计算逻辑的复杂度就比较大了，这时候已经明显感觉思路不对了，必须换方向。</p><h3 id="Table的妙用"><a href="#Table的妙用" class="headerlink" title="Table的妙用"></a>Table的妙用</h3><p>后来参考orgchart的实现，打开调试工具一看，怎么里面一大堆<code>&lt;table&gt;</code>标签，心想这是什么骚操作，后来仔细研究DEMO的标签结构，原来orgchart非常巧妙的利用了Table标签的特性，只要合理嵌套Table，浏览器就会自然渲染出我们需要的结果。</p><p>这里补充一下Table的背景知识，在DIV+CSS刚刚盛行的年代，Table布局因为渲染慢和代码冗余被所有前端集体唾弃，Table布局渲染慢的原因是，TD是唯一一个先进入文档可能被后进入文档影响到自身尺寸的标签，如果按照普通的页面渲染逻辑加载整页Table，就会随着TD标签的载入频繁触发页面重绘，浏览器为了避免这种情况所以会对Table采用特殊的绘制逻辑，也就是等整个Table标签全部加载完，再集中一次绘制到页面上。这样的结果就是当页面完全使用Table布局的时候，整个页面加载过程是空白的，加载完之后页面会一次性突然呈现，这在弱网情况下的用户体验非常差，因此不使用Table布局成了对前端开发最基本的要求。</p><p>Table的这种特性虽然不适合用来布局，但却使Table成了HTML中“最强大”的标签，比如前面我们梳理的树形插件的实现思路，其实就是对Table特性的拙劣模仿，一个多代组织结构关系完全可以只用Table标签完美实现，甚至连CSS都不需要：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td colspan=&quot;2&quot;&gt;</span><br><span class="line">            root</span><br><span class="line">        &lt;/td/&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;table&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        children1</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        &lt;table&gt;</span><br><span class="line">                            &lt;tr&gt;</span><br><span class="line">                                &lt;td colspan=&quot;2&quot;&gt;</span><br><span class="line">                                    children2</span><br><span class="line">                                &lt;/td&gt;</span><br><span class="line">                            &lt;/tr&gt;</span><br><span class="line">                            &lt;tr&gt;</span><br><span class="line">                                &lt;td&gt;</span><br><span class="line">                                    grandchild1</span><br><span class="line">                                &lt;/td&gt;</span><br><span class="line">                                &lt;td&gt;</span><br><span class="line">                                    grandchild2</span><br><span class="line">                                &lt;/td&gt;</span><br><span class="line">                            &lt;/tr&gt;</span><br><span class="line">                        &lt;/table&gt;</span><br><span class="line">                    &lt;/td&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">            &lt;/table&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><p>虽然结构很罗嗦，但确实能实现需求。</p><p>节点连线的实现同样是利用了Table的自适应性，只不过实现的更加精妙：</p><p><img src="https://refined-x.com/asset/nodes-4.png" alt=""></p><p>上下级的连线分成两行（TR）实现，第一行实现一个连结父节点的居中竖线，第二行实现连接每个子节点的竖线及横向连线，第一行比较简单这里不提，第二行的实现非常有意思，上图中画红框的部分分别是实现效果和标签结构。</p><p>首先按照子节点数量X2来生成TD标签，然后”rightLine”、”leftLine”交替为每个TD添加class，”rightLine”为TD显示1px的右边线，”leftLine”为TD显示1px的左边线，六根一右一左的线两两合并在一起，正好呈现出三条连接每个子节点正中的2px竖线；然后除了第一个和最后一个TD标签以外，全部添加”topLine”的class，为他们添加2px的上边线，这样会呈现出一条正好连接三条竖线的横线，再拼上第一行TR的居中竖线，上下级的连线就实现出来了。</p><p>看到这部分时，反正我是感觉自己的智商被碾压了。（这部分在1.1.0版本中被重构掉了，因为用伪元素实现连线更方便）</p><p>基于这个思路用Vue实现了一遍，独立成组件后<a href="https://github.com/tower1229/Vue-Tree-Chart/blob/master/lib/components/TreeChart.vue" target="_blank" rel="external">整个文件</a>代码不过百行左右。</p><p>另外知识的活学活用真的非常重要，这里面的知识点一个入门前端就应该掌握，但开发的时候却完全没有想到这个思路，可能跟近几年的工作大量依赖js有关系，对HTML和CSS的敏感性降低了。总是使用自己熟悉的方式解决问题是人的共性，但这一点对开发者来说绝对不是个好习惯，需要反省。</p><h2 id="二次开发"><a href="#二次开发" class="headerlink" title="二次开发"></a>二次开发</h2><p>Vue-Tree-Chart已经发布到npm，默认可以通过包管理工具将其添加到项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-tree-chart --save</span><br></pre></td></tr></table></figure><p>但npm安装的是编译后的版本，如果希望比较灵活的在项目中做二次开发，可以直接将<code>&#39;lib/components/TreeChart.vue&#39;</code>文件下载到项目的组件目录（<code>&#39;src/components/&#39;</code>），直接修改<code>TreeChart.vue</code>文件就可以了。</p><h2 id="vue-cli-3-0-构建库"><a href="#vue-cli-3-0-构建库" class="headerlink" title="vue-cli 3.0 构建库"></a>vue-cli 3.0 构建库</h2><p>最后提一下vue-cli 3.0的<a href="https://cli.vuejs.org/zh/guide/build-targets.html#%E5%BA%94%E7%94%A8" target="_blank" rel="external">构建目标</a>功能，为了方便组件开发者，vue-cli 3.0在常规构建之外单独提供了针对库和Web Components组件两种构建模式，现在开发Vue插件/组件再也不需要手动修改webpack配置了，只要为构建命令传入<code>target\name\entry</code>，就能自动将入口文件编译成库，并输出CommonJS、浏览器环境所需要的一系列文件。</p><p>例如Vue-Tree-Chart的package.json文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;main&quot;: &quot;./dist/TreeChart.common.js&quot;,</span><br><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build-bundle&quot;: &quot;vue-cli-service build --target lib --name TreeChart ./lib/index.js&quot;,</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>执行<code>npm run build-bundle</code>就会在<code>&#39;/dist&#39;</code>目里下生成一系列产出文件，其中<code>&quot;TreeChart.common.js&quot;</code>是webpack环境下需要的CommonJS包，将这个文件配置为<code>&#39;main&#39;</code>，就可以在项目中这样使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import TreeChart from &quot;vue-tree-chart&quot;;</span><br></pre></td></tr></table></figure><p>导入的TreeChart对象就是一个Vue Component，可以作为全局组件或者局部组件挂载使用。</p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>Vue-Tree-Chart项目地址：<a href="https://github.com/tower1229/Vue-Tree-Chart" target="_blank" rel="external">https://github.com/tower1229/Vue-Tree-Chart</a></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2018/08/03/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E5%9B%BE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何计算一款保险的杠杆</title>
      <link>https://refined-x.com/2018/07/02/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E4%B8%80%E6%AC%BE%E4%BF%9D%E9%99%A9%E7%9A%84%E6%9D%A0%E6%9D%86/</link>
      <guid>https://refined-x.com/2018/07/02/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E4%B8%80%E6%AC%BE%E4%BF%9D%E9%99%A9%E7%9A%84%E6%9D%A0%E6%9D%86/</guid>
      <pubDate>Mon, 02 Jul 2018 07:06:20 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这篇文章向大家分享一个复利计算小工具，用来模拟保险年缴保费的支出情况，并用复利的方式算出这些保费在相同年数里的理财收入，技术含量极低，但如果你像我一样近期有买保险需求的话，这个小工具可以帮助你快速衡量一款保险产品的投入产出杠杆。</p><h2 id="聊聊保险"><a href="#聊聊保险" class="headerlink" title="聊聊保险"></a>聊聊保险</h2><p>自从宝宝出生后，突然感觉自己的健康风险特别高，为什么呢，说白了就一个原因：<strong>收入来源单一</strong>，孩子在不断长大，父母在不断老去，家庭支出在可预见的未来越来越高，这时候作为家庭经济支柱的自己如果出了问题，后果不堪设想，所以有一天我的脑子里突然响起一个声音：我要买保险。说到保险很多人第一反应是<code>骗子、坑、水深、感觉没啥用</code>，这也是我曾经的想法，但当有一天你也看到自己珍视的东西暴露在不可承受的风险之下时，可能也会重新考虑保险这件事。其实<strong>保险的本质是杠杆</strong>，这个杠杆允许你交一小笔钱，待出现风险时拿到一笔大钱，帮助家庭度过难关。在这个本质的基础上，如今的保险产品衍生出了太多花样，我花了不少时间才大致理清一个脉络，这里就不展开说了。</p><h2 id="定投复利计算器"><a href="#定投复利计算器" class="headerlink" title="定投复利计算器"></a>定投复利计算器</h2><p>前面大致说了这个计算器是干什么用的，这里再详细解释一下。以我自己为例，准备买人生第一款商业保险，重疾险，对于暂时手头没有那么宽裕的人（===穷人）来说，只能选择消费型、低保额、保终身，于是就锁定了全网最便宜的消费型重疾险<a href="https://cps.qixin18.com/zt1029065/product/detail-2170-2726.html" target="_blank" rel="external">百年康惠保</a>，保额我打算先来30万，以后宽裕了再增加（maybe），缴费年限越长年费越少（总额会多一些），老夫已经30了，希望20年内缴完，所以保费情况是这样的：</p><p><a href="https://cps.qixin18.com/zt1029065/product/detail-2170-2726.html" target="_blank" rel="external"><img src="https://refined-x.com/asset/baofei-kanghuibao.png" alt="此处输入图片的描述"></a></p><p>每年缴3390元，缴费20年，那么此时我最想知道，同样的时间和金钱付出，如果用在普通理财产品上会有怎样的收益？假设自己可以通过理财达到跟保险保额差不太多的收益，那显然就不需要买保险了。OK，我平时工资一般就放在微信钱包-零钱通里，年化收益率大致4%，如果我把每年要缴给保险公司的3390元都放进零钱通，20年后我一共有多少钱？算法很简单，第一年投入的年费作为初始本金，到年底会获得4%的受益，然后连本带息再加上第二年的年费一起作为第二年的本金，继续按照4%的收益率计算年底收益，以此类推直到20年，得到最终结果。</p><p><a href="//refined-x.com/projects/codes/interest.html">复利计算器</a>就是用来做这件事的，最终计算结果为104983，也就是10万出头，而这款产品的保额是30万，那么可以得出结论，以我的理财能力这款保险的保费杠杆可以达到3倍，这基本上是市面上杠杆最高的了，看来全网最便宜果然名不虚传。</p><p><img src="https://refined-x.com/asset/interest.png" alt="此处输入图片的描述"></p><p>感兴趣的可以自己来算算：<a href="//refined-x.com/projects/codes/interest.html">复利计算器</a>。</p><p>这里衍生一个话题，就是什么人不需要买保险？我觉得有两种人，第一是理财收益率能达到13%的人，因为通过计算得知，只要保持这个收益率就能将<a href="https://cps.qixin18.com/zt1029065/product/detail-2170-2726.html" target="_blank" rel="external">“全网最便宜的消费型重疾险”</a>的杠杆拉平，获得跟保费大致相同的收益，但是理财讲究资金的规模效应，以多数人的资金水平不可能稳定实现这么高的收益率；第二种人可能就是所谓生意人了，把钱投入商业运作，得到多高的收益都不稀奇，难点在于稳定。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>计算器的具体实现实在太简单就不提了，有兴趣的可以自己打开调试工具看源码。这里想多说两句，大家买保险千万不要凭感觉去买，很多人不喜欢纯消费型保险，认为如果自己好人一生平安就相当于把钱白给保险公司了，首先这是事实，你得到了你需要的保障，保险公司得到了利润，天经地义，也因此保险才是一个双赢产品，得以经久不衰的经营下去。由于这种“吃亏”心理非常普遍，因此市面上带返还的产品非常受欢迎，比如有的产品会在65周岁时反保额，看上去好像很划算，其实自己算一下就知道，去掉返现以后你的总投入一点不比消费型产品少，因为这期间动辄几十年的时间，你的本金会源源不断的产生收益，正所谓时间就是金钱。</p><hr><p><a href="//refined-x.com/projects/codes/interest.html">复利计算器</a></p><p><a href="https://cps.qixin18.com/zt1029065/product/detail-2170-2726.html" target="_blank" rel="external">“全网最便宜的消费型重疾险”</a></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2018/07/02/%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E4%B8%80%E6%AC%BE%E4%BF%9D%E9%99%A9%E7%9A%84%E6%9D%A0%E6%9D%86/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HybridStart v1.2.0 更新日志</title>
      <link>https://refined-x.com/2018/04/27/HybridStart%20v1.2.0%20%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</link>
      <guid>https://refined-x.com/2018/04/27/HybridStart%20v1.2.0%20%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</guid>
      <pubDate>Fri, 27 Apr 2018 08:53:15 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;新增&quot;&gt;&lt;a href=&quot;#新增&quot; class=&quot;headerlink&quot; title=&quot;新增&quot;&gt;&lt;/a&gt;新增&lt;/h2&gt;&lt;h3 id=&quot;1-插件机制&quot;&gt;&lt;a href=&quot;#1-插件机制&quot; class=&quot;headerlink&quot; title=&quot;1.
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h2><h3 id="1-插件机制"><a href="#1-插件机制" class="headerlink" title="1. 插件机制"></a>1. 插件机制</h3><p>WEB代码无需编译，部署即可运行，因此可以很容易的实现热插拔插件机制，HybridStart内置了一个插件机制的实现DEMO，见示例APP首页“OTA-plugins(扩展插件)”。实现代码位于<code>/views/ota/</code>，额外引入了<a href="https://docs.apicloud.com/Client-API/Func-Ext/zip" target="_blank" rel="external">zip</a>模块实现插件压缩包的解压，完整流程如下：</p><p><img src="http://refined-x.com/asset/hybridstart-plugin.png" alt=""></p><p>插件列表数据格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;status&quot;: &quot;Y&quot;,</span><br><span class="line">&quot;data&quot;: [&#123;</span><br><span class="line">&quot;remote&quot;: &quot;http://static-zt.oss-cn-qingdao.aliyuncs.com/mock/plugin-test.zip&quot;,//插件压缩包下载地址</span><br><span class="line">&quot;index&quot;: &quot;/view/index/temp.html&quot;,//插件首页路径</span><br><span class="line">&quot;name&quot;: &quot;plugin-test&quot;,//插件名称（唯一标识）</span><br><span class="line">&quot;showName&quot;: &quot;测试插件&quot;//插件展示名称</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&quot;remote&quot;: &quot;http://static-zt.oss-cn-qingdao.aliyuncs.com/mock/plugin-refined-x.zip&quot;,</span><br><span class="line">&quot;index&quot;: &quot;/view/index/temp.html&quot;,</span><br><span class="line">&quot;name&quot;: &quot;plugin-refined-x&quot;,</span><br><span class="line">&quot;showName&quot;: &quot;下载失败测试&quot;</span><br><span class="line">&#125;],</span><br><span class="line">&quot;msg&quot;: &quot;获取插件成功&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对插件包的文件结构没有要求，只需要在插件数据中正确指定首页即可，每个插件都自成一体，无法调用App的脚本文件。示例没有实现插件的删除，实际应用中可以自行实现删除功能。</p><h3 id="2-UI支持沉浸式"><a href="#2-UI支持沉浸式" class="headerlink" title="2. UI支持沉浸式"></a>2. UI支持沉浸式</h3><p>对<code>ui.less</code>做了调整，可以很容易的适配沉浸式效果，只需要给<code>.head类</code>加上<code>padding-top:24px</code>，编译成<code>ui.css</code>即可。开启沉浸式体验可以修改<code>config.xml</code>中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;preference name=&quot;statusBarAppearance&quot; value=&quot;true&quot;/&gt;//默认false</span><br></pre></td></tr></table></figure><h2 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h2><h3 id="1-移除页面style-css文件"><a href="#1-移除页面style-css文件" class="headerlink" title="1. 移除页面style.css文件"></a>1. 移除页面style.css文件</h3><p>考虑到页面独有样式通常不多，所以从页面文件夹中移除style.css文件，页面样式可以直接写在<code>temp.html</code>头部，减少文件引用，提升页面加载速度。</p><h3 id="2-增加loader-js"><a href="#2-增加loader-js" class="headerlink" title="2. 增加loader.js"></a>2. 增加loader.js</h3><p>将原来页面底部的一大坨异步非阻塞加载脚本的代码整理成<code>loader.js</code>统一调用。所谓异步非阻塞的意思是绕过APICloud的加载等待机制，使新开窗口能第一时间进场，在进场动画过程中加载页面脚本，以提升页面进场动画的响应速度。</p><p>由此带来的问题是页面脚本只能在真机环境下运行，让js调试非常不方便，关于调试方面的建议可以参考<a href="https://refined-x.com/HybridStart/docs/#solution-speed">进场动画提速</a></p><h2 id="BUG-修复"><a href="#BUG-修复" class="headerlink" title="BUG 修复"></a>BUG 修复</h2><h3 id="1-IOS事件委托BUG"><a href="#1-IOS事件委托BUG" class="headerlink" title="1. IOS事件委托BUG"></a>1. IOS事件委托BUG</h3><p>这个BUG的复现条件为，在IOS环境下将多个页面元素（比如列表项）的点击事件委托在body元素上，当元素多到足以页面发生滚动时，非首屏的元素将不响应点击事件。框架在<code>common.js</code>中默认提供的<code>[active]</code>跳转属性受到该BUG影响，示例APP的首页列表在IOS上会出现非首屏内容无法点击的问题。</p><p>解决方法为在body里插入一个<code>div#body</code>元素，将事件委托改在这个元素上就OK了，<code>common.js</code>里的事件委托写法做了如下兼容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var $body = $(&apos;#body&apos;).length ? $(&apos;#body&apos;) : $(&apos;body&apos;);//优先查找div#body元素</span><br><span class="line">$body.on(...</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-移除默认数据格式约定"><a href="#1-移除默认数据格式约定" class="headerlink" title="1. 移除默认数据格式约定"></a>1. 移除默认数据格式约定</h3><p>不再约定默认的异步数据格式，<code>app.ajax()</code>中已经移除数据格式校验相关代码。</p><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><p><a href="http://app.mi.com/details?id=com.apicloud.A6997660453388" target="_blank" rel="external">体验APP</a></p><p><a href="https://github.com/tower1229/HybridStart" target="_blank" rel="external">代码仓库</a></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2018/04/27/HybridStart%20v1.2.0%20%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>AJAX-Cache：一款好用的Ajax缓存插件</title>
      <link>https://refined-x.com/2018/03/07/AJAX-Cache/</link>
      <guid>https://refined-x.com/2018/03/07/AJAX-Cache/</guid>
      <pubDate>Wed, 07 Mar 2018 01:29:37 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;AJAX-Cache是什么&quot;&gt;&lt;a href=&quot;#AJAX-Cache是什么&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="AJAX-Cache是什么"><a href="#AJAX-Cache是什么" class="headerlink" title="AJAX-Cache是什么"></a>AJAX-Cache是什么</h2><p>Ajax是前端开发必不可少的数据获取手段，在频繁的异步请求业务中，我们往往需要利用“缓存”提升界面响应速度，减少网络资源占用。AJAX-Cache是一款jQuery缓存插件，可以为<code>$.ajax()</code>方法扩展缓存功能。</p><h2 id="AJAX-Cache提供什么"><a href="#AJAX-Cache提供什么" class="headerlink" title="AJAX-Cache提供什么"></a>AJAX-Cache提供什么</h2><h3 id="1-定时缓存"><a href="#1-定时缓存" class="headerlink" title="1. 定时缓存"></a>1. 定时缓存</h3><p>大多数的缓存场景是，希望将某个接口数据在一定时间段内缓存起来，缓存期内不再发起请求直接返回本地数据，过了这段时间再重新获取并更新缓存。</p><p>这就是“定时缓存”的典型使用场景，我们可以为<code>$.ajax()</code>方法传入<code>localCache: Number</code>开启定时缓存，Number是缓存秒毫秒数。定时缓存实际上是牺牲了数据实时性换取响应速度，使用中通过设置不同的缓存时长，可以匹配不同的业务场景，比如对于相对稳定的数据可以设置较长的缓存时间，而设置较短的缓存时间则可以起到请求“防抖”作用。</p><h3 id="2-快照缓存"><a href="#2-快照缓存" class="headerlink" title="2. 快照缓存"></a>2. 快照缓存</h3><p>更多的时候我们希望接口能兼具实时性和响应速度，比如应用首屏的异步数据块，既要快又要新，虽然这种需求听起来很“不科学”，但我们确实可以通过“快照缓存”满足这个需求。</p><p>为<code>$.ajax()</code>方法传入<code>localCache: &quot;snapshot&quot;</code>可以开启快照缓存，此时每当接口成功请求后都会为数据建立一份“快照”，下次请求时接口会首先将最近的快照数据作为结果返回，供前端渲染界面，同时发送请求获取最新数据，新数据到达后会与快照做对比，如果与快照相同则缓存命中，如果与快照不同会更新快照，并将新数据返回，供前端更新界面。也就是说启用快照缓存的接口前端有可能得到两次返回结果，为了让前端能够区分出快照，对象格式的快照数据会自动增加一个<code>snapshot=true</code>的属性。</p><h3 id="3-缓存清理"><a href="#3-缓存清理" class="headerlink" title="3. 缓存清理"></a>3. 缓存清理</h3><p>插件本身会自动清理过期缓存；</p><p>对于不想继续使用缓存的接口可以为<code>$.ajax()</code>方法传入<code>localCache: false</code>清理当前接口的缓存并返回最新数据；</p><p>也可以调用<code>$.ajaxCache.clear()</code>清理所有AJAX-Cache插件产生的缓存。</p><h3 id="4-并发管理"><a href="#4-并发管理" class="headerlink" title="4. 并发管理"></a>4. 并发管理</h3><p>除了上述基本功能，AJAX-Cache还考虑到了极端情况下的请求并发问题，当某个接口在本地没有缓存或者缓存过期时发生了并发，AJAX-Cache会拦截并发请求，暂存请求回调，只向服务端发送一次请求，待拿到数据后再依次执行暂存的请求回调，从而真正起到减少网络资源占用的作用。</p><h3 id="5-约定优于配置"><a href="#5-约定优于配置" class="headerlink" title="5. 约定优于配置"></a>5. 约定优于配置</h3><p>最后，Ajax-Cache奉行“约定优于配置”的理念，将主要功能都集中到一个<code>localCache</code>配置上，使用简单，将对业务代码的侵入性降到最低，如果没有使用<code>$.ajaxCache</code>全局方法的话，从页面中直接将Ajax-Cache插件移除业务代码也不会报错。</p><p>使用简单不代表功能简单，如果需要修改Ajax-Cache的全局配置，也可以通过<code>$.ajaxCache.set(config[Object])</code>方法实现，目前有两个配置项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">storage: &apos;localStorage&apos;, //存储方式，默认localStorage，可选sessionStorage</span><br><span class="line">cacheNamePrefix: &apos;_ajaxcache&apos; //存储标识，集中清理缓存时的依据，如果与你存储的业务数据发生冲突，可以通过这里修改</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展信息"><a href="#扩展信息" class="headerlink" title="扩展信息"></a>扩展信息</h2><p>官网：//refined-x.com/AJAX-Cache/<br>Github：<a href="https://github.com/tower1229/AJAX-Cache" target="_blank" rel="external">https://github.com/tower1229/AJAX-Cache</a></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2018/03/07/AJAX-Cache/#disqus_thread</comments>
    </item>
    
    <item>
      <title>前端页面热更新实现方案</title>
      <link>https://refined-x.com/2018/02/07/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</link>
      <guid>https://refined-x.com/2018/02/07/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</guid>
      <pubDate>Wed, 07 Feb 2018 02:46:48 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;前端页面热更新&quot;&gt;&lt;a href=&quot;#前端页面热更新&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="前端页面热更新"><a href="#前端页面热更新" class="headerlink" title="前端页面热更新"></a>前端页面热更新</h2><p>了解过前端性能优化的同学应该清楚，给页面加载提速的终极方案就是CDN，这是BS架构本身的特点决定的，无论什么前端提速手段，最终都会回到客户端文件的传输上来；与之相对的CS架构则不存在加载压力，但CS架构的问题是更新不灵活，那么有没有一种方法能结合这两种架构的优点，在加载速度和更新灵活性之间找到一个平衡点呢？这就是本文要探讨的一种方案：前端热更新。</p><h2 id="方案概述"><a href="#方案概述" class="headerlink" title="方案概述"></a>方案概述</h2><p>“前端”和“热更新”这两个词通常很少一起出现，提到热更新一般都是指APP的一种静默更新方式，这种方式会在用户使用时悄悄检测并下载增量更新包，当用户下次打开APP时自动应用更新，从而将APP“更新”这个破坏连贯性的动作隐藏于无形；前端页面的加载则相当于每次都是“全量更新”，如果能让前端页面也能用上“本地模板”，那将极大缩短前端加载时间，而且以此为前提，我们也可以实现一个前端的模板热更新机制，做到不影响页面更新的实时性。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>场景一：APP内嵌页面。</p><p>比如电商类APP的首页，经常需要改版或者做活动皮肤，如何减少更新成本就成了一个大问题。使用了热更新方案我们就可以用HTML实现APP首页，页面内容以模板的形式存进localStorage，后台静默更新模板，下次启动自动生效；针对具有一定时效性的活动皮肤，我们以补丁的形式发布，补丁文件叠加在模板上产生最终的活动模板效果，对于补丁包我们可以提前加载并预存在本地，补丁包应该包含自身的生效时段信息，前端检测到时间处于活动周期内时应用补丁。最终可以做到热更新页面无论改版还是做活动，只需要前端发版就可以，完全不需要APP端参与。</p><p>场景二：追求加载速度的web页面。</p><p>对于web页面来说更新不是问题，加载才是最大的问题，如果个别页面希望极致提升页面展现速度，那么也可以使用该方案作为提速手段，但因为页面的所有代码都将存进localStorage，所以不适合大范围使用。</p><h3 id="需求细化"><a href="#需求细化" class="headerlink" title="需求细化"></a>需求细化</h3><p>综合以上场景和需求，最终我们要做的东西是一个“壳”页面，该页面没有具体业务内容，只实现热更新功能，每次加载都先检查localStorage中是否存在模板，如果有则立即应用模板，此时页面展现出来，如果没有则进入下一步；下一步页面会请求模板管理接口获取最新模板信息，拿到模板信息后如果本地已有模板，则与本地模板比对版本信息，如果版本一致说明缓存命中，流程结束；如果本地版本不是最新，则获取最新模板并存进本地，下次页面加载时将应用最新的模板，流程结束；另一种情况是首次加载本地没有任何模板，那么将获取最新模板，保存到本地，然后应用模板，流程结束。</p><p>前面说的是稳定模板的更新流程，稳定模板流程结束后会进入补丁模板更新流程。首先仍然是检查本地是否存在补丁模板，如果已存在则检测当前时间是否匹配补丁的生效时段，匹配则应用补丁，不匹配将进入下一步；下一步将获取最新补丁模板并存到本地，然后检测当前时间是否匹配最新补丁的生效时段，如果匹配则应用模板，不匹配流程结束。</p><p>完整流程如图所示：<br><img src="https://refined-x.com/asset/hot-patch.png" alt="hot patch"></p><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="接口数据"><a href="#接口数据" class="headerlink" title="接口数据"></a>接口数据</h3><p>根据功能需求我们需要接口返回稳定模板信息和活动模板信息，分别都包含<code>id</code>和<code>url</code>两个字段，<code>id</code>用于版本校验，<code>url</code>指向模板文件下载地址，活动模板信息还需要额外提供<code>cycle</code>字段，定义活动模板的生效时段，与之相对的我们还需要接口返回服务器当前时间，用于匹配活动模板的生效时段，最终完整的数据结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;status&quot;: &quot;Y&quot;,</span><br><span class="line">&quot;data&quot;: &#123;</span><br><span class="line">&quot;stableVersion&quot;: &#123;</span><br><span class="line">&quot;id&quot;: &quot;17&quot;,</span><br><span class="line">&quot;url&quot;: &quot;&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;activeVersion&quot;: &#123;</span><br><span class="line">&quot;id&quot;: &quot;18&quot;,</span><br><span class="line">&quot;url&quot;: &quot;&quot;,</span><br><span class="line">&quot;cycle&quot;: &quot;2018,02,01-2018,02,10&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;today&quot;: &quot;2018,02,06&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="本地数据"><a href="#本地数据" class="headerlink" title="本地数据"></a>本地数据</h3><p>保存到本地的数据大致跟接口数据保持一致，只保留<code>stableVersion</code>和<code>activeVersion</code>信息，字段在<code>id</code>和<code>url</code>基础上再增加<code>template</code>用于保存模板字符串，完整本地数据结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;stableVersion&quot;: &#123;</span><br><span class="line">&quot;id&quot;: &quot;17&quot;,</span><br><span class="line">&quot;url&quot;: &quot;&quot;,</span><br><span class="line">&quot;template&quot;: &quot;&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;activeVersion&quot;: &#123;</span><br><span class="line">&quot;id&quot;: &quot;18&quot;,</span><br><span class="line">&quot;url&quot;: &quot;&quot;,</span><br><span class="line">&quot;cycle&quot;: &quot;2018,02,01-2018,02,10&quot;,</span><br><span class="line">&quot;template&quot;: &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板文件"><a href="#模板文件" class="headerlink" title="模板文件"></a>模板文件</h3><p>前端页面由三种语言构成，但我们希望只用一次请求就把模板文件拿到，所以模板是一个包含了html/css/js的文本文件，标签格式就保持普通HTML文件的写法，考虑到模板应用部分的实现，需要约定一下标签的写法，例如css必须用<code>&lt;style&gt;&lt;/style&gt;</code>标签包裹，js必须用<code>&lt;script style=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code>标签包裹，这样一来用正则表达式就很容易提取到各部分代码段。</p><h3 id="模板应用"><a href="#模板应用" class="headerlink" title="模板应用"></a>模板应用</h3><p>如上段所说，获得模板文件后可以使用正则表达式拿到三种语言代码，然后只需要按照css &gt; html &gt; js的顺序依次将他们插入页面相应位置，就完成了模板应用，唯一不同的是html代码将以<code>innerHTML</code>的方式覆盖进body元素。在应用顺序上，将css放在html之前是为了避免重绘，将js放在html之后是为了能够在js中操作DOM。</p><p>活动模板虽然定义为补丁，但模板构成跟稳定模板其实是相同的，应用方式也完全相同，只不过由于活动模板在稳定模板之后应用，所以活动模板的css和js都将以补丁的方式影响页面，对于普通的换皮肤需求只需要css和js就足够了，但如果希望html也能发生一些改变，根据html的覆盖式应用方式，活动模板中就需要给出一份完整的html代码，以达到修改html的目的。</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><h3 id="示例展示"><a href="#示例展示" class="headerlink" title="示例展示"></a>示例展示</h3><p><a href="//refined-x.com/WEB-OTA/">//refined-x.com/WEB-OTA/</a></p><p><img src="https://refined-x.com/asset/web-ota-qrcode.png" alt="qrcode"></p><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p><a href="http://o2o.zhongyishijia.com/" target="_blank" rel="external">一健康网上商城</a>APP首页即采用WEB-OTA方案实现，应付日常迭代游刃有余。</p><p><img src="https://refined-x.com/asset/yijiankang-share.png" alt="yijiankang"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>整个方案的流程比较琐碎，但实现过程其实很简单，部署成本也不高，只需要后端把模板管理起来，再提供一个更新接口就行了，但这套更新机制还是有一个小问题，那就是当有新版本发布时用户并不能第一时间看到新版本，必须下次访问才能更新到新版本，这算是静默更新要付出的一点点代价吧，如果实在介意这个问题其实也容易解决，只需要在检测到远程有新版本时提示用户重启/刷新就可以了。</p><p>相比较HTML5的manifest缓存方案，我认为灵活性要更高一些，但不足之处在于不支持静态文件的碎片化管理，但扩展这个功能也不复杂，无非模板信息里再扩展几个字段而已。</p><p>代码在这里了，更细节的东西自己看代码吧：<a href="https://github.com/tower1229/WEB-OTA" target="_blank" rel="external">https://github.com/tower1229/WEB-OTA</a></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2018/02/07/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%83%AD%E6%9B%B4%E6%96%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Vue2.0用户权限控制解决方案</title>
      <link>https://refined-x.com/2017/11/28/Vue2.0%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <guid>https://refined-x.com/2017/11/28/Vue2.0%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <pubDate>Tue, 28 Nov 2017 08:39:21 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;&lt;a href=&quot;//refined-x.com/Vue-Access-Control/&quot;&gt;Vue-Access-Control&lt;/a&gt;是一套基于Vue/Vue-Router/axios
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="//refined-x.com/Vue-Access-Control/">Vue-Access-Control</a>是一套基于Vue/Vue-Router/axios 实现的前端用户权限控制解决方案，通过对路由、视图、请求三个层面的控制，使开发者可以实现任意颗粒度的用户权限控制。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="版本要求"><a href="#版本要求" class="headerlink" title="版本要求"></a>版本要求</h3><ul><li>Vue 2.0x</li><li>Vue-router 3.x</li></ul><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>项目主页：//refined-x.com/Vue-Access-Control/</p><p>git：<code>git clone https://github.com/tower1229/Vue-Access-Control.git</code></p><p>npm：<code>npm i vue-access-control</code></p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//开发</span><br><span class="line">npm run dev</span><br><span class="line"></span><br><span class="line">//构建</span><br><span class="line">npm build</span><br></pre></td></tr></table></figure><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><p>会话开始之初，先初始化一个只有登录路由的Vue实例，在根组件created钩子里将路由定向到登录页，用户登录成功后前端拿到用户token，设置axios实例统一为请求headers添加<code>{&quot;Authorization&quot;:token}</code>实现用户鉴权，然后获取当前用户的权限数据，主要包括路由权限和资源权限，之后动态添加路由，生成菜单，实现权限指令和全局权限验证方法，并为axios实例添加请求拦截器，至此完成权限控制初始化。动态加载路由后，路由组件将随之加载并渲染，而后展现前端界面。</p><p>为解决浏览器刷新路由重置的问题，拿到token后要将其保存到<code>sessionStorage</code>，根组件的created钩子负责检查本地是否已有token，如果有则无需登录直接用该token获取权限并初始化，如果token有效且当前路由有权访问，将加载路由组件并正确展现；若当前路由无权访问将按路由设置跳转404；如果token失效，后端应返回4xx状态码，前端统一为axios实例添加错误拦截器，遇到4xx状态码执行退出操作，清除<code>sessionStorage</code>数据并跳转到登录页，让用户重新登录。</p><h3 id="最小依赖原则"><a href="#最小依赖原则" class="headerlink" title="最小依赖原则"></a>最小依赖原则</h3><p>Vue-Access-Control的定位是单一领域解决方案，除了Vue/Vue-Router/axios之外没有其他依赖，理论上可以无障碍的应用到任何有权限控制需求的Vue项目中，项目基于<a href="https://github.com/vuejs-templates/webpack" target="_blank" rel="external">webpack</a> 模板开发构建，大多数新项目可以直接基于检出代码继续开发。需要说明的是，项目额外引入的<a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="external">Element-UI</a>和<a href="https://www.npmjs.com/package/crypto-js" target="_blank" rel="external">CryptoJS</a>仅用于开发演示界面，他们不是必须且与权限控制毫无关系，项目应用中可以自行取舍。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line">  |-- api/                  //接口文件</span><br><span class="line">  |     |-- index.js             //输出通用axios实例</span><br><span class="line">  |     |-- account.js           //按业务模块组织的接口文件，所有接口都引用./index提供的axios实例</span><br><span class="line">  |-- assets/</span><br><span class="line">  |-- components/</span><br><span class="line">  |-- router/</span><br><span class="line">  |     |-- fullpath.js         //完整路由数据，用于匹配用户的路由权限得到实际路由</span><br><span class="line">  |     `-- index.js            //输出基础路由实例</span><br><span class="line">  |-- views/</span><br><span class="line">  |-- App.vue</span><br><span class="line">  ·-- main.js</span><br></pre></td></tr></table></figure><h3 id="数据格式约定"><a href="#数据格式约定" class="headerlink" title="数据格式约定"></a>数据格式约定</h3><ul><li><p>路由权限数据必须是如下格式的对象数组，<code>id</code>和<code>parent_id</code>相同的两个路由具有上下级关系，如果希望使用自定义格式的路由数据，需要修改路由控制的相关实现，详见<a href="#路由控制"><strong>路由控制</strong></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;菜单1&quot;,</span><br><span class="line">      &quot;parent_id&quot;: null,</span><br><span class="line">      &quot;route&quot;: &quot;route1&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;2&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;菜单1-1&quot;,</span><br><span class="line">      &quot;parent_id&quot;: &quot;1&quot;,</span><br><span class="line">      &quot;route&quot;: &quot;route2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></li><li><p>资源权限数据必须是如下格式的对象数组，每个对象代表一个RESTful请求，支持带参数的url，具体格式说明见<a href="#请求控制"><strong>请求控制</strong></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;2c9180895e172348015e1740805d000d&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;账号-获取&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;/accounts&quot;,</span><br><span class="line">      &quot;method&quot;: &quot;GET&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;id&quot;: &quot;2c9180895e172348015e1740c30f000e&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;账号-删除&quot;,</span><br><span class="line">      &quot;url&quot;: &quot;/account/**&quot;,</span><br><span class="line">      &quot;method&quot;: &quot;DELETE&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h2 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h2><p>路由控制包括动态注册路由和动态生成菜单两部分。</p><h3 id="动态注册路由"><a href="#动态注册路由" class="headerlink" title="动态注册路由"></a>动态注册路由</h3><p>最初实例化的路由仅包括登录和404两个路径，我们期待完整的路由是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">  path: &apos;/login&apos;,</span><br><span class="line">  name: &apos;login&apos;,</span><br><span class="line">  component: (resolve) =&gt; require([&apos;../views/login.vue&apos;], resolve)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  path: &apos;/404&apos;,</span><br><span class="line">  name: &apos;404&apos;,</span><br><span class="line">  component: (resolve) =&gt; require([&apos;../views/common/404.vue&apos;], resolve)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  path: &apos;/&apos;,</span><br><span class="line">  name: &apos;首页&apos;,</span><br><span class="line">  component: (resolve) =&gt; require([&apos;../views/index.vue&apos;], resolve),</span><br><span class="line">  children: [&#123;</span><br><span class="line">    path: &apos;/route1&apos;,</span><br><span class="line">    name: &apos;栏目1&apos;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      icon: &apos;icon-channel1&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    component: (resolve) =&gt; require([&apos;../views/view1.vue&apos;], resolve)</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: &apos;/route2&apos;,</span><br><span class="line">    name: &apos;栏目2&apos;,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      icon: &apos;ico-channel2&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    component: (resolve) =&gt; require([&apos;../views/view2.vue&apos;], resolve),</span><br><span class="line">    children: [&#123;</span><br><span class="line">      path: &apos;child2-1&apos;,</span><br><span class="line">      name: &apos;子栏目2-1&apos;,</span><br><span class="line">      meta: &#123;</span><br><span class="line">        </span><br><span class="line">      &#125;,</span><br><span class="line">      component: (resolve) =&gt; require([&apos;../views/route2-1.vue&apos;], resolve)</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  path: &apos;*&apos;,</span><br><span class="line">  redirect: &apos;/404&apos;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>那么接下来就需要获取首页以及其子路由们，思路是事先在本地存一份整个项目的完整路由数据，然后根据用户权限对完整路由进行筛选。</p><p>筛选的实现思路是先将后端返回的路由数据处理成如下哈希结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let hashMenus = &#123;</span><br><span class="line">   &quot;/route1&quot;:true,</span><br><span class="line">   &quot;/route1/route1-1&quot;:true,</span><br><span class="line">   &quot;/route1/route1-2&quot;:true,</span><br><span class="line">   &quot;/route2&quot;:true,</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后遍历本地完整路由，在循环中将路径拼接成上述结构中的key格式，通过<code>hashMenus[route]</code>就可以判断路由是否匹配，具体实现见<code>App.vue</code>文件中的<code>getRoutes()</code>方法。</p><p>如果后端返回的路由权限数据与约定不同，就需要自行实现筛选逻辑，只要能得到实际可用的路由数据就可以，最终使用<code>addRoutes()</code>方法将他们动态添加到路由实例中，注意404页面的模糊匹配一定要放在最后。</p><h3 id="动态菜单"><a href="#动态菜单" class="headerlink" title="动态菜单"></a>动态菜单</h3><p>路由数据可以直接用来生成导航菜单，但路由数据是在根组件中得到的，导航菜单存在于<code>index.vue</code>组件中，显然我们需要通过某种方式共享菜单数据，方法有很多，一般来说首先想到的是Vuex，但菜单数据在整个用户会话过程中不会发生改变，这并不是Vuex的最佳使用场景，而且为了尽量减少不必要的依赖，这里用了最简单直接的方法，把菜单数据挂在根组件<code>data.menuData</code>上，在首页里用<code>this.$parent.menuData</code>获取。</p><p>另外，导航菜单很可能会有添加栏目图标的需求，这可以通过在路由中添加<code>meta</code>数据实现，例如将图标class或unicode存到路由meta里，模板中就可以访问到meta数据，用来生成图标标签。</p><p>在多角色系统中可能遇到的一个问题是，不同角色有一个名字相同但功能不同的路由，比如说<em>系统管理员</em>和<em>企业管理员</em>都有”账号管理”这个路由，但他们的操作权限和目标不同，实际上是两个完全不同的界面，而Vue不允许多个路由同名，因此路由的name必须做区分，但把区分后的name显示在前端菜单上会很不美观，为了让不同角色可以享有同一个菜单名称，我们只要将这两个路由的<code>meta.name</code>都设置成”账号管理”，在模板循环时优先使用<code>meta.name</code>就可以了。</p><p>菜单的具体实现可以参考<code>views/index.vue</code>。</p><h2 id="视图控制"><a href="#视图控制" class="headerlink" title="视图控制"></a>视图控制</h2><p>视图控制的目标是根据当前用户权限决定界面元素显示与否，典型场景是对各种操作按钮的显示控制。实现视图控制的本质是实现一个权限验证方法，输入请求权限，输出是否获准。然后配合<code>v-if</code>或<code>jsx</code>或自定义指令就能灵活实现各种视图控制。</p><h3 id="全局验证方法"><a href="#全局验证方法" class="headerlink" title="全局验证方法"></a>全局验证方法</h3><p>验证方法的的实现本身很简单，无非是根据后端给出的资源权限做判断，重点在于优化方法的输入输出，提升易用性，经过实践总结最终使用的方案是，将权限跟请求同时维护，验证方法接收请求对象数组为参数，返回是否具有权限的布尔值。</p><p>请求对象格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//获取账户列表</span><br><span class="line">const request = &#123;</span><br><span class="line">  p: [&apos;get,/accounts&apos;],</span><br><span class="line">  r: params =&gt; &#123;</span><br><span class="line">    return instance.get(`/accounts`, &#123;params&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>权限验证方法<code>$_has()</code>的调用格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v-if=&quot;$_has([request])&quot;</span><br></pre></td></tr></table></figure><p>权限验证方法的具体实现见<code>App.vue</code>中<code>Vue.prototype.$_has</code>方法。</p><p>将权限验证方法全局混入，就可以在项目中很容易的配合<code>v-if</code>实现元素显示控制，这种方式的优点在于灵活，除了可以校验权限外，还可以在判断表达式中加入运行时状态做更多样性的判断，而且可以充分利用<code>v-if</code>响应数据变化的特点，实现动态视图控制。</p><p>具体实现细节参考<a href="//refined-x.com/2017/08/29/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/">基于Vue实现后台系统权限控制</a>中的相关章节。</p><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p><code>v-if</code>的响应特性是把双刃剑，因为判断表达式在运行过程中会频繁触发，但实际上在一个用户会话周期内其权限并不会发生变化，因此如果只需要校验权限的话，用<code>v-if</code>会产生大量不必要的运算，这种情况只需在视图载入时校验一次即可，可以通过自定义指令实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//权限指令</span><br><span class="line">Vue.directive(&apos;has&apos;, &#123;</span><br><span class="line">  bind: function(el, binding) &#123;</span><br><span class="line">    if (!Vue.prototype.$_has(binding.value)) &#123;</span><br><span class="line">      el.parentNode.removeChild(el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>自定义指令内部仍然是调用全局验证方法，但优点在于只会在元素初始化时执行一次，多数情况下都应该使用自定义指令实现视图控制。</p><h2 id="请求控制"><a href="#请求控制" class="headerlink" title="请求控制"></a>请求控制</h2><p>请求控制是利用axios拦截器实现的，目的是将越权请求在前端拦截掉，原理是在请求拦截器中判断本次请求是否符合用户权限，以决定是否拦截。</p><p>普通请求的判断很容易，遍历后端返回的的资源权限格式，直接判断<code>request.method</code>和<code>request.url</code>是否吻合就可以了，对于带参数的url需要使用通配符，这里需要根据项目需求前后端协商一致，约定好通配符格式后，拦截器中要先将带参数的url处理成约定格式，再判断权限，方案中已经实现了以下两种通配符格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 格式：/resources/:id</span><br><span class="line">   示例：/resources/1</span><br><span class="line">   url: /resources/**</span><br><span class="line">   解释：一个名词后跟一个参数，参数通常表示名词的id</span><br><span class="line">   </span><br><span class="line">2. 格式：/store/:id/member</span><br><span class="line">   示例：/store/1/member</span><br><span class="line">   url：/store/*/member</span><br><span class="line">   解释：两个名词之间夹带一个参数，参数通常表示第一个名词的id</span><br></pre></td></tr></table></figure><p>对于第一种格式需要注意的是，如果你要发起一个url为<code>&quot;/aaa/bbb&quot;</code>的请求，默认会被处理成<code>&quot;/aaa/**&quot;</code>进行权限校验，如果这里的”bbb”并不是参数而是url的一部分，那么你需要将url改成<code>&quot;/aaa/bbb/&quot;</code>，在最后加一个”/“表示该url不需要转化格式。</p><p>拦截器的具体实现见<code>App.vue</code>中的<code>setInterceptor()</code>方法。</p><p>如果你的项目还需要其他的通配符格式，只需要在拦截器中实现对应的检测和转化方法就可以了。</p><h2 id="演示及说明"><a href="#演示及说明" class="headerlink" title="演示及说明"></a>演示及说明</h2><h3 id="演示说明："><a href="#演示说明：" class="headerlink" title="演示说明："></a>演示说明：</h3><p>DEMO项目中演示了动态菜单、动态路由、按钮权限、请求拦截。</p><p>演示项目后端由<a href="http://rap2.taobao.org/" target="_blank" rel="external">rap2</a>生成mock数据，登录请求通常应该是POST方式，但因为rap2的编程模式无法获取到非GET的请求参数，因此只能用GET方式登录，实际项目中不建议仿效；</p><p>另外登录后获取权限的接口本来不需要携带额外参数，后端可以根据请求头携带的token信息实现用户鉴权，但因为rap2的编程模式获取不到headers数据，因此只能增加一个”Authorization”参数用于生成模拟数据。</p><h3 id="测试账号"><a href="#测试账号" class="headerlink" title="测试账号:"></a>测试账号:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. username: root</span><br><span class="line">   password: 任意</span><br><span class="line">2. username: client</span><br><span class="line">   password: 任意</span><br></pre></td></tr></table></figure><h3 id="演示地址"><a href="#演示地址" class="headerlink" title="演示地址:"></a>演示地址:</h3><p><a href="https://refined-x.com/Vue-Access-Control/">https://refined-x.com/Vue-Access-Control/</a></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/11/28/Vue2.0%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Vue2.0开发风格指南</title>
      <link>https://refined-x.com/2017/11/16/Vue2.0%E5%BC%80%E5%8F%91%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/</link>
      <guid>https://refined-x.com/2017/11/16/Vue2.0%E5%BC%80%E5%8F%91%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/</guid>
      <pubDate>Thu, 16 Nov 2017 07:03:32 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;本文是对Vue官方风格指南的注解，过滤了极少数我认为重要性很低的项目，并将其余项按照作用相关性重新归类，便于读者针对性的选择某一方面进行参考。&lt;/p&gt;
&lt;h2 id=&quot;框架或规范约束&quot;&gt;&lt;a href=&quot;#框架或规范约束&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>本文是对Vue官方风格指南的注解，过滤了极少数我认为重要性很低的项目，并将其余项按照作用相关性重新归类，便于读者针对性的选择某一方面进行参考。</p><h2 id="框架或规范约束"><a href="#框架或规范约束" class="headerlink" title="框架或规范约束"></a>框架或规范约束</h2><ol><li>组件名推荐统一使用<code>kebab-case</code>(连字符式)，因为HTML对大小写不敏感，无法识别<code>PascalCase</code>(驼峰式)。</li><li>组件的 <code>data</code> 属性的值必须是返回一个对象的函数，如果直接用一个数据对象，则组件的多个实例之间会产生数据污染，导致失去复用价值。</li><li>组件的<code>Prop</code>在声明时推荐使用<code>PascalCase</code>(驼峰式)，但在模板中必须使用<code>kebab-case</code>(连字符式)，原因同样是因为HTML对大小写不敏感。</li></ol><h2 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h2><ol><li><code>v-for</code>必须配合<code>key</code>使用，可以提高部分情况下Vue的渲染性能。</li><li><code>scoped</code> 样式中避免使用元素选择器，因为遍历元素的效率通常很低。</li></ol><h2 id="健壮性相关"><a href="#健壮性相关" class="headerlink" title="健壮性相关"></a>健壮性相关</h2><ol><li>组件名必须为多个单词，避免与未来的HTML元素冲突，配合<strong>框架或规范约束</strong>第一条理解。</li><li>组件样式必须设置作用域，避免样式冲突，单文件组件可以选择使用<code>scope</code>特性，通用组件可以选择基于class的规则，例如<a href="http://getbem.com/" target="_blank" rel="external">BEM</a>。</li><li>对于混合到Vue对象中的全局资源使用<code>$_</code>前缀，避免与未来版本的Vue属性冲突，必要时可以再添加一个命名空间，避免与其他插件属性冲突。</li><li>组件命名规则：基础组件加特定前缀预示复用性，例如<code>Base</code>；单例组件用<code>The</code>前缀标识预示唯一性；耦合组件中的子组件使用父组件名做前缀预示耦合关系，例如<code>TodoList</code>和<code>TodoListItem</code>；相关组件命名用一般性描述单词开头，用修饰性单词结尾，例如<code>ColorPicker</code>、<code>ColorPickerMulti</code>、<code>ColorPickerQuery</code>。</li><li>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法，因为计算属性和方法利于复用和重构，而且模板也会看起来也更清晰易懂。</li></ol><h2 id="可读性相关"><a href="#可读性相关" class="headerlink" title="可读性相关"></a>可读性相关</h2><ol><li>组件的<code>Prop</code> 定义应该尽量详细，至少要定义类型，利于开发期间调试和提高组件代码可读性。</li><li>推荐用单文件的方式组织组件，利于提高单个组件的编辑查阅效率，即使不使用构建工具，也可以<a href="//refined-x.com/2017/10/28/%E5%A6%82%E4%BD%95%E4%B8%8D%E7%94%A8%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E9%A1%B9%E7%9B%AE/">变通的使用单文件组件开发方式</a>。</li><li>组件文件的命名推荐<code>kebab-case</code>(连字符式)，与组件名写法一致。</li><li>在除了DOM模板以外的任何地方使用自闭合组件写法，使代码更简洁，例如<code>&lt;my-component/&gt;</code>。</li><li>组件命名应使用完整单词，避免歧义。</li><li>拥有多个特性的元素应该分多行撰写，每个特性一行。</li><li>指令缩写要么一直用要么一直不用，提高模板可读性。</li><li>项目中的组件/实例选项声明顺序保持一致，推荐的顺序如下：<code>el,name,parent,functional,delimiters,comments,components,directives,filters,extends,mixins,inheritAttrs,model,props/propsData,data,computed,watch,lifeCircleHooks,methods,template/render,renderError</code>。</li><li>项目中的元素属性书写顺序保持一致。</li></ol><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>指南中的绝大多数优化项都是针对代码健壮性和可读性提出的，基本也都是比较普遍的最佳实践方式，对于有一定经验的开发者来说应该都是很熟悉的内容，或者早已形成了自己的一套习惯，如果部分条目与你所熟知的方式相违背，也不需要过于纠结，只要明确了选择背后的利弊，那就是你的“最佳实践”。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/11/16/Vue2.0%E5%BC%80%E5%8F%91%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>如何不用构建工具开发Vue全家桶项目</title>
      <link>https://refined-x.com/2017/10/28/%E5%A6%82%E4%BD%95%E4%B8%8D%E7%94%A8%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E9%A1%B9%E7%9B%AE/</link>
      <guid>https://refined-x.com/2017/10/28/%E5%A6%82%E4%BD%95%E4%B8%8D%E7%94%A8%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E9%A1%B9%E7%9B%AE/</guid>
      <pubDate>Sat, 28 Oct 2017 08:40:19 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;Vue是目前最流行的前端开发框架之一，与Vue-router和Vuex组成俗称的Vue全家桶，更是开发前端富交互应用的利器。配合webpack等构建工具，开发大型应用也可以得心应手。随着Vue的普及，可能一些老旧项目也希望能“渐进式”的使用Vue，或者有的项目想用Vue来做
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>Vue是目前最流行的前端开发框架之一，与Vue-router和Vuex组成俗称的Vue全家桶，更是开发前端富交互应用的利器。配合webpack等构建工具，开发大型应用也可以得心应手。随着Vue的普及，可能一些老旧项目也希望能“渐进式”的使用Vue，或者有的项目想用Vue来做但不打算引进构建工具，这种情况该怎样愉快的开发Vue全家桶项目呢？本文将提供一种解决方案。</p><h2 id="构建工具的意义"><a href="#构建工具的意义" class="headerlink" title="构建工具的意义"></a>构建工具的意义</h2><p>首先应该明白构建工具的意义，是为了更好的实现模块化开发。具体来说就是开发的时候“拆”，发布的时候“合”，从而实现以模块为单位的关注点分离，以解决前端项目越来越庞大的背景下，单一开发者很难同时统筹项目所有细节的问题。具体来说都“拆”了什么，无非以下两方面：</p><ul><li>静态资源</li><li>业务模块</li></ul><p>静态资源的打包构建不是什么新鲜东西，编译啊合并啊压缩啊，都是老生常谈。</p><p>业务模块的拆分才是开发大型Vue项目的关键，也是构建工具在这里存在的最大意义。例如基于webpack使用Vue的单文件组件功能，使一个组件的所有部分（样式、模板、逻辑）都集中在一个<code>.vue</code>文件中管理，非常的方便。</p><p>除此之外构建工具通常还额外提供一些别的小恩小惠，比如实时刷新、代码压缩、md5戳等等，都不是很重要，替代方案也很多，这里就忽略它们了。</p><h2 id="如何优雅的摆脱构建工具"><a href="#如何优雅的摆脱构建工具" class="headerlink" title="如何优雅的摆脱构建工具"></a>如何优雅的摆脱构建工具</h2><p>不用构建工具不难，难的是同时实现模块化，没有构建工具的帮助，我们就要自己解决组件及依赖资源的互相引用和加载。核心思路是利用Vue的异步组件特性，借助前端模块加载器实现组件按需加载，只要能通过一个异步请求返回正确的组件对象，我们仍然可以以文件的形式组织组件！</p><p>下面就通过一个小例子来讲解具体如何实现这个方案。示例中用seajs作为加载器，对于借助seajs实现前端模块化开发另一篇讨论参见这里：<a href="//refined-x.com/2017/06/16/Webpack%E6%98%AF%E7%AD%94%E6%A1%88%E5%90%97/">Webpack是答案吗</a>。</p><p>本文不对Vue全家桶及相关类库的使用做讲解，这部分内容请自行查阅文档。示例项目的完整代码及预览地址见文末链接。</p><h3 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h3><p>项目文件被分成两类，一类是通过加载器加载的，一类的是页面文件中直接引用的，为了开发方便应该尽可能将所有文件做模块化改造，但有一部分文件不适合也没有必要，比如类库，项目通用样式，图片文件等，所以这些文件被单独拎出来，项目的整体结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|-- src/                       //模块化文件</span><br><span class="line">|    |-- assets/</span><br><span class="line">|    |-- component/</span><br><span class="line">|    |-- plugin/</span><br><span class="line">|    |-- store/</span><br><span class="line">|    |-- app.js</span><br><span class="line">|    `-- router.js</span><br><span class="line">|-- static/                   //非模块化文件</span><br><span class="line">|    |-- lib/</span><br><span class="line">|    |-- css/</span><br><span class="line">|    |-- font/</span><br><span class="line">|    `-- images/</span><br><span class="line">·-- index.html                 //入口页面</span><br></pre></td></tr></table></figure><h3 id="文件加载"><a href="#文件加载" class="headerlink" title="文件加载"></a>文件加载</h3><p>非模块化文件基本都是各种类库，主要是在入口页面中引用，没什么可说的，对于项目“本体”来说，已经彻底实现了模块化改造，可以说项目中的“一切皆是模块”。</p><p>访问入口页面会加载包括Vue三件套、seajs以及其他类库，然后seajs会加载并执行入口模块<code>app.js</code>，在入口模块中完成Vue实例的创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//app.js 部分代码</span><br><span class="line">const router = require(&apos;js/router&apos;);</span><br><span class="line">const store = require(&apos;js/store/store&apos;);</span><br><span class="line"></span><br><span class="line">let app = new Vue(&#123;</span><br><span class="line">el: &apos;#app&apos;,</span><br><span class="line">router,</span><br><span class="line">store,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>创建实例后会启动路由并跳转首页，路由中使用异步组件，此时会发起请求加载首页的路由组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//router.js 部分代码</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">base: seajs.root,</span><br><span class="line">routes: [&#123;</span><br><span class="line">path: &apos;/&apos;,</span><br><span class="line">component: function (resolve, reject) &#123;</span><br><span class="line">require.async(&apos;js/component/main&apos;, function(main)&#123;</span><br><span class="line">resolve(main);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;,</span><br><span class="line">children: [&#123;</span><br><span class="line">path: &apos;/channel/:cid&apos;,</span><br><span class="line">children: [&#123;</span><br><span class="line">path: &apos;type/:tid&apos;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;]</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>创建实例的同时<code>store</code>也同时初始化完成了，<code>store</code>的”actions”,”getters”,”mutations”各部分的实现比较简单，请直接参考项目源码。</p><p>到这里项目就启动完成了。</p><h3 id="组件的实现"><a href="#组件的实现" class="headerlink" title="组件的实现"></a>组件的实现</h3><p>上一小节是从宏观角度描述项目如何启动以及组件如何被加载，这里着重看一下Vue组件文件该如何实现。</p><p>一个Vue组件本质上是一个包含特定属性的对象，比如它可以包含<code>template</code>,<code>components</code>,<code>created</code>等等属性，因此只要是能返回这种对象的模块化文件，就已经是一个低配版的单文件组件了，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">template: `hello $&#123;name&#125;!`,</span><br><span class="line">data() &#123;</span><br><span class="line">    name: &apos;Vue&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件中很有可能还需要依赖其他资源，比如样式，比如插件，或者其他子组件，也都很容易通过加载器实现，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line">const box = require(&apos;box&apos;);     //加载插件</span><br><span class="line">const wilddogApp = require(&apos;js/assets/wilddog&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">template: `&lt;div class=&quot;body flex-col&quot;&gt;</span><br><span class="line">    &lt;v-head&gt;&lt;/v-head&gt;</span><br><span class="line">    &lt;div class=&quot;flex-1 flex-col main&quot;&gt;</span><br><span class="line">        &lt;v-nav&gt;&lt;/v-nav&gt;</span><br><span class="line">        &lt;v-body&gt;&lt;/v-body&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;`,</span><br><span class="line">components: &#123;</span><br><span class="line">&quot;v-head&quot;: require(&apos;js/component/head&apos;), //加载子组件</span><br><span class="line">&quot;v-nav&quot;: require(&apos;js/component/nav&apos;),</span><br><span class="line">&quot;v-body&quot;: require(&apos;js/component/body&apos;)</span><br><span class="line">&#125;,</span><br><span class="line">created: function() &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果组件希望独立管理自己的样式，seajs也有加载css的解决方案，可以参考<code>src/plugin/dropdown.js</code>里的实现。但就做不到<code>.vue</code>文件里的”scoped”特性了，这方面就需要开发者自己约定命名空间来避免冲突了。</p><h3 id="插件的实现"><a href="#插件的实现" class="headerlink" title="插件的实现"></a>插件的实现</h3><p>与Vue组件类似，Vue插件本质上是一个包含”install”属性的对象，因此一个模块化的Vue插件大概是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">install: function(Vue, options) &#123;</span><br><span class="line">Vue.mixin(&#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在全局方法<code>Vue.mixin</code>中就可以具体实现我们的插件功能了，这个插件可以这样被加载并调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const Dropdown = require(&apos;js/plugin/dropdown&apos;);</span><br><span class="line">Vue.use(Dropdown);</span><br></pre></td></tr></table></figure><p>由于插件本质上还是调用<code>Vue.mixin</code>方法，因此如果你的插件不需要参数的话，也可以省掉<code>install</code>这一层包装，这样插件模块一旦加载就会生效，也不需要调用<code>Vue.use()</code>方法了，效果一样。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这个方案有明显的局限和短板，主要是由于组件加载会发起大量的请求，使项目整体运行效率受到影响，因此需要着重强调的是，组件最好不要一次同步加载，尽量的使用异步组件，分散各界面的加载压力，另外配合<a href="//refined-x.com/2017/06/16/Webpack%E6%98%AF%E7%AD%94%E6%A1%88%E5%90%97/">恰当的缓存方案</a>，效果应该也不错。</p><p>项目代码：<a href="https://github.com/tower1229/WidgetsPlayground" target="_blank" rel="external">https://github.com/tower1229/WidgetsPlayground</a><br>预览地址：//refined-x.com/WidgetsPlayground/</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/10/28/%E5%A6%82%E4%BD%95%E4%B8%8D%E7%94%A8%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91Vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E9%A1%B9%E7%9B%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title>RESTful学习及应用</title>
      <link>https://refined-x.com/2017/09/22/RESTful%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%BA%94%E7%94%A8/</link>
      <guid>https://refined-x.com/2017/09/22/RESTful%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%BA%94%E7%94%A8/</guid>
      <pubDate>Fri, 22 Sep 2017 09:31:42 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;RESTful是什么&quot;&gt;&lt;a href=&quot;#RESTful是什么&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="RESTful是什么"><a href="#RESTful是什么" class="headerlink" title="RESTful是什么"></a>RESTful是什么</h2><p>RESTful是一种API架构，符合REST设计原则的API都可以被称为RESTful，REST的全称是<em>Representational State Transfer</em>。</p><p>REST的核心原则是后端将资源发布为URI，前端通过URI访问资源，并通过HTTP动词表示要对资源进行的操作，典型的RESTful API长这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /article           //增加一篇文章</span><br><span class="line">DELETE /article/1       //删除id为1的文章</span><br><span class="line">PUT /article/1          //修改id为1的文章</span><br><span class="line">GET /articles/1         //查询id为1的文章</span><br></pre></td></tr></table></figure><p>这里需要明确一个概念：<strong>资源</strong>，后端提供的所有内容都可以被定义为资源，前端用户的一切行为，本质都是与一系列后端资源互动的结果。从这个角度来讲，前端的意义就是连接用户与资源，使用户能以最简单的方式调度后端资源，并将调度结果以用户最容易接受的方式呈现出来。</p><h2 id="为什么使用RESTful"><a href="#为什么使用RESTful" class="headerlink" title="为什么使用RESTful"></a>为什么使用RESTful</h2><p>前后端分离的本质是前后端以API为界限进行开发解耦，所以前后端分离的副产品是大量的API，采用RESTful架构可以让API的表现力更强，更易于被理解；对于接口开发来说，RESTful风格也更易于扩展，这对于大型项目非常重要。</p><p>RESTful是无状态的，因此无论前端是什么设备，前端是什么状态，都可以无差别的请求资源，有利于后端实现分布式。</p><p>RESTful允许前端索取指定格式的信息，因此可以实现一套统一的API服务于不同的前端设备。</p><h2 id="如何构建RESTful-API"><a href="#如何构建RESTful-API" class="headerlink" title="如何构建RESTful API"></a>如何构建RESTful API</h2><h3 id="一、每个网址代表一种资源，网址中只能有名词"><a href="#一、每个网址代表一种资源，网址中只能有名词" class="headerlink" title="一、每个网址代表一种资源，网址中只能有名词"></a>一、每个网址代表一种资源，网址中只能有名词</h3><p>网址仅用来表示资源的名称，而不包括操作，因此只能由名词组成；但有些资源可能自带操作属性，比如转账，这时候我们应该将转账看成一种服务（名词），将转账的其他信息作为参数传递</p><h3 id="二、对于资源的操作类型由HTTP动词表示"><a href="#二、对于资源的操作类型由HTTP动词表示" class="headerlink" title="二、对于资源的操作类型由HTTP动词表示"></a>二、对于资源的操作类型由HTTP动词表示</h3><p>常用的四种HTTP动词以及对应的SQL操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET（SELECT）：从服务器取出资源（一项或多项）。</span><br><span class="line">POST（CREATE）：在服务器新建一个资源。</span><br><span class="line">PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）</span><br><span class="line">DELETE（DELETE）：从服务器删除资源。</span><br></pre></td></tr></table></figure><h3 id="三、统一的返回结果"><a href="#三、统一的返回结果" class="headerlink" title="三、统一的返回结果"></a>三、统一的返回结果</h3><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /collection：返回资源对象的列表（数组）</span><br><span class="line">GET /collection/resource：返回单个资源对象</span><br><span class="line">POST /collection：返回新生成的资源对象</span><br><span class="line">PUT /collection/resource：返回完整的资源对象</span><br><span class="line">PATCH /collection/resource：返回完整的资源对象</span><br><span class="line">DELETE /collection/resource：返回一个空文档</span><br></pre></td></tr></table></figure><h3 id="四、返回正确的状态码"><a href="#四、返回正确的状态码" class="headerlink" title="四、返回正确的状态码"></a>四、返回正确的状态码</h3><p>常用状态码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">200 ：服务器成功返回用户请求的数据</span><br><span class="line">400 ：用户发出的请求有错误</span><br><span class="line">401 ：表示用户没有权限</span><br><span class="line">403 : 表示用户得到授权（与401错误相对），但访问被禁止的</span><br><span class="line">404 ：用户发出的请求针对的是不存在的记录</span><br><span class="line">500 ：服务器发生错误，用户无法判断发出的请求是否成功</span><br></pre></td></tr></table></figure><h3 id="五、允许通过HTTP内容协商"><a href="#五、允许通过HTTP内容协商" class="headerlink" title="五、允许通过HTTP内容协商"></a>五、允许通过HTTP内容协商</h3><p>客户端可以通过Accept头请求一种特定格式的表述，服务端则通过Content-Type告诉客户端资源的表述形式。若服务器不支持，它应该返回一个HTTP 406响应，表示拒绝处理该请求。</p><p>通常项目中最常用的还是直接预定为JSON格式。</p><h2 id="web端的应用"><a href="#web端的应用" class="headerlink" title="web端的应用"></a>web端的应用</h2><p>目前最流行的web端AJAX类库当属axios，axios与RESTful完美兼容，主要体现在以下几个方面。</p><p>axios将HTTP动词直接封装为方法，正好对应RESTful的API风格，在RESTful架构中使用起来非常方便</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.post(`/article`, params)</span><br><span class="line">axios.delete(`/article/1`, params)</span><br><span class="line">axios.put(`/article/1`, params)</span><br><span class="line">axios.get(`/article/1`, params)</span><br></pre></td></tr></table></figure><p>而且axios的返回数据包括响应正文和状态码等信息，配合拦截器很容易实现对RESTful API错误码的统一处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//错误处理</span><br><span class="line">axios.interceptors.response.use(function(response) &#123;</span><br><span class="line">  return response;</span><br><span class="line">&#125;, function(error) &#123;</span><br><span class="line">  if (error.response) &#123;</span><br><span class="line">    switch (error.response.status) &#123;</span><br><span class="line">      case 400:</span><br><span class="line">        </span><br><span class="line">        break;</span><br><span class="line">      case 401:</span><br><span class="line">        </span><br><span class="line">        break;</span><br><span class="line">      case 403:</span><br><span class="line">        </span><br><span class="line">        break;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>更多axios内容参考<a href="https://www.npmjs.com/package/axios" target="_blank" rel="external">这里</a>。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>其实RESTful的绝大多数内容都是规范推荐的做法，没有什么新东西，只不过前几年后端MVC盛行的时期，没有这么重的API开发需求，在这方面就一切从简了，近来赶上前后端分离的东风，API设计又被大家重视起来了，重回规范的RESTful相当于让大家见识了一下当年规范制定者们的远见卓识，就像小时候不听话的孩子在长大的某一天里突然想起来长辈曾经的教诲一样。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/09/22/RESTful%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%BA%94%E7%94%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>纯前端实现人脸识别-提取-合成</title>
      <link>https://refined-x.com/2017/09/06/%E7%BA%AF%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-%E6%8F%90%E5%8F%96-%E5%90%88%E6%88%90/</link>
      <guid>https://refined-x.com/2017/09/06/%E7%BA%AF%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-%E6%8F%90%E5%8F%96-%E5%90%88%E6%88%90/</guid>
      <pubDate>Wed, 06 Sep 2017 01:10:07 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;最近火爆朋友圈的军装照H5大家一定还记忆犹新，其原理是先提取出照片中的面部，然后与模板进行合成，官方的合成处理据说由&lt;em&gt;天天P图&lt;/em&gt;提供技术支持，后端合成后返回给前端展示，形式很新颖效果也非常好，整个流程涉及的人脸识别和图像合成两项核心技术在前端都有对应的解决方案
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>最近火爆朋友圈的军装照H5大家一定还记忆犹新，其原理是先提取出照片中的面部，然后与模板进行合成，官方的合成处理据说由<em>天天P图</em>提供技术支持，后端合成后返回给前端展示，形式很新颖效果也非常好，整个流程涉及的人脸识别和图像合成两项核心技术在前端都有对应的解决方案，因此理论上前端也可以完成人脸识别-提取-合成整个流程，实现纯前端的军装照H5效果。</p><h2 id="前端人脸识别"><a href="#前端人脸识别" class="headerlink" title="前端人脸识别"></a>前端人脸识别</h2><p>首先需要的是人脸识别，这个一听就觉得高大上的东西原理并不深奥，无非是用人的面部特征规则对图像进行匹配和识别，这项工作前端虽然可以实现，但前端实现基本就只能依据内置规则库进行匹配，这个库的质量就决定了识别质量，而通常更成熟的方案是引入机器学习，让程序不断自我修正和提高，进一步提高识别率，机器学习的前端库倒是也有，但把这两者结合起来的还没发现，因此对前端人脸识别的准确率不要报太高期望。</p><p>现有的前端人脸识别库不算多，这里我们选择的是效果相对好点的<a href="https://trackingjs.com/" target="_blank" rel="external">trackingjs</a>，这个类库功能非常强大，库如其名，它可以完成各种追踪类的图像处理任务，人脸识别只是其众多功能之一，而且通过选配插件，还可以精确识别眼睛、鼻子等五官的位置，貌似稍微折腾一下也可以实现<em>美图秀秀</em>的效果。</p><p>这里我们只用<code>trackingjs</code>实现面部识别，初始化一个面部识别任务的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//实例化</span><br><span class="line">var tracker = new tracking.ObjectTracker([&apos;face&apos;]);</span><br><span class="line">//识别回调</span><br><span class="line">tracker.on(&apos;track&apos;, function(event) &#123;</span><br><span class="line">    if (!event.data.length) &#123;</span><br><span class="line">        return console.log(&apos;画面中没有人脸&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    event.data.forEach(function(rect, i) &#123;</span><br><span class="line">        console.log(rect);//单个面部数据</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">//配置参数</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这样一个面部识别任务就初始化完成了，调用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tracking.track(&apos;#img&apos;, tracker);</span><br><span class="line">//其中&apos;#img&apos;参数是目标图像的选择器</span><br></pre></td></tr></table></figure><p>在识别回调中<code>event.data</code>就是数组格式的面部数据，如果长度为0则表示图像中没有人脸或者识别失败，如果识别成功，单个面部数据的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    x: number,          //面部位于原图x轴方向位置</span><br><span class="line">    y: nuber,           //面部位于原图y轴方向位置</span><br><span class="line">    width:number,       //面部区域宽度</span><br><span class="line">    height:nubmer       //面部区域高度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个面部数据就可以很容易的将该区域从原图中提取出来，前端当然就用<code>canvas</code>啦，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var img = document.getElementById(&quot;img&quot;);</span><br><span class="line">var faceCtx = document.getElementById(&quot;mycanvas&quot;).getContext(&apos;2d&apos;);</span><br><span class="line"></span><br><span class="line">var theFace = ...; //假设我们识别到了theFace</span><br><span class="line"></span><br><span class="line">//使用drawImage()方法将面部绘制出来</span><br><span class="line">faceCtx.drawImage(img, theFace.x, theFace.y, theFace.width, theFace.height, 0, 0, theFace.width, theFace.height);</span><br></pre></td></tr></table></figure><p>到这里我们已经实现了面部识别 + 提取，而且代码量也没多少，其实这里面有个小坑要在实践中才会发现，那就是<code>trackingjs</code>的配置，文档中能找到4个跟识别有关的配置，分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setClassifiers(classifiers)</span><br><span class="line">setEdgesDensity(edgesDensity)</span><br><span class="line">setScaleFactor(scaleFactor)</span><br><span class="line">setStepSize(stepSize)</span><br></pre></td></tr></table></figure></p><p>看不懂吧，我也看不懂，而且文档中对他们没有任何有用的说明，在测试中我只使用了后两个配置，翻译过来分别是”比例因子”和”步长”，经过枯燥的人肉测试发现，这两个参数的有效取值范围分别在<code>1 - 2</code>和<code>1.1 - 2</code>，其中<code>setStepSize</code>不能为<code>1</code>，否则会浏览器会卡死，所以从1.1开始取值，取值超过2也可以，但识别成功的概率就很低了。通过调整这两个参数绝大多数图像都可以成功识别，唯独对面部大特写很难识别，这可能需要配合另外两个参数吧，我实在没耐心继续人肉测试下去了，感兴趣的自己回去玩吧。</p><h2 id="前端图像处理"><a href="#前端图像处理" class="headerlink" title="前端图像处理"></a>前端图像处理</h2><p>经过上一步的识别+提取我们已经得到了面部图像，要实现合成军装照效果我们还需要对面部图像进行处理，使色调与模板一致，将来才能毫无违和感的融合在一起，具体到军装照这个例子我们需要将面部重新着色，并达到”做旧”的老照片效果，如果用PS想必大家都会，但在前端怎么实现呢？</p><p>这里我们需要借助腾讯前端团队出品的<a href="http://alloyteam.github.io/AlloyImage/" target="_blank" rel="external">AlloyImage</a>，这是一个堪称<em>前端PS</em>的前端图像处理类库，比如要实现上述效果，我们只需要这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var faceImg = document.getElementById(&quot;theFace&quot;);</span><br><span class="line">faceImg.loadOnce(function() &#123;</span><br><span class="line">    AlloyImage(this).act(&quot;灰度处理&quot;).add(</span><br><span class="line">        AlloyImage(this.width, this.height, &quot;#808080&quot;)</span><br><span class="line">        .act(&quot;高斯模糊&quot;, 4)</span><br><span class="line">        .act(&quot;色相/饱和度调节&quot;, 22, 45, 0, true),</span><br><span class="line">        &quot;叠加&quot;</span><br><span class="line">    ).replace(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你就得到了一个做旧的人脸，还是非常简单的，AlloyImage的使用基本可以说是傻瓜化，感兴趣的就自己花个五分钟去看下官方文档吧，这里不再赘述。</p><p>然后就要说一下我们这个图像处理和人家<em>天天P图</em>的差距了，虽然我们得到了理想的色调，但要想把随便一张人脸与特定模板做合成，有两件事必不可少。首先是面部角度矫正，如果模板是正的而你的照片是歪的，直接暴力拼接肯定很违和，所以需要先识别出面部角度，并纠正到指定角度；然后是面部中心定位，因为人脸识别的结果提取出来后不一定是以面部中心为中心的，所以在合成之前要识别出面部中心线，并以此为依据与模板进行定位。然而这些我们都没有，所以我们只能对输入的图像的要求更高，如果输入了嘴歪眼斜的图片，结果就只能尴尬了。</p><p>最后的图片合成部分就更简陋了，先将处理好的面部画到画布指定位置，然后将抠好图的脸部透明png模板铺在上面，完成。实际过程中需要处理一些小问题，比如要根据模板的面部尺寸将面部图像缩放到合适的尺寸；抠模板时要将边缘模糊处理，而且尽量保留模板本来的面部轮廓，只将五官抠掉。即便这样，合成结果还是很容易穿帮，不过纯前端处理也没有更好的办法了。</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>好了，说的再多不如看个例子，示例提供三种图片输入源，分别是本地图片、远程图片、内置示例。其中内置的图片大部分是提前在PS中纠正过角度的，而且内置图片会自动匹配到我事先调校好的参数，不出意外可以直接识别出人脸；如果选择本地图片作为图片源，最好选择头部姿态垂直的正面照，同时参考内置图片的 参数设置调节参数，一次识别不成功很正常，需要多调几次；也可以使用远程图片识别，但因为canvas受到跨域策略影响，远程图片只能识别不能提取和合成。</p><p>示例：<a href="//refined-x.com/projects/codes/tracking.html">纯前端军装照合成</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最初是抱着好奇的心态开始捣鼓这个项目的，虽然最终的合成效果远远达不到生产要求，但整个示例撸下来后对人脸识别和图片处理技术都有了基本的认识，对canvas操作中一些细节问题的解决也略微补足了一下这方面的知识空白，算略有收获吧。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/09/06/%E7%BA%AF%E5%89%8D%E7%AB%AF%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB-%E6%8F%90%E5%8F%96-%E5%90%88%E6%88%90/#disqus_thread</comments>
    </item>
    
    <item>
      <title>用addRoutes实现动态路由</title>
      <link>https://refined-x.com/2017/09/01/%E7%94%A8addRoutes%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/</link>
      <guid>https://refined-x.com/2017/09/01/%E7%94%A8addRoutes%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/</guid>
      <pubDate>Fri, 01 Sep 2017 02:25:16 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;之前在&lt;a
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>之前在<a href="//refined-x.com/2017/08/29/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/">基于Vue实现后台系统权限控制</a>一文中提到路由权限的实现思路，因为不喜欢在每次路由跳转的before钩子里做判断，所以在初始化Vue实例前对路由做了筛选，再用实际路由初始化Vue实例，代价是登录页需要从Vue实例中独立出来，实现上倒没什么问题，不过这种做法需要在登录和首页之间通过url跳转，感觉总是不太”优雅”，实际上只要能在登录后动态修改当前实例的路由就行了，之前确实没办法，但vue-router 2.2版本新增了一个<code>router.addRoutes(routes)</code>方法，让动态路由得以实现。</p><h2 id="想当然的实现方案"><a href="#想当然的实现方案" class="headerlink" title="想当然的实现方案"></a>想当然的实现方案</h2><p>用动态路由实现路由权限控制貌似是一个完美的方案，初始路由只有登录和404，登录后动态添加可用路由，同时将菜单数据保存到Vuex或本地用于实现动态菜单，关键节点大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//初始路由：</span><br><span class="line">[&#123;</span><br><span class="line">  path: &apos;/login&apos;,</span><br><span class="line">  name: &apos;login&apos;,</span><br><span class="line">  component: (resolve) =&gt; require([&apos;../views/common/404.vue&apos;], resolve)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  path: &apos;/404&apos;,</span><br><span class="line">  name: &apos;404&apos;,</span><br><span class="line">  component: (resolve) =&gt; require([&apos;../views/common/404.vue&apos;], resolve)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  path: &apos;*&apos;,</span><br><span class="line">  redirect: &apos;/404&apos;</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line">//登录逻辑</span><br><span class="line">let vm = this;</span><br><span class="line">axios.get(&apos;/login&apos;, vm.user).then((res) =&gt; &#123;</span><br><span class="line">    let extendsRoutes = filterRoutes(res.menus); </span><br><span class="line">    &lt;!--</span><br><span class="line">    //假设得到的可用路由如下</span><br><span class="line">    [&#123;</span><br><span class="line">      path: &apos;/&apos;,</span><br><span class="line">      name: &apos;首页&apos;,</span><br><span class="line">      component: (resolve) =&gt; require([&apos;../views/index.vue&apos;], resolve),</span><br><span class="line">      children: [&#123;</span><br><span class="line">        path: &apos;/menus&apos;,</span><br><span class="line">        name: &apos;菜单管理&apos;,</span><br><span class="line">        component: (resolve) =&gt; require([&apos;../views/menus.vue&apos;], resolve)</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        path: &apos;/resources&apos;,</span><br><span class="line">        name: &apos;资源管理&apos;,</span><br><span class="line">        component: (resolve) =&gt; require([&apos;../views/resources.vue&apos;], resolve)</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;]--&gt;</span><br><span class="line">    //存菜单</span><br><span class="line">    sessionStorage.setItem(&apos;menus&apos;,JSON.stringify(extendsRoutes[0].children));</span><br><span class="line">    //动态添加路由</span><br><span class="line">    vm.$router.addRoutes(extendsRoutes);</span><br><span class="line">    //跳转到应用界面</span><br><span class="line">    vm.$router.push(&#123;path:&apos;/&apos;&#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//首页获取菜单数据</span><br><span class="line">this.menus = JSON.parse(sessionStorage.getItem(&apos;menus&apos;)); </span><br><span class="line">//用此数据循环菜单</span><br><span class="line">..</span><br></pre></td></tr></table></figure><p>目前为止看上去一切顺利，然而前方有坑。</p><h2 id="动态路由的坑"><a href="#动态路由的坑" class="headerlink" title="动态路由的坑"></a>动态路由的坑</h2><p>第一个坑是，如果你将这套逻辑实现之后会发现打开应用看到的第一个页面是404，这是因为启动服务后将默认打开首页’/‘，然而初始路由中没有这个路径，因此根据路由规则跳转到了404。我们希望结果当然是跳转到’/login’，因此需要对这种情况做判断，在用户登录之前所有请求都要指向’/login’，这个判断可以在before钩子里做也可以在根组件里做，建议做在根组件的created回调里，核心代码大概这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let isLogin = sessionStorage.getItem(&apos;user&apos;);</span><br><span class="line">if(!isLogin)&#123;</span><br><span class="line">    return this.$router.push(&#123;path:&apos;/login&apos;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候已经可以顺利登录了，登录后很快就会发现第二个坑，手动刷新页面又会跳到404，这是因为刷新会导致Vue重新实例化，路由也恢复到了初始路由，于是当前路径又被重定向到了404，这个问题的根源是可用路由没有实现持久化，那么可以通过将路由数据存sessionStorage来解决，实例化之前如果检测到本地路由就直接合并路由，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//检测本地路由</span><br><span class="line">let localRoutes = sessionStorage.getItem(&apos;routes&apos;);</span><br><span class="line">if(localRoutes)&#123;</span><br><span class="line">    router.addRoutes(JSON.parse(localRoutes));</span><br><span class="line">&#125;</span><br><span class="line">//实例化</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  router,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>理论上可以，但实际操作要远比上述代码复杂，因为存在本地的只能是权限数据而不是真实路由，路由在存、取之前都要先根据权限匹配获得，过程还是挺繁琐的，而且必须依赖sessionStorage这种持久存储，没有其他方法。问题就出在这个sessionStorage上，原则上权限只能在内存变量中流转，不能直接暴露到用户可操作的地方，试想只要用户手动修改了sessionStorage里的权限，再刷新一下页面就能突破前端路由控制了，非常的不靠谱。</p><h2 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h2><p>既然不能存本地，那就每次刷新都重新从服务端获取，所以改进后的方案是本地存用户token，每次刷新要凭token从服务端重新获取用户信息和权限，然后动态更新路由，获取权限操作可以跟登录检测一起放在根组件的created回调中进行，确保访问任何路径都会先执行这一步，但因为获取权限是异步操作，在此之前仍然会经过应用初始化，所以还是会遇到404的问题，为此我们只需做一个小调整，将不匹配路径(‘*’)跳404的路由从初始路由中移除，动态更新路由时再把这个配置加进去，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let userPath = ...//我们的动态路由</span><br><span class="line">//注入时拼接404处理路由</span><br><span class="line">this.$router.addRoutes(userPath.concat([&#123;</span><br><span class="line">  path: &apos;*&apos;,</span><br><span class="line">  redirect: &apos;/404&apos;</span><br><span class="line">&#125;]));</span><br></pre></td></tr></table></figure><p>这样就解决了刷新问题，后面还有几个小问题就简单了。</p><p>首先是菜单，之前通过<code>$router.options.routes</code>访问路由数据实现动态菜单，但这个数据不是响应式的，无法追踪动态路由的变化，因此我们需要将得到的导航菜单数据存到sessionStorage或Vuex里实现数据共享。</p><p>资源权限控制也受到很大的影响，实现较为细致的权限控制需要一个自定义权限验证指令和一个全局验证方法，之前的方案里权限是在Vue实例化之前获取的，所以可以很方便的拿到权限后实现验证方法，然后用验证方法实现自定义指令，再将方法全局混合进Vue，然后实例化，这样实例中的 所有组件都可以使用自定义指令和验证方法；但现在的方案是先实例化再获取权限，实例化之前根本没有权限数据，所以自定义指无法实现，等拿到权限后实现了验证方法，却无法再全局混合了。</p><p>这个问题最后也解决了，但解决方案就彻底的”有辱斯文”了，首先是全局方法的实现，直接这么做:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.has = function()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式跟全局混合的方法完全一样。</p><p>自定义指令的实现本来很头疼，因为全局指令只能在实例化之前实现，但那时候又确实没有权限，不过既然验证方法这么做的话，指令倒是也顺便解决了，像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//权限指令</span><br><span class="line">Vue.directive(&apos;has&apos;, &#123;</span><br><span class="line">  bind: function(el, binding) &#123;</span><br><span class="line">    if (!Vue.prototype.has(binding.value)) &#123;</span><br><span class="line">      el.parentNode.removeChild(el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>神奇的<code>prototype</code>貌似自带惰性效果，可以先注册后实现，具体原因我也不太明白，如过有大牛路过，希望能留下答案。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>生命不息，折腾不止啊，本来已经放弃的思路，捋着捋着竟然捋顺了，然后又花了大半天把原来多入口的项目改成了单入口，虽然麻烦了一顿，但心里总算舒坦了。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/09/01/%E7%94%A8addRoutes%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>基于Vue实现后台系统权限控制</title>
      <link>https://refined-x.com/2017/08/29/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</link>
      <guid>https://refined-x.com/2017/08/29/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</guid>
      <pubDate>Tue, 29 Aug 2017 01:28:27 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本文中的菜单权限控制方案由于没有使用<code>router.addRoutes()</code>实现动态路由，需要将登录页独立出来单独做，基于相同思路的动态路由方案参见]<a href="//refined-x.com/2017/09/01/%E7%94%A8addRoutes%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/">用addRoutes实现动态路由</a>。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>用Vue这类双向绑定框架做后台系统再适合不过，后台系统相比普通前端项目除了数据交互更频繁以外，还有一个特别的需求就是对用户的权限控制，那么如何在一个Vue应用中实现权限控制呢？下面是我的一点经验。</p><h2 id="权限控制是什么"><a href="#权限控制是什么" class="headerlink" title="权限控制是什么"></a>权限控制是什么</h2><p>在权限的世界里服务端提供的一切都是资源，资源可以由请求方法+请求地址来描述，权限是对特定资源的访问许可，所谓权限控制，也就是确保用户只能访问到被分配的资源。具体的说，前端对资源的访问通常是由界面上的按钮发起，比如删除某条数据；或由用户进入某一个页面发起，比如获取某个列表数据。这两种形式覆盖了资源请求的大部分场景，因此权限控制也可以被笼统的分成菜单权限控制和按钮权限控制。</p><h2 id="Vue菜单权限控制"><a href="#Vue菜单权限控制" class="headerlink" title="Vue菜单权限控制"></a>Vue菜单权限控制</h2><p>菜单是对路由的直接体现，菜单控制实际上就是路由控制。实现路由控制一个简单的方式是，在路由的before钩子里校验当前即将跳转的路由地址是否有权访问，根据校验结果决定路由是否放行，伪码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">    //权限校验</span><br><span class="line">    let pass = valid(to);</span><br><span class="line">    if(!pass)&#123;</span><br><span class="line">        return console.log(&apos;无权访问&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种实现方式既简单又直观，用于路由总数不多的系统非常合适，但这么做本质上是将所有路由全部注册了，直接带来的缺点有两个：一、如果路由组件不是按需加载的话，应用将加载大量冗余代码；二、每次跳转都要遍历一次完整路由，是对计算能力的浪费。</p><p>理想的实现方式是本地保存完整路由，但并不立即初始化Vue应用，待用户登录拿到权限后，用菜单权限筛选出可用路由，再用可用路由初始化Vue应用。也就是说，要将登录页独立出去做成一个单独的页面，登录后将用户数据保存在本地，再通过url跳转到Vue应用所在页面，Vue应用启动前通过本地用户数据完成路由筛选，然后初始化Vue应用，伪码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//main.js</span><br><span class="line">let user = sessionStorage.getItem(&apos;user&apos;);</span><br><span class="line">if (user) &#123;</span><br><span class="line">    user = JSON.parse(user);</span><br><span class="line">    //筛选得到实际路由</span><br><span class="line">    let fullPath = require(&apos;fullPath.js&apos;);</span><br><span class="line">    let routes = filter(fullPath, user.menus);</span><br><span class="line">    //创建路由对象</span><br><span class="line">    let router = new Router(&#123;routes&#125;);</span><br><span class="line">    //生成Vue实例</span><br><span class="line">    new Vue(&#123;</span><br><span class="line">        el: &apos;#app&apos;,</span><br><span class="line">        router,</span><br><span class="line">        render: h =&gt; h(App)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    location.href = &apos;/login/&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们还希望能直接用路由数据生成导航菜单，常规的路由数据可能无法满足菜单组件的需求，所以我们要事先在路由的<code>meta</code>里维护上菜单数据，比如菜单名称菜单图标等，只要在模板中通过<code>$router.options</code>就可以访问到当前路由数据，如果使用element-ui的菜单组件实现，代码大致是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-menu router&gt;</span><br><span class="line">    &lt;el-menu-item v-for=&quot;(route, index) in $router.options.routes[2].children&quot;</span><br><span class="line">    :route=&quot;route&quot;</span><br><span class="line">    :index=&quot;route.name&quot;&gt;</span><br><span class="line">        &lt;i class=&quot;ion&quot; v-html=&quot;route.icon&quot;&gt;&lt;/i&gt;&#123;&#123;route.name&#125;&#125;</span><br><span class="line">    &lt;/el-menu-item&gt;</span><br><span class="line">&lt;/el-menu&gt;</span><br></pre></td></tr></table></figure><p>当然这样只能循环出一级菜单，如果还有二级路由需要对应二级菜单的话，就得判断并循环<code>children</code>节点，比较简单就不放更多代码了，菜单权限控制到这里就完成了。</p><h2 id="Vue按钮权限控制"><a href="#Vue按钮权限控制" class="headerlink" title="Vue按钮权限控制"></a>Vue按钮权限控制</h2><p>按钮权限控制与菜单权限控制的实现思路类似，也是根据用户权限判断各个按钮的显示与否，方式无非是<code>v-if</code>或自定义指令，而且只要将<code>v-if</code>背后的权限校验逻辑抽象成方法，无论是代码量还是使用形式上都跟自定义指令几乎一样，但<code>v-if</code>的特点是它会响应数据变化，因此随着应用的运行会频繁触发权限校验，而权限在应用的整个生命周期内其实只需校验一次，为了避免无谓的程序执行，这里可以用自定义指令来实现，伪码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(&apos;has&apos;, &#123;</span><br><span class="line">  bind: function (el, binding) &#123;</span><br><span class="line">    if(!has(binding.value))&#123;</span><br><span class="line">        el.parentNode.removeChild(el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//用法：</span><br><span class="line">&lt;btn v-has=&apos;get,/sources&apos;&gt;按钮&lt;/btn&gt;</span><br></pre></td></tr></table></figure><p>注意在指令<code>bind</code>回调里有一个<code>has()</code>方法，这就是权限校验方法，我们同时将这个方法全局混合到Vue对象中，使应用里的每个组件都可以访问到这个方法，便于为界面上的<code>v-if</code>提供支持，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-if=&quot;has(&apos;get,/sources&apos;) &amp;&amp; something&quot;&gt;</span><br><span class="line">    一个需要同时具备&apos;get,/sources&apos;权限和somthing为真值才显示的div</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>验证方法的实现不是本文重点，只讲大致思路，假设服务端用请求方法+请求url定义资源，如”get,/resources”，那么资源权限数据应该是由于资源组成的数组，我们需要先将数组转换成对象格式，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let permissions = &#123;</span><br><span class="line">  &quot;get,/resources&quot;:true,</span><br><span class="line">  &quot;delete,/resources&quot;:true,</span><br><span class="line">  &quot;post,/resources&quot;:true,</span><br><span class="line">  &quot;put,/resources&quot;:true,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在验证方法里就可以通过直接访问permissions的属性来确定是否拥有权限，效率远高于遍历原始权限数组，代码应该是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let has = function(permission)&#123;</span><br><span class="line">  if(!permissions[permission])&#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来凡是需要依据权限实现的按钮显隐控制和界面变化都可以很方便的实现。</p><p>但做按钮权限麻烦的地方不在于如何实现，而在于高昂的维护成本。我们假设按钮Btn绑定了点击回调Fn，回调Fn里发起了请求Req，请求Req需要某个资源的访问权限，最终你要根据用户是否拥有Req的权限决定Btn是否显示，而Req跟Btn之间并没有直接关联，所以我们就要人肉维护他们的关系，一个复杂项目里的按钮有个几十上百都很正常，随着业务的变更去维护这么多按钮的权限，想想都头疼。</p><p>有一个方法可以绕开这个烂摊子，那就是前端放弃对视图层的控制，退到请求层面，在请求发起前集中拦截，这时可以直接根据请求方法和请求地址来校验权限，除了实现一个拦截器之外不需要额外的代码，可以说非常优雅了。以<code>axios</code>为例，拦截器大概长这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(function (config) &#123;</span><br><span class="line">  let permission = config.method + config.url.replace(config.baseURL,&apos;,&apos;);</span><br><span class="line">  if(!has(permission))&#123;</span><br><span class="line">  //验证不通过</span><br><span class="line">    return Promise.reject(&#123;</span><br><span class="line">      message: `no permission`</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  return config;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但如果仅仅这样做权限控制，界面上将显示出所有的按钮，用户看到的按钮却不一定可以点击，这种体验我认为只能停留在理论层面，根本无法应用到实际产品中。请求控制可以作为整个控制体系的第二道防线，或某些特殊情况下的辅助手段，最终还是要回到按钮控制的思路上来。</p><p>那么怎样能尽可能方便的采集到每个按钮所需的权限呢？按钮和权限之间隔着两层东西，第一层是click回调，第二层是回调里的AJAX请求，不想人肉维护就得想办法突破这两层隔阂，让按钮和权限产生联系，按钮必然要绑定click事件，最理想的采集方式是在绑定事件的同时得到所需权限，让一切自然而然的发生，比如我们可以实现一个完美的<code>v-do</code>指令，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;btn v-do=&quot;Fn&quot;&gt;按钮&lt;/btn&gt;</span><br></pre></td></tr></table></figure><p>如果<code>Fn</code>能以某种形式采集到内部的AJAX请求参数，并转化成权限信息传递出来就完美了，然而我没找到可行的方法，并且这种形式在应用上也存在缺陷，因为不一定每个操作按钮都会发起AJAX请求，比如编辑按钮本身并不会触发请求，真正触发请求的是另一个保存按钮，所以这个思路只是看起来很美。</p><p>退而求其次的做法是让按钮和请求联系起来，比如说按钮涉及一个名称为A的请求，那么我希望权限指令可以这样写，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;btn v-has=&quot;A&quot; @click=&quot;Fn&quot;&gt;按钮&lt;/btn&gt;</span><br></pre></td></tr></table></figure><p>比完美形态是差了不少，但起码不需要手动维护到<code>&#39;get,/resources&#39;</code>这个级别了，这里对A的实现可以有多种形式，比如A可以是一个包含两个属性的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const A = &#123;</span><br><span class="line">  p: [&apos;put,/menu/**&apos;],</span><br><span class="line">  r: params =&gt; &#123;</span><br><span class="line">    return axios.put(`/menu/$&#123;params.id&#125;`, params)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//用作权限：</span><br><span class="line">&lt;btn v-has=&quot;[A]&quot; @click=&quot;Fn&quot;&gt;按钮&lt;/btn&gt;</span><br><span class="line"></span><br><span class="line">//用作请求：</span><br><span class="line">function Fn()&#123;</span><br><span class="line">    A.r().then((res) =&gt; &#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们会将项目里所有的api放在一个api模块里集中管理，在写api时顺便就把权限给维护了，换来的是在组件界面里可以直接用请求名称来描述权限，而不需要来回奔波于界面和api模块之间，一定程度上实现了关注点分离，而且has指令还可以进一步做优化，例如参数只需要接收A，指令内部根据约定自动访问A.p来获取权限，还可以接收数组，允许多个权限联合校验，尽可能降低按钮权限的维护成本。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>总结一下，因为我的项目包含了管理端和客户端的所有功能，角色差异比较大，因此路由权限没有在before钩子里做，而是在登录后启动前进行路由筛选，省去了每次都要在before钩子里做校验的麻烦；按钮权限使用自定义指令实现，并且将验证方法全局混入，便于在界面上使用<code>v-if</code>；最后为axios设置拦截器，作为权限控制的第二道防线。</p><p>好了，这就是我对前端权限控制的一些实践和思考，如有不当欢迎指正。</p><p>最后吐槽一下Element-UI，真心难看。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/08/29/%E5%9F%BA%E4%BA%8EVue%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>混合应用从开发到发布</title>
      <link>https://refined-x.com/2017/08/08/%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E4%BB%8E%E5%BC%80%E5%8F%91%E5%88%B0%E5%8F%91%E5%B8%83/</link>
      <guid>https://refined-x.com/2017/08/08/%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E4%BB%8E%E5%BC%80%E5%8F%91%E5%88%B0%E5%8F%91%E5%B8%83/</guid>
      <pubDate>Tue, 08 Aug 2017 06:47:56 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;前段时间基于&lt;a
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>前段时间基于<a href="//refined-x.com/HybridStart/">HybridStart</a>开发了一个公司内部APP，重走了一遍混合应用从开发到发布的整个流程，唤起了很多坑的记忆，也为HybridStart修复了不少细节bug，下面简单回顾一下过程中值得一提的几个点。</p><h2 id="开发前准备"><a href="#开发前准备" class="headerlink" title="开发前准备"></a>开发前准备</h2><p>基于APICloud+HybridStart开发混合应用的门槛是极低的，一个初级水平的前端开发就应该可以从容搞定，这里有一个详细的<a href="http://jingyan.baidu.com/article/eb9f7b6d60e18f869264e847.html" target="_blank" rel="external">混合应用新手入门教程</a>；对于有一定经验的开发者，在做好项目准备工作之后，应该排查以下几项东西有没有准备好：</p><ul><li>APP图标 200x200 png格式</li><li>APP启动页 1080x1920 格式不限</li><li>IOS测试证书和发布证书（安卓证书平台可以自动生成）</li><li>添加所需模块，移除冗余模块</li><li>核对<code>config.xml</code>中的信息，包括appID、权限信息</li></ul><p>以上都准备就绪后就可以在平台上打包一个”自定义Loader”，安装到安卓手机上，打开IDE，开启wifi调试，进入无忧无虑的APP开发阶段了。</p><h2 id="开发中可能遇到的坑"><a href="#开发中可能遇到的坑" class="headerlink" title="开发中可能遇到的坑"></a>开发中可能遇到的坑</h2><p>安卓上的问题自4.4.2之后就比较少了，可能出现的绝大多数问题都属于表现层面上的兼容问题，基本上都是由于ROM厂商对webview的篡改导致的，这次开发的APP面向的主要用户群体是IOS用户，安卓上面没有做大规模的测试，仅在开发中遇到了一个页面切换闪白色块的问题，表现为返回到部分页面时屏幕上会随机闪现大块的白色色块，页面进场后消失。首先排查模块，发现不是模块导致的，加上受影响的页面很固定，所以猜测问题出在webview上，可能是问题页面的部分样式写法触发了渲染bug，经过对样式的排查，果然找到原因了，是一个绝对定位的伪元素引起的，加上<code>transform:translate3d(0,0,0);</code>强制开启硬件加速之后解决了问题。</p><p>IOS上的问题历来是不多，但很奇葩，这次遇到的问题也算IOS上的一个经典问题了，就是把滚动元素的事件委托在<code>body</code>上无效，只能委托在<code>body</code>内的一个容器元素上，而且<code>body</code>的高度还必须自动，如果<code>body</code>高度<code>100%</code>，那么会出现更奇葩的情况，当前屏幕范围内的元素事件可以触发，滚动后新进入屏幕的元素事件不会触发，只能理解为滚动后相当于把<code>body</code>整体上移了，导致点击事件没有落在<code>body</code>元素上，而这毫无疑问是个bug。</p><h2 id="IOS上架"><a href="#IOS上架" class="headerlink" title="IOS上架"></a>IOS上架</h2><p>开发完成后最大的一个难关就是IOS上架了，这次上架总体还算顺利，被驳回一次是因为自己的疏忽，申请了一个没有必要的权限，因为HybridStart默认集成了百度地图插件并开发了定位相关的功能演示，所以在<code>config.xml</code>里申请了一个后台定位的权限，新APP并不需要定位和地图相关功能，因此将模块及相关代码都移除了，但百密一疏忘了将<code>config.xml</code>的权限删掉，导致被驳回，这里也给大家提个醒，如果要上架的话这些细节一定记得检查。</p><p>混合应用IOS上架另一个最常犯的错误就是忘了屏蔽自动更新，自动更新太方便了，基本所有的APP都会做，但如果IOS版要上架苹果商店，一定记得在IOS里隐藏相关功能按钮，否则一定上不了架的。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>经过这次项目的检验HybridStart已经准备好了应对各种类型的混合应用开发，代码仍在持续维护，文档主要内容已完成，解决方案部分和细节修缮我会抽时间完成。</p><p>附：</p><ol><li><a href="//refined-x.com/HybridStart/">HybridStart项目主页</a></li><li><a href="http://jingyan.baidu.com/article/eb9f7b6d60e18f869264e847.html" target="_blank" rel="external">混合应用新手入门教程</a></li><li>本次项目部分截屏</li></ol><p><img src="https://refined-x.com/asset/yjk-screen-1.png" alt="此处输入图片的描述"><br><img src="https://refined-x.com/asset/yjk-screen-5.png" alt="此处输入图片的描述"><br><img src="https://refined-x.com/asset/yjk-screen-2.png" alt="此处输入图片的描述"><br><img src="https://refined-x.com/asset/yjk-screen-3.png" alt="此处输入图片的描述"><br><img src="https://refined-x.com/asset/yjk-screen-4.png" alt="此处输入图片的描述"></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/08/08/%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E4%BB%8E%E5%BC%80%E5%8F%91%E5%88%B0%E5%8F%91%E5%B8%83/#disqus_thread</comments>
    </item>
    
    <item>
      <title>混合应用页面打开速度优化</title>
      <link>https://refined-x.com/2017/07/21/%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E9%A1%B5%E9%9D%A2%E6%89%93%E5%BC%80%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/</link>
      <guid>https://refined-x.com/2017/07/21/%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E9%A1%B5%E9%9D%A2%E6%89%93%E5%BC%80%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/</guid>
      <pubDate>Fri, 21 Jul 2017 07:15:58 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;我们都知道混合应用的流畅性不如原生应用，除了不能像原生一样轻松驾驭各种狂拽酷炫的效果，混合应用还有一个难以消除的弱点在于页面打开速度上，如果有机会在同一台手机上直接对比的话，这种差距是普通人都能直观感受到的，这主要是由于web页面每次打开前需要初始化，在那一瞬间需要完成DO
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>我们都知道混合应用的流畅性不如原生应用，除了不能像原生一样轻松驾驭各种狂拽酷炫的效果，混合应用还有一个难以消除的弱点在于页面打开速度上，如果有机会在同一台手机上直接对比的话，这种差距是普通人都能直观感受到的，这主要是由于web页面每次打开前需要初始化，在那一瞬间需要完成DOM创建、资源下载、样式渲染、js执行，这些时间消耗造成了按键按下与页面进场之间短暂的停顿，也造成了混合应用整体“不流畅，不跟手”的印象，HybridStart 1.1.1版本针对性的优化了页面打开速度，下面就介绍一下具体是怎么做的。</p><h2 id="怎么做优化"><a href="#怎么做优化" class="headerlink" title="怎么做优化"></a>怎么做优化</h2><p>混合应用乃至所有前端项目的优化工作，总结起来其实都是在试图消除延迟感，消除延迟感要从两方面着手，一是提升绝对速度，做到不慢；二是增加过度效果，填充停顿，让用户无瑕感知到慢；这两方面是做好优化的关键。</p><h2 id="提升绝对速度"><a href="#提升绝对速度" class="headerlink" title="提升绝对速度"></a>提升绝对速度</h2><p>在混合应用中打开一个页面，会发生如下几个事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">渲染完成 =&gt; 加载完成 =&gt; runtime就绪</span><br></pre></td></tr></table></figure><p>这三个事件是依次发生的，apicloud为了保证页面打开即是显示完整的，所以会在页面<em>加载完成</em>之后开始进场动画，这里是优化的关键，我们分析一下加载完成之前都发生了什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">载入DOM节点</span><br><span class="line">加载css/js/img</span><br><span class="line">页面渲染</span><br><span class="line">运行js</span><br><span class="line">js运行时创建DOM节点并渲染</span><br><span class="line">资源加载完成</span><br><span class="line">页面加载完成</span><br></pre></td></tr></table></figure></p><p>以上所有事情都发生在页面初始化，其中远程图片的加载是最耗时的，所以图片较多的页面建议使用<a href="//refined-x.com/HybridStart/docs/#lazyload%28%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%29">懒加载插件</a>，懒加载并不是简单的减少了第一批图片加载数量，而是将所有图片加载从初始化队列中移除，在页面打开后才开始加载，这能有效提高初始化速度，但代价是用户有大概率会看到图片加载过程，这里的取舍就需要分情况讨论了，我的建议是优先提升页面打开速度，多数情况下的图片加载过程不会造成很坏的用户体验。</p><p>排除掉图片之后，通常意义上讲已经没什么可优化的地方了，但在混合应用场景下，仍然有一部分提速空间可以被压榨，那就是js资源的加载和执行，与js相关的操作有这么几项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">载入js</span><br><span class="line">执行js</span><br><span class="line">js运行时创建DOM节点并渲染</span><br></pre></td></tr></table></figure></p><p>载入和执行本地js在桌面端可以被认为是实时的，但移动端的计算能力和IO能力都远差于桌面端，HybridStart中的每个页面需要加载一个配置文件和一个核心类库，核心类库运行后再异步获取页面脚本并执行，经过对比测试这些操作平均耗时在100ms左右，如果页面脚本中还有其他插件的引用或者同步创建DOM操作，那么耗时还会延长，并且会导致不同的页面打开速度差别很大。</p><p>我们知道混合应用页面打开后通常有一个进场动画，这个动画的时长默认300ms，所以我们可以想办法利用这300ms，将js相关操作从初始化队列中移除，转而在动画过程中进行，多数情况下所有的js加载和执行都可以在页面动画结束前完成，对用户体验的影响几乎为零，却可以提高页面初始化的速度。</p><p>具体实施过程是：先将页面底部脚本链接移除，写一段代码创建脚本节点，在合适的时机将脚本节点插入页面。关键是插入时机的选择，apicloud会监听页面加载完成事件，我们必须跳过这个时间节点，所以同步插入脚本是不行的，测试发现<code>apiready</code>事件可以跳过加载完成，而且耗时很少，完全可以被动画过程覆盖，因此就选择在<code>apiready</code>之后插入节点，可以满足需求，而且还带来一个不大不小的副产品，那就是业务代码不再需要<code>app.ready()</code>回调函数了，因为所有js的加载执行都在runtime就绪之后发生的。</p><p>优化后在测试机上普通页面的打开速度较之前至少提升100ms，对于大量依赖js运行的页面提速效果更明显。</p><h2 id="增加过度效果"><a href="#增加过度效果" class="headerlink" title="增加过度效果"></a>增加过度效果</h2><p>绝对速度的提升有明确的瓶颈，而且跟手机性能有很大关系，即使排除了图片和js的加载，页面初始化仍然需要处理DOM节点的创建和样式的渲染，为了保证用户体验这部分是无论如何都不能动的，但这部分操作的耗时多数情况下仍然能被用户感知到，这时我们只能使用障眼法，增加一些过度效果，减缓用户等待的焦虑感，v1.1.1中实验性的为<a href="//refined-x.com/HybridStart/docs/#list%28%E5%88%97%E8%A1%A8%29">列表组件</a>添加了触摸状态波纹效果，具体实现在<code>sdk/common.js</code>中，效果参见<a href="http://downloadpkg.apicloud.com/app/download?path=http://7xm7pq.com1.z0.glb.clouddn.com/8cb26eca4ee9f6ef2a06debb470b0eec_d" target="_blank" rel="external">v1.1.1示例APP</a>。</p><p>过渡效果更多的还是需要根据业务场景自定义，这个内置效果就当抛砖引玉了。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>项目主页：//refined-x.com/HybridStart/<br>项目文档：//refined-x.com/HybridStart/docs/</p><p>另外，HybridStart项目一直都是beta状态，近期手头正好有一个小项目，准备上手操练一下，估计近期将迎来bugfixed版本。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/07/21/%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E9%A1%B5%E9%9D%A2%E6%89%93%E5%BC%80%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/#disqus_thread</comments>
    </item>
    
    <item>
      <title>小程序上手指南</title>
      <link>https://refined-x.com/2017/07/20/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/</link>
      <guid>https://refined-x.com/2017/07/20/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/</guid>
      <pubDate>Thu, 20 Jul 2017 03:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;这是一门微信小程序入门课程，通过学习本节课程可以使你快速上手小程序开发，在学习这门课之前，需要你先具备基本的前端开发能力，包括html/css/JavaScrip，起码你得会切图，了解js语法。&lt;/p&gt;
&lt;h2 id=&quot;为什么学习小程序&quot;&gt;&lt;a
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>这是一门微信小程序入门课程，通过学习本节课程可以使你快速上手小程序开发，在学习这门课之前，需要你先具备基本的前端开发能力，包括html/css/JavaScrip，起码你得会切图，了解js语法。</p><h2 id="为什么学习小程序"><a href="#为什么学习小程序" class="headerlink" title="为什么学习小程序"></a>为什么学习小程序</h2><p>学习小程序之前要先了解，小程序是什么，有什么独特的地方值得我们一定要去学习它，小程序是<em>基于微信实现特定功能</em>的一种载体，同样基于微信实现功能的我们知道还有公众号和微网站，那小程序的特点是什么，我们用HTML5做一个手机站不行吗，再接入微信的SDK，功能也很强大，小程序最大的特点，就是可以拥有媲美原生App的流畅体验，这一点是非常诱人的，也是相比HTML5最大的优势，尤其学到后面你会发现小程序的开发还特别简单，开发又简单体验又好，天底下哪有这么便宜的事，但小程序就是这样一个东西。</p><p>小程序为什么能做到接近原生的体验呢，这是因为小程序在底层就是调用的原生组件，我们开发小程序编写的前端代码，可以理解为是调用微信内部原生组件的快捷方式，因此，开发小程序使用的必然是一种全新的语言，不可能是HTML5，本节课程就是带领大家一起来学习这门语言，并且完成一个小示例，让大家可以快速的对小程序开发有一个直观的认识。</p><h2 id="小程序开发语言介绍"><a href="#小程序开发语言介绍" class="headerlink" title="小程序开发语言介绍"></a>小程序开发语言介绍</h2><p>小程序的开发语言跟HTML5是非常相似的，视图层的两种语言WXML和WXSS就分别对应了HTML和CSS，逻辑层就仍然还是Javascript，为了便于理解，下面我就用小程序和HMLT5对比的方式，来讲解小程序的这三种开发语言。</p><p>首先我们说区别最小的，就是小程序里的这个JS，它跟web开发中的JS只有两点区别，第一，没有任何DOM操作相关功能，这一点跟Nodejs是一样的，大家知道Js语言本身就是不包括DOM操作的，DOM操作是浏览器环境为JS做的扩展；第二点区别，小程序里的Js增加了一些微信特有的API，这个很好理解，像微信扫码啊，上传下载啊这些功能，肯定是要单独提供API的。总结一下，去掉了DOM操作，增加了一些API，另外值得一提的是小程序中的js是支持模块化的，也支持ES6。</p><p>WXSS与CSS的区别，也是两点，第一，增加了一个rpx单位，这个单位具有自动适应屏幕宽度的特点，规则是1rpx = 屏幕宽度/750，这是个很好用的单位，可以说完美解决了屏幕适配的问题，如果你用过HTML5里的vw单位，会发现他俩是一回事，只不过1vw = 屏幕宽度/100，比例不太一样；第二个区别，WXSS支持的选择器类型有限，目前只支持<code>.class, #id, element, ele,ele, ::before, ::after</code>，注意，后代选择器是不支持的，这个我再开发工具里测试发现可以支持，但文档是明确说只支持上面那些，那我们就听文档的，后代选择器就不要用了。总结一下，WXSS相比CSS增加了rpx单位，不支持后代选择器；</p><p>最后WXML这块的内容比较多，尤其有一部分HTML里完全没有的东西，比如说数据绑定、条件渲染、列表渲染、模板、引用，这些东西我在这里就不展开讲了，如果你之前用过任何的前端MVVM框架或者前端模板引擎，那对这块内容应该是轻车熟路的，如果说这些东西都不知道，那也没关系，自己回去把文档这块内容仔细的阅读一遍，相信都能看明白是怎么回事。</p><p>这里我们就说两个东西，标签和事件，首先，标签彻底换了一套，所有的HTML标签都不能用，取而代之的是小程序提供的一套标签，官方把他们叫组件，不管叫什么，这个组件的写法和HTML标签是一样的，也是由标签名，属性，内容组成，也可以嵌套，也可以通过<code>class，id，style</code>来添加样式，但是小程序组件相对来说拥有更强大的功能，自带样式也更丰富，举个例子，</p><p><img src="https://refined-x.com/asset/weapp-picker.png" alt="weapp-picker"></p><p>如果要做这样一个从底部弹起的滚动选择器，想想是不是好麻烦，有很多样式和js要写，但是用小程序的组件来做，一个picker组件拿过来，全有了，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;picker bindchange=&quot;pickerChange&quot; value=&quot;&#123;&#123;index&#125;&#125;&quot; range=&quot;&#123;&#123;array&#125;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure><p>代码就这么多，样式都是自带的，工作量一下就小了很多，这是小程序在设计上非常好的一点，它在背后做了很多封装，就为了让开发者开发起来简单，实际上也达到了目的；</p><p>小程序的事件与HTML5里的事件，有哪些不一样呢，第一个就是事件绑定的写法不一样了，小程序里是bind+事件名或catch+事件名，bind绑定不阻止冒泡，而catch会阻止冒泡；另外支持的事件种类也不一样，常规事件只支持<code>touchstart，touchmove，touchend，touchcancel，tap，longtap</code>，除了这些事件以外，再有的事件就是组件的自定义事件，比如picker组件就有一个change事件，可以通过bindchange来绑定处理函数；第三个区别是事件对象不一样了，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;type&quot;:&quot;tap&quot;,</span><br><span class="line">&quot;timeStamp&quot;:895,</span><br><span class="line">&quot;target&quot;: &#123;</span><br><span class="line">  &quot;id&quot;: &quot;tapTest&quot;,</span><br><span class="line">  &quot;dataset&quot;:  &#123;</span><br><span class="line">    &quot;hi&quot;:&quot;WeChat&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;currentTarget&quot;:  &#123;</span><br><span class="line">  &quot;id&quot;: &quot;tapTest&quot;,</span><br><span class="line">  &quot;dataset&quot;: &#123;</span><br><span class="line">    &quot;hi&quot;:&quot;WeChat&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;detail&quot;: &#123;</span><br><span class="line">  &quot;x&quot;:53,</span><br><span class="line">  &quot;y&quot;:14</span><br><span class="line">&#125;,</span><br><span class="line">&quot;touches&quot;:[&#123;</span><br><span class="line">  &quot;identifier&quot;:0,</span><br><span class="line">  &quot;pageX&quot;:53,</span><br><span class="line">  &quot;pageY&quot;:14,</span><br><span class="line">  &quot;clientX&quot;:53,</span><br><span class="line">  &quot;clientY&quot;:14</span><br><span class="line">&#125;],</span><br><span class="line">&quot;changedTouches&quot;:[&#123;</span><br><span class="line">  &quot;identifier&quot;:0,</span><br><span class="line">  &quot;pageX&quot;:53,</span><br><span class="line">  &quot;pageY&quot;:14,</span><br><span class="line">  &quot;clientX&quot;:53,</span><br><span class="line">  &quot;clientY&quot;:14</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义事件会有detail属性，touch事件包括两个不同的属性，这些东西不用记，用到的时候知道去哪找就行了，总结一下，事件绑定的写法bind/catch，事件类型6种+组件自定义事件，事件对象的内容有区别；</p><h2 id="小程序开发框架介绍"><a href="#小程序开发框架介绍" class="headerlink" title="小程序开发框架介绍"></a>小程序开发框架介绍</h2><p>掌握了小程序的开发语言之后，我们还必须掌握小程序的开发框架，框架故名思意就是条条框框，是用来具体的告诉你怎样开发小程序，我们先看一下小程序的目录结构，</p><p><img src="https://refined-x.com/asset/weapp-tree.png" alt="weapp-tree"></p><p>这是一个比较典型的微信小程序项目结构，最下面三个文件名字都叫app，一个js一个json一个wxss，这三个是固定的，就得叫这个名字，就得放在这，另外的三个文件夹分别是放页面、放样式的、放工具类的，当然你可以根据项目实际需求随便改。</p><p>其中这个app.json就是小程序的配置文件，可以看到打开里面是一个对象，配置了页面和window的一些属性，具体还有哪些配置以及他们的意义可以自己到文档中去进一步的了解。</p><p>然后我们就从上往下说这个目录结构，首先你会发现页面是以文件夹为组织单位的，每个页面至少要包含<code>js    wxml wxss</code>这三个文件，而且这些文件都跟文件夹同名，这是一个约定，必须这么干，然后还有一个json文件是可选的，里面可以对当前页面做单独的设置。下面这个util文件夹没什么说的，不是硬性要求，可有可无。再然后app.js，这个文件是非常重要的，它主要做两件事，一是定义小程序的生命周期函数，二是可以在这里定义全局数据或全局方法，我们看代码，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//app.js</span><br><span class="line">App(&#123;</span><br><span class="line">  onLaunch: function () &#123;</span><br><span class="line">    //调用API从本地缓存中获取数据</span><br><span class="line">    var logs = wx.getStorageSync(&apos;logs&apos;) || []</span><br><span class="line">    logs.unshift(Date.now())</span><br><span class="line">    wx.setStorageSync(&apos;logs&apos;, logs)</span><br><span class="line">  &#125;,</span><br><span class="line">  getUserInfo:function(cb)&#123;</span><br><span class="line">    var that = this</span><br><span class="line">    if(this.globalData.userInfo)&#123;</span><br><span class="line">      typeof cb == &quot;function&quot; &amp;&amp; cb(this.globalData.userInfo)</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      //调用登录接口</span><br><span class="line">      wx.login(&#123;</span><br><span class="line">        success: function () &#123;</span><br><span class="line">          wx.getUserInfo(&#123;</span><br><span class="line">            success: function (res) &#123;</span><br><span class="line">              that.globalData.userInfo = res.userInfo</span><br><span class="line">              typeof cb == &quot;function&quot; &amp;&amp; cb(that.globalData.userInfo)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  globalData:&#123;</span><br><span class="line">    userInfo:null,</span><br><span class="line">    apiKey: &quot;c2d3e04cc633644f1c3ae3f6eea94564&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个onLaunch就可以定义一个小程序初始化的回调，下面getUserInfo显然就是一个自定义的函数了，再往下是一个globalData属性，也是自定义的，用这些配置将小程序初始化后，可以在任意页面中使用getApp()方法获取到小程序示例，进而访问到这些自定义方法或数据。</p><h2 id="开发一个《星座配对》小程序"><a href="#开发一个《星座配对》小程序" class="headerlink" title="开发一个《星座配对》小程序"></a>开发一个《星座配对》小程序</h2><p>《星座配对》小程序功能虽然很简单，但大多数小程序开发常用的API都用到了，是一个很好的上手项目。</p><p>源码：<a href="https://github.com/tower1229/weapp-star" target="_blank" rel="external">weapp-star</a></p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/07/20/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E6%89%8B%E6%8C%87%E5%8D%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hexo自定义页面的方法</title>
      <link>https://refined-x.com/2017/07/10/Hexo%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <guid>https://refined-x.com/2017/07/10/Hexo%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <pubDate>Mon, 10 Jul 2017 06:06:46 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;Hexo是静态页博客生成利器，同很多博主一样，&lt;a href=&quot;//refined-x.com&quot;&gt;前端路上&lt;/a&gt;原创技术博客也是使用Hexo生成并托管在Github
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>Hexo是静态页博客生成利器，同很多博主一样，<a href="//refined-x.com">前端路上</a>原创技术博客也是使用Hexo生成并托管在Github Page上的，但在使用Hexo的过程中遇到一个小问题，Hexo默认会对<code>/source/</code>里的所有页面应用主题模板渲染，但有一些前端作品或demo页我们不希望经过渲染，而是能保持完全自定义的样子，那该怎么用Hexo添加自定义的web页面呢？</p><p>下面介绍两种方法。</p><p>第一种方法是使用Hexo提供的跳过渲染配置，适用于整个目录的设置。具体步骤，打开博客根目录<code>_config.yml</code>，找到其中<code>skip_render</code>项，这个项目用来配置<code>/source/</code>中需要跳过渲染的文件或目录，例如希望跳过<code>/source/projects/</code>里的所有文件渲染，可以配置为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip_render: projects/**</span><br></pre></td></tr></table></figure></p><p>匹配规则是一种类似正则的规则，官方给出的参考是<a href="https://github.com/isaacs/minimatch" target="_blank" rel="external">这个</a>。另外在测试这个功能的时候发现，Hexo的内部缓存不是特别好用，有时候你修改了配置但生成出来的内容不一定及时应用了新配置，最好在生成之前执行一下<code>hexo clean</code>命令，清除掉旧的生成文件和缓存。</p><p>第二种方法是给单个文件添加不应用模板的标记，适用于个别特殊文件的处理。例如我们的网站如果要使用百度统计，往往需要在根目录放一个html格式的验证文件，这个文件默认也会经过用主题模板渲染，避免渲染的办法就是在文件头部添加如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">layout: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>这样，这个文件就不会经过模板渲染，最终发布到<code>/public/</code>里的文件就是去掉标记后的文件的样子。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/07/10/Hexo%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%96%B9%E6%B3%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HybridStart v1.0开发纪要</title>
      <link>https://refined-x.com/2017/07/07/HybridStart%20v1.0%E5%BC%80%E5%8F%91%E7%BA%AA%E8%A6%81/</link>
      <guid>https://refined-x.com/2017/07/07/HybridStart%20v1.0%E5%BC%80%E5%8F%91%E7%BA%AA%E8%A6%81/</guid>
      <pubDate>Fri, 07 Jul 2017 06:58:47 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;自混合应用前端开发框架&lt;code&gt;HybridStart v1.0&lt;/code&gt;&lt;a
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>自混合应用前端开发框架<code>HybridStart v1.0</code><a href="//refined-x.com/2017/07/03/%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF%E6%A2%B3%E7%90%86/">升级计划</a>开始后，经过近一周的开发测试，现已发布<a href="https://github.com/tower1229/HybridStart" target="_blank" rel="external">预览版</a>，基本实现了最初定下的四个目标：核心易用、UI可剥离、开发模式清晰、开发体验优秀，这也是我理想中的以web前端技术为主的，混合应用开发的正确姿势。在这个过程中将一些笼统的思路细化并落地，也将一些过去思路不对的地方推倒了重构，在通用性方面也做了更多的考量，下面就从核心和UI两大部分入手，详细拆解一下升级后的HybridStart。</p><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><h3 id="移除依赖"><a href="#移除依赖" class="headerlink" title="移除依赖"></a>移除依赖</h3><p>之前的<code>core.js</code>直接集成部分第三方插件，并且内部实现也互相依赖，这对于不同技术栈的开发者来说很不友好，比如有的开发者喜欢用Vue做模板渲染，那他看到依赖jQuery后心里一定恶心无比，因此要做的第一件事就是移除核心库的依赖。</p><p>移除掉jQuery势必就要自己动手做一个<code>util</code>工具类，以简化原生JavaScript语法，这里我偷了个懒直接把mui的部分代码拿过来，稍作修剪和扩充就ok了。在功能取舍方面，除了满足核心库的需求外还增加了少数几个常用操作，使这部分功能对外开放后能一定程度上发挥jQuery的作用，通过<code>app.util</code>可以获取到这个内部工具集合，经过内置示例的开发体验，应该说只要DOM操作不是很重的情况，基本可以让jQuery歇息了，当然前提是大量的jQuery语法糖都不能用了，其实用习惯了原生语法，会觉得除了单词长一点也并没有多麻烦。</p><h3 id="功能梳理"><a href="#功能梳理" class="headerlink" title="功能梳理"></a>功能梳理</h3><p>框架功能都挂载在<code>app</code>对象上，主要提供这五类功能：核心功能、窗口操作、数据操作、设备访问、原生控件。</p><h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h4><p>核心功能以APP运行周期内的事件或操作为主，比如各种事件监听、按键监听，全局事件的发布/订阅，原生能力就绪的回调方法等，这些方法都直接挂载在<code>app</code>对象上，例如<code>app.ready(callback)</code>。</p><p>着重说一下原生能力就绪回调，HybridStart里一个典型的页面js文件是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * script</span><br><span class="line"> */</span><br><span class="line">define(function(require) &#123;</span><br><span class="line">    require(&apos;sdk/common&apos;);</span><br><span class="line">    var $ = app.util;</span><br><span class="line">    //立即执行</span><br><span class="line"></span><br><span class="line">    app.ready(function() &#123;</span><br><span class="line">    //runtime就绪</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>可以看到正文明显被<code>app.ready()</code>方法分隔成上下两部分，上面空白处的代码将在页面加载后立即执行，ready回调内的代码将等待原生能力就绪后被执行，我们鼓励将所有不需要原生能力的操作放在上面，以提升脚本响应速度，这个没什么问题。</p><p>但可能遇到的一个问题是，如果一个依赖原生能力的功能被开发者立即执行了，将会因为runtime未就绪而报错，也就是说需要开发者明确的知道那些功能依赖runtime哪些不依赖，如果试图解决这个问题很容易想到的一个办法是，将所有依赖runtime的功能在内部用ready方法包裹一下，这样表面上可以解决问题，但因为ready的异步特性，可能导致代码执行顺序与书写顺序不一致，这无疑是不可接受的。最终在两者间做了妥协，将这些功能在内部用另一个readyEval方法包裹，readyEval方法仅仅在检测到runtime未就绪时给控制台抛出调试信息，而不会中断后续代码的执行，算是一个容错性的处理吧。</p><h4 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h4><p>窗口操作包括对window和frame的常用操作，比如打开、关闭、移动、执行脚本等，这些方法都挂载在<code>app.window</code>对象上，例如<code>app.window.open()</code>。</p><p>作为最基础也最常用的操作，封装目标就是易用，比如打开窗口这个操作，即便有了<code>app.window.open()</code>也仍然觉得不够简单，因此进一步封装了<code>app.openView()</code>，可以说让绝大多数场景下的打开窗口变得极致简单了，看下两个方法的对比：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.window.open(&#123;</span><br><span class="line">    url:&apos;./view/member/index/temp.html&apos;,</span><br><span class="line">    pageParam: &#123;</span><br><span class="line">        id: 123</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.openView(123, &apos;member&apos;, &apos;index&apos;);</span><br></pre></td></tr></table></figure></p><p>openView方法的详细介绍可以参见<a href="//refined-x.com/2017/06/26/%E5%9F%BA%E4%BA%8EAPICloud%E7%9A%84%E6%B7%B7%E5%90%88%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/">这里</a>，openView的参数传递是借助本地存储实现的，这次升级也为其配套了一个获取参数的方法<code>app.getParam()</code>，专门用来获取openView方法传递的参数，并且支持对象类型的存取。</p><h4 id="内建机制"><a href="#内建机制" class="headerlink" title="内建机制"></a>内建机制</h4><p>简化开发另一个很重要的方向是内建机制，举个例子，实现会员退出登录，需要跳转到登录页同时关闭所有后台页面，关闭后台页面的功能apicloud提供了，但本着<em>尽量不使用特定平台提供的特殊能力</em>原则，这个功能在框架中用另一种方式实现了，而且使用起来超简单，比如可以这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.openView(&#123;</span><br><span class="line">    closeback: true</span><br><span class="line">&#125;, &apos;member&apos;, &apos;login&apos;);</span><br></pre></td></tr></table></figure></p><p>内部实现是，每一个页面打开后会在window上挂载一个”isBack”属性，通过监听本窗口的前后台状态更改这个属性的值，当openView方法的closeback被设置为<code>true</code>时，将在打开新页面前在本地存储埋下一个标记，新页面打开后通过这个标记得知自己的任务，然后发布一个相应的全局事件，所有页面都能通过这个事件得知自己的任务，比如任务是<em>关闭后台页面</em>，那么就会检查自己的<code>window.isBack</code>属性，发现是真值就关闭自身，从而完成这个任务。</p><p>其实就是利用全局通信能力建立起来的关闭机制，依据这个思路，还可以扩展出打开新窗口同时关闭自身的方法，比如订单提交场景，提交成功后通常会跳转到一个提示页，但是我们不希望从这个提示页可以返回到刚才的提交订单页，所以希望打开提示页的同时关闭订单页，那么实现的代码将是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.openView(&#123;</span><br><span class="line">    closeself: true</span><br><span class="line">&#125;, &apos;shop&apos;,&apos;orderSubmitSuccess&apos;)</span><br></pre></td></tr></table></figure></p><p><code>closeself</code>与<code>closeback</code>的区别仅仅是给当前页面增加了一个”closeByNew”的属性，然后本地存储埋了另外一个标记，发布了另外一个任务，新页面打开后照例发布全局事件公布任务，订单页收到任务后发现自己具有”closeByNew”属性，于是关闭了自身。</p><p>这些功能都集成在openView方法的配置中，说起来很罗嗦，用起来确特别简单，这类问题只在安卓系统上有，因为IOS没有返回键，只要界面不提供返回按钮用户是不可能随意返回上一个页面的。</p><p>框架另外还做了一件事，就是为frame页面的window对象扩展了一个”selfTop”属性，属性值是当前frame距离屏幕顶部的距离，这个值当在frame需要打开带界面的原生插件时很有用，比如打开百度地图，需要你指定地图距离屏幕顶部的距离，如果frame不知道自己距离屏幕顶部有多远，就不可能知道这个值应该是多少，这也算一个隐性需求，不用不知道，用了都说好。</p><h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><p>数据操作分为数据请求和数据存储两块内容。</p><p><strong>数据请求</strong>也就是<code>app.ajax()</code>方法，主要用来异步获取数据，当然也包括上传和下载，但他们都被单独封装成了插件，这里不做讨论。</p><p><code>app.ajax()</code>在易用性上的改进体现为增加了默认错误处理，约定交互格式以及格式检查，api风格几乎照搬<code>jQuery.ajax</code>，没有太多值得说的。在此基础上<code>app.ajax()</code>还针对APP开发场景做了两项功能扩展，一是请求加密，二是快照式缓存。</p><p>请求加密通过默认集成的加密模块<code>app.crypto</code>实现，加密算法为3DES，加密后的所有Ajax请求将集中发送到一个url地址，本次请求的真实url和参数以特定方式组织并加密，并将密文以参数形式发送，服务端需要有对应的解密方法得知请求url和参数，并将返回数据也做3DES加密返回给前端，前端解密后得到真实数据，整个过程中的关键是3DES算法的<code>secret</code>，这个值使用apicloud提供的加密存储方式存储，APP被反编译也无法拿到这个密匙，因此理论上实现不可逆加密。至于加密请求为什么要集中发送到一个url，其实是因为之前有的项目后端是这样处理的，如果要修改这个加密逻辑其实也很简单，详细的加密过程参考文档，这里不做赘述（如果发现文档没写完，也请不要奇怪- -!）。</p><p>ajax缓存功能apicloud的原生接口也有提供，不过他的缓存是没有更新机制的，一次缓存终生使用，除非做全局的缓存清理，简单说，这个功能很鸡肋。<code>app.ajax()</code>专门增加了一种快照式缓存，每一次请求成功后都会将结果保存为快照，下次这个请求再发起时会先将快照结果返回，待真实数据到达后再返回真实数据，也就是说启用快照缓存的请求将执行两次回调，这个听起来有点奇葩，但应用场景确很普遍，比如说打开一个列表页，通常要有一个loading然后请求到数据后显示到页面上，而使用快照缓存的结果是，打开页面马上呈现最近一次的数据，待新数据拿到后再更新一次页面，我认为这是体验更佳的方式。</p><p>可能有的同学会想，如果单纯只是渲染页面还好，万一请求数据后还有一些业务操作，那你执行两次肯定是不行的，没错，为了解决这个问题，快照数据如果是对象的话，会自动为这个数据增加一个”snapshoot”属性，你可以通过检测这个属性来得知当前数据是否为快照，以避免业务操作重复执行。</p><p>快照缓存目前来看的问题是，没有做新数据与快照是否相同的检测，导致如果两次数据相同，也会让页面白白重新渲染一次，后续会考虑改进这个功能。</p><p><strong>数据存储</strong>模块提供本地数据的增删改查功能，适用于少量应用数据的存储方法挂载在<code>app.storage</code>对象上，比如<code>app.storage.val()</code>。</p><p>因为是依托<code>localStorage</code>实现的，所以原来不支持对象类型的存取，这次升级支持了对象类型，其实也就是内部自动做了转化；另外增加了一个<code>app.storage.clear()</code>方法，用来清除存储的数据，但我们常常会有一些数据是希望能不受影响的、持久的存储，比如用户信息、权限等等，那么可以将这些值的key加到配置文件中的<code>appcfg.set.safeStorage</code>安全存储项目里，多个值用逗号隔开，”clear”方法默认会跳过不清理这些存储项，除非启用强制清理。</p><p>顺带说另外一个相关的配置<code>appcfg.set.temporary</code>临时存储，这个配置的意思是这些值每次APP退出后都将自动清除。</p><h5 id="设备访问"><a href="#设备访问" class="headerlink" title="设备访问"></a>设备访问</h5><p>设备访问能力提供对手机硬件的信息获取和其他操作能力，比如获取系统信息、拨打电话、安装文件等等，他们被挂载在<code>app.device</code>对象上，例如<code>app.device.call()</code>。</p><p>这部分就是单纯的封装引擎功能，没什么可说的，目前支持的功能并不很多，因为这些东西我用的不多，不确定哪些是必要的，所以这部分有待后期观察，再做调整。</p><h4 id="原生控件"><a href="#原生控件" class="headerlink" title="原生控件"></a>原生控件</h4><p>原生控件就是系统自带的UI控件，比如loading、alert、confirm、actionSheet等，因为还比较常用所以直接挂载到了<code>app</code>对象上，比如<code>app.alert()</code>。</p><p>这部分一开始我还纠结要不要封装，因为他们应该归到UI层面，既然是UI的东西核心里不应该集成，但想了想，目前apicloud没有一个拿得出手的同类插件，总得有东西用啊，所以就封装进来了。这肯定不是个长久之计，因为大部分安卓系统的原生控件实在太丑，这个后期再想想办法，争取解决掉。</p><p>目前有一个不成熟的思路是用web来做，但web有一个致命的问题是可能受到frame窗口的限制，无法做到模态，还可能被其他控件遮挡，这个问题可以通过打开一个透明window来解决，在这个window上显示控件，操作后再隐藏到底层去，可能的问题有两个，一个是响应速度不知道够不够快，再就是跨窗口通信内容比较多，可能导致实现很复杂，进一步拖慢速度。最好还是找到一个靠谱的原生插件。</p><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><h3 id="css组件"><a href="#css组件" class="headerlink" title="css组件"></a>css组件</h3><p>框架自带一套css组件放在<code>sdk/ui.css</code>中，这次经过小幅修改，着重删掉了一些冗余代码和微调了部分组件的样式。</p><p>为了实现<em>UI可剥离</em>，放弃了之前做的主题功能，这个主题功能简单说就是页面一开始是隐藏的，模板引擎解析得到主题css后动态插入页面才让页面显示出来，从性能角度讲放弃这种做法也算是走上了正道，但我记得之前在一次项目中发现，部分安卓机会出现页面打开之初先按照物理分辨率解析，随后布局抖动再恢复为像素分辨率，感觉是webview打开过程发生了一个异步的调整，这个体验是毁灭性的，主题功能的另一个作用就是解决这个问题，不过现在我已经找不到那台测试机了，目前这个问题是否还存在是未知的，有待经过实际项目检验。</p><p>如果不满意这套UI是可以直接抛弃掉的，跟框架其他部分几乎没有耦合，如果感觉还能凑合用，换主题功能就只能通过修改<code>less</code>文件来实现了，<code>less</code>文件估计将在文档写完后放出，在这之前暂时只能手动改样式了。</p><h3 id="js插件"><a href="#js插件" class="headerlink" title="js插件"></a>js插件</h3><p>框架内置了部分常用插件，比如图片轮显、相册、各种选择器、滚动加载、图片懒加载等等，体验都还不错，部分来自<a href="//refined-x.com/Flow-UI/docs/">Flow-UI</a>的插件库，针对移动端做了微调，使用上还是一贯的模块化。</p><p>虽然有了<code>app.util</code>之后就不再提倡使用jQuery了，但如果有人在乎的话，内置jQuery的版本已经升级到3.x。</p><p>原来内置在<code>core.js</code>里的<code>etpl</code>也成为了一个插件模块，用来实现前端页面渲染。应该说开发混合应用免不了大量的页面渲染，Vue当然是最好用的工具之一，但把一个功能完备的MVVM框架拿来做渲染，总觉得的有点冗余，而且依我过去的项目经验，大部分渲染其实都是单向的，也就是展示型的，需要将界面操作反应到数据中的情况不太多，在这种情况下，单从代码利用率的角度讲前端模板引擎是“实惠”的选择。</p><p>但模板引擎的使用体验比Vue差太多了，先要解析模板，再应用数据，最后填充到页面中，为了减轻这部分负担插件库中提供了一个<a href="https://flow-ui.refined-x.com/docs.html#Render(%E6%B8%B2%E6%9F%93%E5%99%A8" target="_blank" rel="external">Render</a>)插件，可以实现<code>数据=&gt;界面</code>的单向绑定，除了不是双向绑定，在渲染操作上已经接近Vue的体验了，当然差别还是有的，因为内部是使用<code>etpl</code>实现的，并没有高大上的差量更新，所以大范围的页面更新理论上效率不如Vue，这个有待低端机测试，千元以上的手机应该不太会看出差别。</p><p>当然，这些也都属于UI，可以用自己喜欢的任意方案替换掉。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>还有一些功能，散布在框架<code>sdk/</code>里的common.js和server.js中，严格来说这些代码已经不属于框架核心范畴，开发者可以根据自己的业务情况做删改，但其中有一些还是很实用的，举个例子。</p><p>不知道大家有没有发现，apicloud在引擎层面对页面显示做了优化，打开一个页面前多少会有一点停顿，猜测是在页面没有完全渲染完之前不会开始进场动画，因此有动态渲染内容的页面打开会很迟钝，纯静态的页面打开就利索很多，虽然这可以有效解决布局闪动的问题，但有时候这并不是开发者想要的，而造成打开速度差异的最重要原因就是图片元素的加载，所以为了解决这个问题，我们可以先将页面里的图片”src”值赋给”data-src”，使图片不会立即加载，当页面显示完毕后再将”data-src”赋给”src”以加载图片，从而绕过引擎的优化方案，提升页面打开的响应速度，这个操作已经在框架默认的<code>sdk/common.js</code>中实现了，并在示例APP中部分应用，效果明显。</p><p>common.js和server.js中还有很多实用的功能，比如图片自动缓存、给按钮添加点击效果、封装获取经纬度功能、通过经纬度反查地址功能、推送功能等等，具体有啥就自己去看吧，这里不一一列举了。</p><h2 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h2><h3 id="瓶颈明显"><a href="#瓶颈明显" class="headerlink" title="瓶颈明显"></a>瓶颈明显</h3><p>混合应用目前的体验确实不理想，为此我还特地对比性的研究了下Dcloud，感觉文档好专业好极客，各种优化手段好极致，但他们的体验APP也并有明显的流畅性差异，所以我甚至认为，这就是以web技术为主的混合应用开发模式的瓶颈，这种体验跟当下大家对主流APP的期待已经产生了不小的差距，做混合应用很重要的一项工作就是修补这些瑕疵。</p><p>要说apicloud跟Dcloud完全没差别也是不准确的，粗略的看至少有两点apicloud不如Dcloud做的好，第一是apicloud的后台页面更容易被回收，当连续打开几个apicloud应用页面后切到其他稍微重一点的APP操作一会儿，再切回apicloud，然后返回上一个页面会发现页面已经空白了，需要重新渲染；同样的手机同样的场景Dcloud应用不存在这个问题。第二是apicloud缺少页面预加载功能，Dcloud的示例应用中利用预加载做了列表到详细页最佳实践，有力证明了预加载的价值，而这个需求被提交给apicloud后，管理员的回复是</p><blockquote><p>“打开页面其实用不着进行预加载，正常的openWin打开然后加载已经足够了。”</p></blockquote><p>最终示例APP中只能勉强用frame模拟了详细页预加载，用frame模拟的缺点有两个，一是frame无法实现“推入”效果，只能“飞入”，因此可能与APP的全局页面切换效果相违背；第二点更致命，因为frame是依赖window的，也就是说不同的列表页无法共享预加载的详细页，即便同一个列表页只要退出了，下次进来也需要重新预加载详细页。</p><h3 id="曲线救国"><a href="#曲线救国" class="headerlink" title="曲线救国"></a>曲线救国</h3><p>刚开始接触混合应用时很喜欢搞一些看上去“很原生”的效果，比如划出菜单、滑动选项卡式列表之类的，后来发现实现是能实现，但结果太糟糕了，因为这些东西太重了，不是web能消费得起的，不要用web的弱点去死磕。</p><p>在整体的体验把控上我的看法是，只要功能实现了，有没有某个特效是第二位的，APP的流畅体验和赏心悦目永远是第一位的，尤其要避免任何反常的界面表现，比如web特有的布局抖动和界面先空白后闪现，都会给用户造成“不稳定”的心理暗示，这些问题稍微用点心其实都可以克服。比如frame第一次打开就会出现典型的闪动现象，这时候就需要做预加载，可以参考示例APP的首页第四个栏目，在做了预加载之后有效避免了闪动，而且可以秒开。</p><p>像侧滑菜单这种东西，多数情况都可以用一个从左往右打开的页面来代替，流畅性有保证，开发难度也低，不一定非得是侧滑到屏幕一半。</p><p>web开发的优势在于布局的灵活性，利用好这一点有时候能让原本不那么好的体验变得可以接受，比如给列表页实现占位元素，实现成本非常低，却能有效降低等待加载的焦虑感，可以参考示例APP的<em>列表到详细页</em>。</p><p>总结起来，从绝对性能上混合不可能比得过原生，混合能做的就是用各种手段提高用户的忍耐阈值，或者转移用户的注意力。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>文档正在撰写中，目前线上的文档版本仅供娱乐。</p><p>未经实际项目检验，渴望暴风雨猛烈抽打，感兴趣的<a href="https://github.com/tower1229/HybridStart" target="_blank" rel="external">戳此</a>Star。</p>]]></content:encoded>
      
      <comments>https://refined-x.com/2017/07/07/HybridStart%20v1.0%E5%BC%80%E5%8F%91%E7%BA%AA%E8%A6%81/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
